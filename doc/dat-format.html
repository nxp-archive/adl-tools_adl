<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="standard header">
  <link type="text/css" rel="stylesheet" href="/swo/css/fsl.css" />
  <script type="text/javascript" language="javascript" src="/swo/jscripts/FSLHeader.js"></script>
  <script language="JavaScript"> 
        WriteFSHeader(); 
  </script> 
</div></div>
<div class="footer">
<hr class="footer" />
<a class="first last reference" href="./fsl-header.rst">View document source</a>.
Generated on: 2018/02/28 15:14:25 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<title>The ADL Trace Format</title>
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="title section" id="the-adl-trace-format">
<h1><a>The ADL Trace Format</a></h1>
<div class="section" id="a-description-of-dat-files">
<h2><a href="#id3" name="a-description-of-dat-files">A Description of DAT Files</a></h2>
<p>This document describes the ADL trace file format, known as DAT.  This is a
simple textual format capable of describing a microprocessor system's initial
state, events which occur during simulation, and a final result state.  The
format is designed to be easily parseable by common scripting languages such as
Perl and to be extensible so that as new resource types are added to ADL, the
DAT format can be extended to handle them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Brian Kahne</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body"><a class="reference" href="mailto:bkahne&#64;freescale.com">bkahne&#64;freescale.com</a></td>
</tr>
</tbody>
</table>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first"><a name="table-of-contents">Table of Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#the-adl-trace-format" id="id2" name="id2">The ADL Trace Format</a><ul class="simple">
<li><a class="reference" href="#a-description-of-dat-files" id="id3" name="id3">A Description of DAT Files</a><ul class="auto-toc simple">
<li><a class="reference" href="#the-file-format" id="id4" name="id4">1&nbsp;&nbsp;&nbsp;The File Format</a><ul class="auto-toc simple">
<li><a class="reference" href="#overview" id="id5" name="id5">1.1&nbsp;&nbsp;&nbsp;Overview</a></li>
<li><a class="reference" href="#comments" id="id6" name="id6">1.2&nbsp;&nbsp;&nbsp;Comments</a></li>
<li><a class="reference" href="#commands" id="id7" name="id7">1.3&nbsp;&nbsp;&nbsp;Commands</a></li>
<li><a class="reference" href="#sections" id="id8" name="id8">1.4&nbsp;&nbsp;&nbsp;Sections</a></li>
</ul>
</li>
<li><a class="reference" href="#recognized-commands" id="id9" name="id9">2&nbsp;&nbsp;&nbsp;Recognized Commands</a><ul class="auto-toc simple">
<li><a class="reference" href="#section-commands" id="id10" name="id10">2.1&nbsp;&nbsp;&nbsp;Section Commands</a></li>
<li><a class="reference" href="#initialfinal-state-commands" id="id11" name="id11">2.2&nbsp;&nbsp;&nbsp;Initial/Final State Commands</a></li>
<li><a class="reference" href="#trace-commands" id="id12" name="id12">2.3&nbsp;&nbsp;&nbsp;Trace Commands</a><ul class="auto-toc simple">
<li><a class="reference" href="#external-register-write-events" id="id13" name="id13">2.3.1&nbsp;&nbsp;&nbsp;External Register Write Events</a></li>
<li><a class="reference" href="#instruction-events" id="id14" name="id14">2.3.2&nbsp;&nbsp;&nbsp;Instruction Events</a></li>
<li><a class="reference" href="#resource-update-events" id="id15" name="id15">2.3.3&nbsp;&nbsp;&nbsp;Resource Update Events</a></li>
</ul>
</li>
<li><a class="reference" href="#time-tagged-iss-and-uadl-specific-trace-commands" id="id16" name="id16">2.4&nbsp;&nbsp;&nbsp;Time-Tagged ISS and uAdL-Specific Trace Commands</a></li>
</ul>
</li>
<li><a class="reference" href="#test-generation" id="id17" name="id17">3&nbsp;&nbsp;&nbsp;Test Generation</a></li>
<li><a class="reference" href="#test-comparison" id="id18" name="id18">4&nbsp;&nbsp;&nbsp;Test Comparison</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="the-file-format">
<h3><a class="toc-backref" href="#id4" name="the-file-format">1&nbsp;&nbsp;&nbsp;The File Format</a></h3>
<div class="section" id="overview">
<h4><a class="toc-backref" href="#id5" name="overview">1.1&nbsp;&nbsp;&nbsp;Overview</a></h4>
<p>The DAT format is a simple, line-oriented textual format for describing the
initial and final state of all resources within a microprocessor system, as well
as a stream of instructions which occurs during a simulation and the
modifications of resources which occur as each instruction executes.  The format
is stream oriented, meaning that a simulation does not have to store large data
structures in memory in order to generate the file, thus allowing it to scale to
long simulation runs.  Although the fact that it is human-readable does mean
that it is less compact than a binary format, it can be coupled with a
compression library, such as zlib, in order to reduce file sizes.</p>
<p>The basic unit of data within the file is a line.  Each line may start with a
unique numerical identifier, used to group together resource changes.  It is
then followed by a command and then data relevant to a command.  The format is
case-sensitive and no line continuation features exist.  The radix of integer
constants follows the C convention of "0x" for base-16, no prefix for base-10,
etc.</p>
<p>A parser for the DAT format should be able to operate in a forward-compatible
manner.  This means that unknown command types should be ignored and should not
cause an error so that if the format is extended in the future, older parsers
will still be able to process these newer files.  It is permissible to display
warning messages about unknown command types and to have a mode in which unknown
command types cause errors, but the default mode of operation should be to
ignore the commands.</p>
<p>Other notes on syntax:</p>
<ul class="simple">
<li>All addresses may be 64-bit values.</li>
<li>All memory accesses are 32-bit values.</li>
<li>Register data is specified as a single number of the size appropriate for the
register.  This means that a 128-bit register is specified as a single 128-bit
value.</li>
<li>All strings are quote-delimited, e.g. "lwz 1,2,3".</li>
</ul>
</div>
<div class="section" id="comments">
<h4><a class="toc-backref" href="#id6" name="comments">1.2&nbsp;&nbsp;&nbsp;Comments</a></h4>
<p>Single-line comments start with "#" and may occur on their own or on the same
line after a non-comment.  They should always be ignored by a parser.</p>
<p>Multi-line comments start with "=", followed by a unique identifier tag.  The
comment ends with "= /&lt;tag&gt;".  Nested tags are allowed, but they should end in
the reverse order in which they were begun.</p>
<p>An example single-line comment:</p>
<pre class="literal-block">#
# This is a comment.
#
</pre>
<p>An example multi-line comment:</p>
<pre class="literal-block">= foo

  This is all 
  comment data
  here.

= /foo
</pre>
<p>While single-line comments are meant to be comments, i.e. they should always be
ignored by a parser, the intent of multi-line comments is to provide a facility
for embedding non-trace data into files for processing by other programs.  For
example, an <em>asm</em> tag might be used to denote a program in assembly language.  A
program might extract out all data within the <em>asm</em> blocks, feed this to an
assembler, and then place the results back into the DAT file.</p>
</div>
<div class="section" id="commands">
<h4><a class="toc-backref" href="#id7" name="commands">1.3&nbsp;&nbsp;&nbsp;Commands</a></h4>
<p>A command takes the form of:</p>
<pre class="literal-block">[id.] &lt;command&gt; &lt;data&gt;
</pre>
<p>Where <em>id</em> is a unique integer, <em>command</em> is an identifier, and <em>data</em> consists
of key-value pairs of information.  The order of the key/value pairs is not
important.  A key-value pair consists of a key that is a legal C identifier
(must start with an alphabetical character or "_" but then may contain digits
after that), followed by "=" and then a value.  No space is allowed on either
side of the "=".  The value may be a valid identifier, a number, or a double-quote
delimited string.</p>
<p>Some example commands:</p>
<pre class="literal-block"># An initialization of a memory named "Mem" at address 0x1000, 
# of the value 0xdeadbeef.
MD n=Mem ra=0x1000 d=0xdeadbeef

# A write to "Mem" at 0x1000 of the value 0x1234567
1. D n=Mem t=Write ra=0x1000 d=0x12345678
1. A l=1 m="ThreadSwitch Reason: L2miss"
</pre>
</div>
<div class="section" id="sections">
<h4><a class="toc-backref" href="#id8" name="sections">1.4&nbsp;&nbsp;&nbsp;Sections</a></h4>
<p>A DAT file is structured into sections.  The outer-most section type, a test,
encompasses a complete simulation run.  Within a test is an initial state, the
trace, and the final result state.  Sections may be parsed using a simple
finite-state-machine approach: There is no need to use a stack to keep track of
section information.  However, keep in mind that it is valid for initial, trace,
and result sections to be interleaved.  In other words, there may be multiple
initial, result, and trace sections and <em>CORE</em> directives, which specify the
active core, may also be interleaved.</p>
</div>
</div>
<div class="section" id="recognized-commands">
<h3><a class="toc-backref" href="#id9" name="recognized-commands">2&nbsp;&nbsp;&nbsp;Recognized Commands</a></h3>
<p>This section lists all commands currently recognized by the format.</p>
<div class="section" id="section-commands">
<h4><a class="toc-backref" href="#id10" name="section-commands">2.1&nbsp;&nbsp;&nbsp;Section Commands</a></h4>
<ul class="simple">
<li><strong>TEST</strong>: Specifies that a new test has begun.  A leading TEST command in
a file is optional.<ul class="simple">
<li><strong>id=&lt;id&gt;</strong>:  The test number.</li>
</ul>
</li>
<li><strong>INIT</strong>:  Specifies that subsequent information is for initialization
purposes.</li>
<li><strong>TRACE</strong>:  Specifies that subsequent information is for trace purposes.</li>
<li><strong>RESULT</strong>: Specifies that subsequent information is for specifying the final
result state.</li>
<li><strong>CORE</strong>:  Specifies that subsequent information applies to the
specified component in the model.<ul class="simple">
<li><strong>n=&lt;name&gt;</strong>: A path identifying a model component.  This takes the form of a
colon-delimited string, e.g. "proc0:thread0".</li>
</ul>
</li>
<li><strong>CTX</strong>:  Specifies that subsequent information applies to the specified
context of the current core.<ul class="simple">
<li><strong>n=&lt;name&gt;</strong>:  The context's name.</li>
<li><strong>cn=&lt;int&gt;</strong>:  The active context number/index.</li>
</ul>
</li>
<li><strong>NOCTX</strong>: Specifies that subsequent information is no longer context
specific.</li>
</ul>
</div>
<div class="section" id="initialfinal-state-commands">
<h4><a class="toc-backref" href="#id11" name="initialfinal-state-commands">2.2&nbsp;&nbsp;&nbsp;Initial/Final State Commands</a></h4>
<ul class="simple">
<li><strong>MD</strong>:  Memory data.<ul class="simple">
<li><strong>n=&lt;name&gt;</strong>:  The name of the memory.  The default, global memory is named
"Mem".</li>
<li><strong>ra=&lt;addr&gt;</strong>:  The real-address of the data.</li>
<li><strong>d=&lt;data&gt;</strong>:  The data, a 32-bit value.</li>
<li><strong>s=&lt;int&gt;</strong>: Optional size specifier, in bytes.  Allowed values are 1, 2,
and 4.  If omitted, default is 4.</li>
</ul>
</li>
<li><strong>CD</strong>:  Cache data.  This specifies data for a cache line.<ul class="simple">
<li><strong>n=&lt;name&gt;</strong>:  The cache name, e.g. L2.</li>
<li><strong>set=&lt;int&gt;</strong>:  The set of the cache line.</li>
<li><strong>way=&lt;int&gt;</strong>:  The way of the cache line.</li>
<li><strong>ra=&lt;addr&gt;</strong>:  The real-address of the cache line.</li>
<li><strong>valid=&lt;0|1&gt;</strong>:  The valid status of the line.</li>
<li><strong>dirty=&lt;0|1&gt;</strong>:  The dirty status of the line.</li>
<li><strong>data=&lt;word,word...&gt;</strong>: A sequence of 32-bit data words specifying the
contents of the cache line.</li>
</ul>
</li>
<li><strong>TD</strong>:  TLB data.  This specifies information about an MMU translation.<ul class="simple">
<li><strong>n=&lt;name&gt;</strong>:  The name of the translation, e.g. TlbCam.</li>
<li><strong>set=&lt;int&gt;</strong>:  The set of the translation.</li>
<li><strong>way=&lt;int&gt;</strong>:  The way of the translation.</li>
<li><strong>&lt;field&gt;=&lt;int&gt;</strong>:  Additional fields are considered fields of the
translation and are used to initialize the entry.</li>
</ul>
</li>
</ul>
<a id="register-data"></a><ul class="simple">
<li><strong>RD</strong>:  Register data.<ul class="simple">
<li><strong>n=&lt;name&gt;</strong>:  The name of the register.</li>
<li><strong>i=&lt;int&gt;</strong>: Index of the entry if the name specifies a register-file.  This
is optional: The index can be appended to the register-file name, if the
file is non-sparse.  In other words, if a register-file named <tt class="docutils literal"><span class="pre">GPR</span></tt>
exists, then <tt class="docutils literal"><span class="pre">n=GPR0</span></tt> refers to the first element, as well as <tt class="docutils literal"><span class="pre">n=GPR</span>
<span class="pre">i=0</span></tt>.  For sparse register-files, this is not the case, since the
individual elements of the file also exist as stand-alone registers.</li>
<li><strong>d=&lt;data&gt;</strong>:  The register data.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="trace-commands">
<h4><a class="toc-backref" href="#id12" name="trace-commands">2.3&nbsp;&nbsp;&nbsp;Trace Commands</a></h4>
<div class="section" id="external-register-write-events">
<h5><a class="toc-backref" href="#id13" name="external-register-write-events">2.3.1&nbsp;&nbsp;&nbsp;External Register Write Events</a></h5>
<ul class="simple">
<li><strong>ERW</strong>: Start of an external register write, initiated by a call to
<tt class="docutils literal"><span class="pre">IssNode::writeReg</span></tt>.  What follows are intermediate results which occur as a
result of the write operation.  For example, a write-one-to-clear register
might show a write value of 0xffffffff, but the intermediate results which
follow will show that the resulting register now has a value of 0x00000000.<ul class="simple">
<li><strong>d=&lt;int&gt;</strong>:  The updated data value.</li>
<li><strong>i=&lt;int&gt;</strong>:  The index of a register-file entry, if this is a register
file.</li>
<li><strong>id=&lt;int&gt;</strong>:  A unique numerical identifier for this external-write event.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="instruction-events">
<h5><a class="toc-backref" href="#id14" name="instruction-events">2.3.2&nbsp;&nbsp;&nbsp;Instruction Events</a></h5>
<ul class="simple">
<li><strong>I</strong>: Start of an instruction sequence.  This implies that all subsequent
information, until a section command or another <strong>I</strong> or <strong>ERW</strong> command is
encountered, is relevant to this instruction.<ul class="simple">
<li><strong>id=&lt;int&gt;</strong>:  A unique numerical identifier for this instruction group.</li>
<li><strong>ea=&lt;addr&gt;</strong>: The effective-address for the instruction fetch, if this
instruction was fetched.  Will be omitted if the instruction was executed
via an external call (via <tt class="docutils literal"><span class="pre">IssNode::exec_from_buffer</span></tt>).</li>
<li><strong>tic=&lt;int&gt;</strong>:  A thread-local instruction count.</li>
</ul>
</li>
<li><strong>INSTR</strong>:  Information about an instruction.<ul class="simple">
<li><strong>op=&lt;int&gt;</strong>:  The instruction's opcode.</li>
<li><strong>asm=&lt;str&gt;</strong>:  The disassembled instruction, e.g. "lwz r1,r2,r3".</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="resource-update-events">
<h5><a class="toc-backref" href="#id15" name="resource-update-events">2.3.3&nbsp;&nbsp;&nbsp;Resource Update Events</a></h5>
<ul class="simple">
<li><strong>A</strong>:  An annotation command.  These are emitted by code within the model or
by system calls generated by code running on the model.<ul class="simple">
<li><strong>l=&lt;int&gt;</strong>:  The annotation level.  This may be used to filter messages by
priority.</li>
<li><strong>m=&lt;str&gt;</strong>:  The message string.</li>
<li><strong>t=&lt;str&gt;</strong>: The type of message: <tt class="docutils literal"><span class="pre">info</span></tt>, <tt class="docutils literal"><span class="pre">warning</span></tt>, or <tt class="docutils literal"><span class="pre">error</span></tt>.
Generally, if this is just an informational notice, then the type key is
omitted.  Also, if an error is generated, then the current behavior of the
test writer is to abort the simulation at this point.  Note that warnings
and errors are always printed, even if tracing is turned off.</li>
<li>Additional keys may be present, specified by the user as data arguments in
the <em>info</em>, <em>warning</em>, and <em>error</em> call.</li>
</ul>
</li>
<li><strong>B</strong>:  Branch information.<ul class="simple">
<li><strong>ea=&lt;addr&gt;</strong>:  The branch target effective-address.</li>
<li><strong>taken=1</strong>: Currently, this command is only issued when a branch is taken,
thus <tt class="docutils literal"><span class="pre">taken</span></tt> will always be true.  For future compatibility issues,
though, we have left open the possibility that this will not be the case.
Thus, an analysis program should always check the value of the <tt class="docutils literal"><span class="pre">taken</span></tt>
parameter.</li>
</ul>
</li>
<li><strong>BP</strong>:  A breakpoint occurrence.<ul class="simple">
<li><strong>ea=&lt;addr&gt;</strong>:  Effective address of the breakpoint.</li>
</ul>
</li>
<li><strong>C</strong>: A cache access.  Note that <strong>C</strong> commands precede in the file the
memory access which causes them.  Thus, a <strong>C</strong> command is tied to the next
<strong>INSTR</strong> or <strong>M</strong> command in the file.<ul class="simple">
<li><strong>n=&lt;name&gt;</strong>:  The name of the cache, e.g. L2.</li>
<li><strong>a=&lt;hit|miss|evict&gt;</strong>:  The action taking place.</li>
<li><strong>t=&lt;read|write|flush|touch|alloc&gt;</strong>:  The access type.</li>
<li><strong>set=&lt;int&gt;</strong>:  The cache line's set.</li>
<li><strong>way=&lt;int&gt;</strong>:  The cache line's way.</li>
<li><strong>lm=&lt;int&gt;</strong>:  The line mask for the cache.</li>
<li><strong>ra=&lt;int&gt;</strong>:  The real-address of the first word in the cache line.</li>
</ul>
</li>
<li><strong>D</strong>:  A memory data access.  This describes a memory access from the
point of view of the core and is then followed by <strong>M</strong> commands which
represent the memory access from the point of view of the memory.<ul class="simple">
<li><strong>n=&lt;name&gt;</strong>:  The name of the memory.  The global memory is named <tt class="docutils literal"><span class="pre">Mem</span></tt>.</li>
<li><strong>ea=&lt;addr&gt;</strong>:  The effective-address of the access.</li>
<li><strong>nb=&lt;int&gt;</strong>: The size of the access in bytes.</li>
<li><strong>t=&lt;read|write&gt;</strong>: The access type.</li>
<li><strong>sn=&lt;int&gt;</strong>:  Optional.  For a model which has dependency tracking enabled, this is
the memory-read sequence number.  Only present for reads.</li>
</ul>
</li>
<li><strong>E</strong>:  Specifies the occurrence of an exception.<ul class="simple">
<li><strong>n=&lt;name&gt;</strong>:  The exception's name.</li>
</ul>
</li>
<li><strong>M</strong>:  A memory access.<ul class="simple">
<li><strong>n=&lt;name&gt;</strong>:  The name of the memory.  The global memory is named <tt class="docutils literal"><span class="pre">Mem</span></tt>.</li>
<li><strong>ea=&lt;addr&gt;</strong>:  The word-aligned effective-address of the access.</li>
<li><strong>ra=&lt;addr&gt;</strong>:  The word-aligned real-address of the access.</li>
<li><strong>t=&lt;read|write|ifetch&gt;</strong>: The access type.  Accesses of type <tt class="docutils literal"><span class="pre">ifetch</span></tt>
occur between <tt class="docutils literal"><span class="pre">I</span></tt> and <tt class="docutils literal"><span class="pre">INSTR</span></tt> cards and represent the instruction-fetch
operation.  More than one <tt class="docutils literal"><span class="pre">ifetch</span></tt> <strong>M</strong> command may occur for misaligned
instructions (if allowed by the architecture).</li>
<li><strong>d=&lt;int&gt;</strong>:  The data.  This is a 32-bit word-aligned value representing
the new state of memory.</li>
</ul>
</li>
<li><strong>R</strong>: A register read or write.  The syntax is the same as for the <a class="reference" href="#id1"><strong>RD</strong>
command</a> in the init/result section, with the possible addition of an action.<a id="id1"></a><ul class="simple">
<li><strong>a=&lt;read|write&gt;</strong>: The type of action: <em>read</em> or <em>write</em>.  If omitted, then
then the action is a write.</li>
<li><strong>d=&lt;int&gt;</strong>:  The updated data value.</li>
<li><strong>i=&lt;int&gt;</strong>:  The index of a register-file entry, if this is a register file.</li>
<li><strong>m=&lt;int&gt;</strong>: A mask describing the portion of the register read.  If
omitted, then the entire register is accessed.</li>
<li><strong>sn=&lt;int&gt;</strong>:  Optional.  For a model which has dependency tracking enabled,
this is the register-read sequence number.  Only present for reads.</li>
<li><strong>dt=&lt;R|M&gt;n[,&lt;R|M&gt;n...]</strong>: Optional.  For a model which has dependency
tracking enabled, this lists the read dependencies.  Register dependencies
are expressed as <strong>Rn</strong>, where <strong>n</strong> is the register sequence number (listed
as <strong>sn=n</strong> in the <strong>R</strong> logging event).  Memory dependencies are expressed
as <strong>Mn</strong>, where <strong>n</strong> is the memory sequence number (listed as <strong>sn=n</strong> in
the <strong>D</strong> logging event).</li>
</ul>
</li>
<li><strong>T</strong>: An MMU/TLB access.  Note that <strong>T</strong> commands precede in the file the
memory modification which causes them.  Thus, a <strong>T</strong> command is tied to the
next <strong>INSTR</strong> or <strong>M</strong> command in the file.<ul class="simple">
<li><strong>n=&lt;name&gt;</strong>:  The name of the translation, e.g. TlbCam.</li>
<li><strong>&lt;field&gt;=&lt;int&gt;</strong>: Additional fields are considered fields of the
translation.</li>
</ul>
</li>
<li><strong>WP</strong>:  A watchpoint occurrence.<ul class="simple">
<li><strong>ea=&lt;addr&gt;</strong>:  Effective address of the breakpoint.</li>
<li><strong>t=&lt;read|write&gt;</strong>:  Type of watchpoint.</li>
<li><strong>nb=&lt;int&gt;</strong>:  Number of bytes associated with the watchpoint memory access.</li>
<li><strong>d=&lt;data&gt;</strong>:  The value written, in the case of a write watchpoint.</li>
</ul>
</li>
</ul>
<p>Note that any resource update command may have an optional <strong>cn</strong> tag which will
report the name of the core on which the resource modification is occurring, if
it differs from the current core, as set by the <strong>CORE</strong> tag.  This generally
only occurs in multi-processor test-cases, where an event from one core causes
modifications, e.g. cache activity, in other core within the execution of a
single instruction.</p>
<p>A resource update may also have a <strong>ctx</strong> and <strong>ctxi</strong> tag if a resource in a
context other than the current context is modified.  In this case, <strong>ctx</strong>
specifies the name of the context and <strong>ctxi</strong> specifies the context index.</p>
</div>
</div>
<div class="section" id="time-tagged-iss-and-uadl-specific-trace-commands">
<h4><a class="toc-backref" href="#id16" name="time-tagged-iss-and-uadl-specific-trace-commands">2.4&nbsp;&nbsp;&nbsp;Time-Tagged ISS and uAdL-Specific Trace Commands</a></h4>
<p>These trace commands only occur within a time-tagged ISS.</p>
<ul class="simple">
<li><strong>ITIME</strong>:  For time-tagged ISSs, this is the time when an instruction is
fetched.<ul class="simple">
<li><strong>t=&lt;time&gt;</strong>:  Time of the fetch.</li>
</ul>
</li>
<li><strong>CTIME</strong>:  For time-tagged ISSs, this is the time when an instruction
completes.<ul class="simple">
<li><strong>t=&lt;time&gt;</strong>:  Time of the completion.</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="test-generation">
<h3><a class="toc-backref" href="#id17" name="test-generation">3&nbsp;&nbsp;&nbsp;Test Generation</a></h3>
<p>The ADL distribution contains a script called <strong>makedat</strong> designed to make it
easy to create assembler-based tests.  The basic idea is that one writes an
assembly program within a multi-line comment block called <em>asm</em>.  For example:</p>
<pre class="literal-block">= asm

   addis 3,2,1
   addis 4,0,100
         mtspr 10,20
         mfspr 21,11
         mtspr 12,8

= /asm
</pre>
<p>Then, run the <strong>makedat</strong> script on this file:</p>
<pre class="literal-block">makedat &lt;input-file&gt;
</pre>
<p>The script will default to using an assembler named <strong>as</strong> in the current
directory.  This way be overridden by using the <strong>--as=&lt;path&gt;</strong> option.  By
default, the script reads the specified input file, assembles the code found
within the <em>asm</em> block, and then re-writes the file, adding the assembled code
as <strong>MD</strong> commands to the file, surrounded by special comments.  This allows the
same input file to be updated repeatedly, while not overwriting anything else in
the file.  The user may then add in extra commands, such as register
initializations, expected results, etc.</p>
<p>For example, here is a simple testcase with expected results:</p>
<pre class="literal-block">#
# Example makedat testcase.
#
= asm

      addi r1,r1,10
      addi r2,r2,20
      add      r3,r1,r2
      add  r3,r3,r4

= /asm

# &lt;GEN&gt;
MD n=Mem ra=0x00000000 d=0x3821000A   #       addi r1,r1,10
MD n=Mem ra=0x00000004 d=0x38420014   #       addi r2,r2,20
MD n=Mem ra=0x00000008 d=0x7C611214   #       add      r3,r1,r2
MD n=Mem ra=0x0000000c d=0x7C632214   #       add  r3,r3,r4
# &lt;/GEN&gt;

CORE n=:P

RD n=GPR i=4 d=40

RESULTS

RD n=GPR i=3 d=70
</pre>
<p>This shows the input assembly and the resulting assembled instructions.  This
also demonstrates initializing a register (GPR 4) to a value, and it shows an
expected result (GPR3 is expected to be 70).  Note the use of the <strong>CORE</strong>
command: By default, <strong>tracediff</strong>, the DAT comparison tool, will associate
results with the global scope unless a <strong>CORE</strong> directive is used to associate
these results with a specific core.</p>
<p>The <strong>makedat</strong> script recognizes several other multi-line comment blocks:</p>
<ul>
<li><p class="first">aopts:  Place assembler flags within this block.</p>
</li>
<li><p class="first">mdopts:  Place makedat command-line flags within this block.  For example, to
specify an offset for the assembled instructions:</p>
<pre class="literal-block">= mdopts
instr-offset: 0x10000
= /mdopts
</pre>
</li>
</ul>
</div>
<div class="section" id="test-comparison">
<h3><a class="toc-backref" href="#id18" name="test-comparison">4&nbsp;&nbsp;&nbsp;Test Comparison</a></h3>
<p>The ADL distribution contains a tool, <strong>tracediff</strong>, which can be used to
compare DAT files.  The usage is:</p>
<pre class="literal-block">tracediff &lt;expected-file&gt; &lt;simulation-output-file&gt;
</pre>
<p>In other words, the first file is the testcase, such as the file shown in the
prior section.  The second file is the file produced by the simulator.
<strong>tracediff</strong> will exit with an exit code of zero if the files compare,
otherwise it will exit with a non-zero exit and will report where it found
discrepancies.</p>
<p>If the simulation output file contains a trace section, then the
expected-results file must contain a trace section.  Otherwise, the trace
section of the expected results will be ignored.</p>
</div>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="dat-format.rst">View document source</a>.
Generated on: 2018/02/28 15:14:26 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
