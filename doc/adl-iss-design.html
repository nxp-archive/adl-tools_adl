<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="standard header">
  <link type="text/css" rel="stylesheet" href="/swo/css/fsl.css" />
  <script type="text/javascript" language="javascript" src="/swo/jscripts/FSLHeader.js"></script>
  <script language="JavaScript"> 
        WriteFSHeader(); 
  </script> 
</div></div>
<div class="footer">
<hr class="footer" />
<a class="first last reference" href="./fsl-header.rst">View document source</a>.
Generated on: 2018/02/28 15:14:25 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<title>ADL ISS Model Design Document</title>
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="title section" id="adl-iss-model-design-document">
<h1><a>ADL ISS Model Design Document</a></h1>
<p>This document describes the architecture of a generated ISS model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Brian Kahne</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body"><a class="reference" href="mailto:bkahne&#64;freescale.com">bkahne&#64;freescale.com</a></td>
</tr>
</tbody>
</table>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first"><a name="table-of-contents">Table of Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#adl-iss-model-design-document" id="id2" name="id2">ADL ISS Model Design Document</a><ul class="auto-toc simple">
<li><a class="reference" href="#overview" id="id3" name="id3">1&nbsp;&nbsp;&nbsp;Overview</a></li>
<li><a class="reference" href="#generated-code-and-support-library" id="id4" name="id4">2&nbsp;&nbsp;&nbsp;Generated Code and Support Library</a><ul class="auto-toc simple">
<li><a class="reference" href="#header-files" id="id5" name="id5">2.1&nbsp;&nbsp;&nbsp;Header Files</a></li>
<li><a class="reference" href="#class-structure" id="id6" name="id6">2.2&nbsp;&nbsp;&nbsp;Class Structure</a></li>
<li><a class="reference" href="#instructions" id="id7" name="id7">2.3&nbsp;&nbsp;&nbsp;Instructions</a></li>
<li><a class="reference" href="#registers" id="id8" name="id8">2.4&nbsp;&nbsp;&nbsp;Registers</a></li>
<li><a class="reference" href="#memory" id="id9" name="id9">2.5&nbsp;&nbsp;&nbsp;Memory</a></li>
<li><a class="reference" href="#logging" id="id10" name="id10">2.6&nbsp;&nbsp;&nbsp;Logging</a></li>
</ul>
</li>
<li><a class="reference" href="#stand-alone-framework" id="id11" name="id11">3&nbsp;&nbsp;&nbsp;Stand-alone Framework</a><ul class="auto-toc simple">
<li><a class="reference" href="#test-readers" id="id12" name="id12">3.1&nbsp;&nbsp;&nbsp;Test Readers</a></li>
<li><a class="reference" href="#test-writers" id="id13" name="id13">3.2&nbsp;&nbsp;&nbsp;Test Writers</a></li>
<li><a class="reference" href="#time-tagged-iss" id="id14" name="id14">3.3&nbsp;&nbsp;&nbsp;Time Tagged ISS</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id3" name="overview">1&nbsp;&nbsp;&nbsp;Overview</a></h2>
<p>An ISS model is produced by the <tt class="docutils literal"><span class="pre">make-iss</span></tt> program, or the <tt class="docutils literal"><span class="pre">adl2iss</span></tt> wrapper
script, from an ADL description.  Usage of these programs is covered by the <a class="reference" href="adl-language-reference.html">ADL
Design Notes</a> document.  This document covers the structure of the generated
models.  Two types of ISSs can be currently generated: Untimed and time-tagged.
An untimed ISS, as you might imagine, has no concept of time.  Instructions are
simply executed sequentially.  A time-tagged ISS executes instructions in the
same manner, except that each resource (currently just registers) has a time
associated with it.  Current time, and the time that a resource is available, is
set by looking at the instructions operands' times and adding the instruction's
latency.  Thus, this allows the user to approximate the behavior of a pipeline
without the overhead of actually modeling the pipeline.</p>
<p>The model can be separated into three main parts:</p>
<ol class="arabic simple">
<li>The generated code.  This is created by <tt class="docutils literal"><span class="pre">make-iss</span></tt> from the ADL
description.</li>
<li>The support library.  This code is used by all models and contains structures
such as the sparse memory model.</li>
<li>The stand-alone execution framework.  This library is only needed if the model
is going to be used as a stand-alone ISS and contains various file readers and
writers for initializing the model and storing logged results.</li>
</ol>
</div>
<div class="section" id="generated-code-and-support-library">
<h2><a class="toc-backref" href="#id4" name="generated-code-and-support-library">2&nbsp;&nbsp;&nbsp;Generated Code and Support Library</a></h2>
<div class="section" id="header-files">
<h3><a class="toc-backref" href="#id5" name="header-files">2.1&nbsp;&nbsp;&nbsp;Header Files</a></h3>
<p>The following header files are referenced throughout this document:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ModuleInterface.h</span></tt>: This header file defines the interface for the model
and should be used by anything that wants to interact with it.  For example,
the stand-alone-ISS framework includes this.</li>
<li><tt class="docutils literal"><span class="pre">ModuleSupport.h</span></tt>: This file is <em>only</em> included by the generated model.  It
contains the memory model and various support routines.  This is a private
header and can only be included once due to various global declarations
contained within.</li>
</ul>
</div>
<div class="section" id="class-structure">
<h3><a class="toc-backref" href="#id6" name="class-structure">2.2&nbsp;&nbsp;&nbsp;Class Structure</a></h3>
<p>The model generator, <tt class="docutils literal"><span class="pre">make-iss</span></tt>, produces a single C++ file from an ADL
description.  Each core is transformed into a class which publicly inherits from
<tt class="docutils literal"><span class="pre">IssCore</span></tt>.  The base class provides a small number of services, such as the
ability to set a register, display all registers, set the starting address, etc.
This base class is declared in <tt class="docutils literal"><span class="pre">ModuleInterface.h</span></tt>.  For a complex ISS that
contains systems of cores, each system is represented as a structure which
declares any needed child systems or cores, then instantiates them.</p>
<p>Each core object registers itself by calling <tt class="docutils literal"><span class="pre">registerCore</span></tt>, which places a
reference to the core object, indexed by its path in the system hierarchy, into
a hash.  These cores can then be retrieved by calling <tt class="docutils literal"><span class="pre">getCore</span></tt>.  This allows
an external framework to retrieve all cores in the system for the purpose of
initializing them, receiving logging information, etc.</p>
<p>The main interface to the system or core are the following routines:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">simulate</span></tt>:  Cycles each core, or in the case of a system, each child
object, once.  In other words, each core executes one instruction.</li>
<li><tt class="docutils literal"><span class="pre">resetSimulation</span></tt>:  Resets each core to its initial state.</li>
</ul>
<p>These methods are called by generated functions called <tt class="docutils literal"><span class="pre">simulate</span></tt> and
<tt class="docutils literal"><span class="pre">resetSimulation</span></tt>.  These are the main interface functions for executing and
reseting the simulation.  The <tt class="docutils literal"><span class="pre">simulate</span></tt> function currently loops until all
cores are inactive.</p>
</div>
<div class="section" id="instructions">
<h3><a class="toc-backref" href="#id7" name="instructions">2.3&nbsp;&nbsp;&nbsp;Instructions</a></h3>
<p>Instructions are decoded in the <tt class="docutils literal"><span class="pre">simulate</span></tt> method.  The method is gated by a
boolean, called <tt class="docutils literal"><span class="pre">_active</span></tt>.  If the core is ever halted, this flag is set to
false.  If the core is active, it assigns the next-instruction-address register (NIA)
to the current-instruction-address register (CIA), then uses the CIA's address
to read from memory.  Note that the names for the CIA and NIA are not fixed:
They are determined by the model builder by looking for registers that have the
<tt class="docutils literal"><span class="pre">nia</span></tt> and <tt class="docutils literal"><span class="pre">cia</span></tt> instruction class.</p>
<p>The data read from memory is then decoded by using a nested switch statement.
For PowerPC, the outer-most switch statement corresponds to the primary opcode
and the next level of switch corresponds to the secondary opcode.  However, the
model does not know that a field is a "primary-opcode"- this is derived from the
instruction encoding and what fields are given hard-coded values.</p>
<p>At a leaf in the switch statement, the NIA is updated based upon the
instruction's size, <tt class="docutils literal"><span class="pre">log_instr</span></tt> is called if tracing is enabled (logging is
described in <a class="reference" href="#logging">Logging</a>), then the instruction handler function is called.  The
arguments to this function are each of the operands that the instruction has.
These are extracted from the instruction using generated extractor functions.
For example, for <tt class="docutils literal"><span class="pre">mtspr</span></tt>, the <tt class="docutils literal"><span class="pre">get_SPRN</span></tt> function creates a 10-bit <tt class="docutils literal"><span class="pre">intbv</span></tt>
by extracting bits 16 through 20 and 11 through 15, then permuting them.</p>
<p>The instruction handler function is basically just the code specified in the
<tt class="docutils literal"><span class="pre">action</span></tt> key in the ADL function definition.  Only minor changes are made:
Register references are modified so that the function-call operator is called,
e.g. <tt class="docutils literal"><span class="pre">CTR</span></tt> is changed to <tt class="docutils literal"><span class="pre">CTR()</span></tt>.  Also, the various language extensions,
such as <tt class="docutils literal"><span class="pre">var</span></tt> are handled.  In this case, <tt class="docutils literal"><span class="pre">var</span></tt> is converted to using gcc's
<tt class="docutils literal"><span class="pre">typeof</span></tt> operator.</p>
<p>Once the instruction handler returns, any exceptions are handled, and the
function returns.  Note that most functions within the model are inlined,
including all of the argument extractors and instruction handlers.</p>
</div>
<div class="section" id="registers">
<h3><a class="toc-backref" href="#id8" name="registers">2.4&nbsp;&nbsp;&nbsp;Registers</a></h3>
<p>Each register in the core is declared as a class within the core's class.  A
basic register is just a wrapper around an <tt class="docutils literal"><span class="pre">intbv</span></tt>.  More complicated
registers, such as aliases, might not actually contain an <tt class="docutils literal"><span class="pre">intbv</span></tt> but will
have the same interface.  A register's interface is:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">operator=</span></tt>:  Handles assignment to the register.  This calls the
register's write-hook, if one exists, and is the interface used by
instruction-handler code.</li>
<li><tt class="docutils literal"><span class="pre">operator()</span></tt>:  Handles reading from a register.  Each instruction-handler
has all register references transformed into calls to this operator.  If a
register has a read-hook, it is called here.</li>
<li><tt class="docutils literal"><span class="pre">get_value()</span></tt>:  Handles reading from a register with no side-effects.
This is used by initialization logic, such as the test writer in a
stand-alone ISS.</li>
<li><tt class="docutils literal"><span class="pre">set_value(intbv&lt;N&gt;)</span></tt>:  Handles writing to a register with no
side-effects.  This is used by initialization logic, such as by the test
reader in a stand-alone ISS.</li>
</ul>
<p>The actual data object within the register is either a <tt class="docutils literal"><span class="pre">Tag</span></tt> (for time-tagged 
ISSs) or <tt class="docutils literal"><span class="pre">NoTag</span></tt> (for untimed ISSs).  The <tt class="docutils literal"><span class="pre">NoTag</span></tt> class has no functionality-
it simply presents the same interface as <tt class="docutils literal"><span class="pre">Tag</span></tt> and is pretty much inlined out
by the compiler.  The <tt class="docutils literal"><span class="pre">Tag</span></tt> object will be discussed in the <a class="reference" href="#time-tagged-iss">Time Tagged ISS</a>
section.</p>
<p>Register files are handled in an analogous fashion to registers, except that
they inherit from <tt class="docutils literal"><span class="pre">RegFile</span></tt>, a simple class which contains an array of objects
(either <tt class="docutils literal"><span class="pre">Tag</span></tt> or <tt class="docutils literal"><span class="pre">NoTag</span></tt>).  The interface to each register-file class is
basically the same as for registers.  The main difference is that <tt class="docutils literal"><span class="pre">operator[]</span></tt>
is defined, which returns a reference object which refers to the particular
register being referenced.</p>
</div>
<div class="section" id="memory">
<h3><a class="toc-backref" href="#id9" name="memory">2.5&nbsp;&nbsp;&nbsp;Memory</a></h3>
<p>The memory model is declared in <tt class="docutils literal"><span class="pre">Memory.h</span></tt>.  The memory representation class
is called <tt class="docutils literal"><span class="pre">Node</span></tt>.  It is a short, wide tree.  Internal nodes are pages of
pointers to child nodes.  Leaf nodes are pages of bytes.  The depth of the tree
is determined by the template parameter Total.  Through the use of recursive
template types, it generates the internal node types, stopping at level 0, which
is the leaf node (page of bytes).  The <tt class="docutils literal"><span class="pre">MemTree</span></tt> type is what is actually
instantiated and is a wrapper which instantiates the <tt class="docutils literal"><span class="pre">Node</span></tt> template with the
proper parameters.</p>
<p>So, for example, <tt class="docutils literal"><span class="pre">MemTree&lt;64,4&gt;</span></tt> will create a tree of four levels of 16 bits
each; three internal nodes and the addressing within the 64K page.
<tt class="docutils literal"><span class="pre">MemTree&lt;64,3&gt;</span></tt> creates a three-level tree: 22 bits for the internal nodes (4
Meg) and 20 bits for the page size (1 Meg).  For performance, the <tt class="docutils literal"><span class="pre">MemTree</span></tt>
class cache the last page accessed.</p>
<p>The <tt class="docutils literal"><span class="pre">Memory</span></tt> object wraps the <tt class="docutils literal"><span class="pre">MemTree</span></tt> object and provides support for
reading and writing 32-bit, 16-bit, and 8-bit quantities which may be
misaligned.  This class is defined in <tt class="docutils literal"><span class="pre">ModuleSupport.C</span></tt> and is currently
hardcoded to create a memory model with 64 address bits and four levels of
lookup, i.e. four total levels to the tree.</p>
<p>The routines <tt class="docutils literal"><span class="pre">mem_read32</span></tt>, <tt class="docutils literal"><span class="pre">mem_write32</span></tt> and equivalent functions for
reading/writing 16 and 8 bits are the interface used to access the <tt class="docutils literal"><span class="pre">Memory</span></tt>
object.  These are then wrapped by the routines <tt class="docutils literal"><span class="pre">mem_log_read32</span></tt>,
<tt class="docutils literal"><span class="pre">mem_log_write32</span></tt>, etc.  The logging routines call the appropriate read/write
routine and then call a logging template (<tt class="docutils literal"><span class="pre">logMem32</span></tt>, etc.) with a template
parameter of either <tt class="docutils literal"><span class="pre">LogRead</span></tt> or <tt class="docutils literal"><span class="pre">LogWrite</span></tt>.  These objects call the actual
tracing routines of <tt class="docutils literal"><span class="pre">log_mem_read</span></tt> or <tt class="docutils literal"><span class="pre">log_mem_write</span></tt> if the <tt class="docutils literal"><span class="pre">Tracing</span></tt> and
<tt class="docutils literal"><span class="pre">TraceMode</span></tt> flags are set to true.  The first flag, <tt class="docutils literal"><span class="pre">Tracing</span></tt>, is a constant
and is declared by the generator at the top of the generated file.  Thus, the
compiler is able to eliminate the conditional, and thus entirely remove all
logging logic if tracing is not enabled.  The second flag, <tt class="docutils literal"><span class="pre">TraceMode</span></tt>, is set
at run-time.  In a stand-alone ISS, this would be set by the value of
command-line parameters.</p>
<p>Finally, a class called <tt class="docutils literal"><span class="pre">MemoryModel</span></tt> wraps the <tt class="docutils literal"><span class="pre">log_mem_read32</span></tt> function
and others and is defined in the generated model as <tt class="docutils literal"><span class="pre">Mem</span></tt>.  This is the memory
object used by instruction handlers.  Its interface methods, <tt class="docutils literal"><span class="pre">read</span></tt> and
<tt class="docutils literal"><span class="pre">write</span></tt>, are both templated on the size of the access in bits and call
structures <tt class="docutils literal"><span class="pre">read_internal</span></tt> and <tt class="docutils literal"><span class="pre">write_internal</span></tt> which have partial
specializations for handling different access sizes.  For example, a call to
<tt class="docutils literal"><span class="pre">Mem.read&lt;32&gt;(addr)</span></tt> will call <tt class="docutils literal"><span class="pre">read_internal&lt;4&gt;</span></tt>, which then directly calls
<tt class="docutils literal"><span class="pre">log_mem_read32()</span></tt>.  Partial specializations exist for other reading and
writing values of 8, 4, 3, 2, and 1 bytes.  Other values are handled by a
generic function which does 32-bit reads for as much as it can, then handles any
remaining bytes.</p>
</div>
<div class="section" id="logging">
<h3><a class="toc-backref" href="#id10" name="logging">2.6&nbsp;&nbsp;&nbsp;Logging</a></h3>
<p>The intermediate-results logging interface is declared in <tt class="docutils literal"><span class="pre">ModuleInterface.h</span></tt>.
As noted earlier, code for it is only generated if the model generator is told
to create it.  The logging interface consists of the following functions:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">log_instr</span></tt>: Called when an instruction is executed.  This is called with a
pointer to the core that is executing the instruction.  All subsequent
intermediate-result calls are relative to this specified core.</li>
<li><tt class="docutils literal"><span class="pre">log_instr_times</span></tt>:  Called by a time-tagged ISS</li>
<li><tt class="docutils literal"><span class="pre">log_reg_write</span></tt>:  Called on a register write.</li>
<li><tt class="docutils literal"><span class="pre">log_regfile_write</span></tt>:  Called on a write to a register file.</li>
<li><tt class="docutils literal"><span class="pre">log_mem_write</span></tt>:  Called on a write to memory.</li>
<li><tt class="docutils literal"><span class="pre">log_mem_read</span></tt>:  Called on a read from memory.</li>
</ul>
</div>
</div>
<div class="section" id="stand-alone-framework">
<h2><a class="toc-backref" href="#id11" name="stand-alone-framework">3&nbsp;&nbsp;&nbsp;Stand-alone Framework</a></h2>
<p>The stand-alone framework may be linked with a generated model to create an
executable ISS able to read in initial state from a variety of files and write
its intermediate and final results to a file in a variety of formats.  The
primary framework code is contained within <tt class="docutils literal"><span class="pre">ExecSupport.C</span></tt>.</p>
<p>It contains <tt class="docutils literal"><span class="pre">main</span></tt>, parses command-line parameters, and instantiates the
necessary test reader and writer.  The type of reader and writer is generally
derived from the input or output filename extension, but this may be overridden
using the <tt class="docutils literal"><span class="pre">--input-format</span></tt> and <tt class="docutils literal"><span class="pre">--output-format</span></tt> command-line arguments.</p>
<p>The basic flow is:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">main</span></tt> resets the simulation by calling <tt class="docutils literal"><span class="pre">resetSimulation</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">init</span></tt> is called, which processes command-line parameters and instantiates
the necessary reader and writer.  The writer is stored in a global called
<tt class="docutils literal"><span class="pre">writer</span></tt> and the current reader is stored in <tt class="docutils literal"><span class="pre">reader</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">readInput</span></tt> is called.  This tells the test reader to read its input and
initialize the model.</li>
<li><tt class="docutils literal"><span class="pre">simulate</span></tt> is called.  This executes the model.</li>
<li><tt class="docutils literal"><span class="pre">writeOutput</span></tt> is called.  This tells the test writer to generate its
output.</li>
<li><tt class="docutils literal"><span class="pre">finalize</span></tt> is called.  This currently just prints some final output
information, such as elapsed wall-clock time.</li>
</ul>
<div class="section" id="test-readers">
<h3><a class="toc-backref" href="#id12" name="test-readers">3.1&nbsp;&nbsp;&nbsp;Test Readers</a></h3>
<p>All test readers are derived from <tt class="docutils literal"><span class="pre">Reader</span></tt>, declared in <tt class="docutils literal"><span class="pre">Reader.h</span></tt>.</p>
<p>There are currently two classes which derive from Reader, ElfReader and DatReader.
Although we do not currently support an AvpReader nor a UvpReader, we do provide
two scripts for conversion to dat format: avp2dat and uvp2dat.</p>
<p>The reader is responsible for parsing the specified input and setting up the
model accordingly.  The resources that it may initialize are the mmu, registers
and system memory.  All communication with the model goes through the base
reader class using the following methods:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">set_program_counter_internal</span></tt> which then calls set_program_counter in ModelInterface.</p>
<p><tt class="docutils literal"><span class="pre">init_reg_internal</span></tt> which then calls initialize_reg in ModelInterface.</p>
<p><tt class="docutils literal"><span class="pre">init_mem_internal</span></tt> which then calls initialize_mem in ModelInterface.</p>
<p><tt class="docutils literal"><span class="pre">init_mmu_internal</span></tt> which then calls initialize_mmu in ModelInterface.</p>
</blockquote>
<p>The public interface for a reader is:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">readFile</span></tt> - which then parses the input file and calls the previously
described internal methods to initialize the model.</p>
</blockquote>
</div>
<div class="section" id="test-writers">
<h3><a class="toc-backref" href="#id13" name="test-writers">3.2&nbsp;&nbsp;&nbsp;Test Writers</a></h3>
<p>All test writers are derived from <tt class="docutils literal"><span class="pre">Writer</span></tt>, declared in <tt class="docutils literal"><span class="pre">Writer.h</span></tt>.</p>
<p>The DatWriter is a streaming writer while the UvpWriter buffers the output.</p>
<p>All communication with the model goes through the base writer class using the
following methods:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">set_program_counter_internal</span></tt> which then calls set_program_counter in
ModelInterface.  This method is used by the UvpWriter when it removes the
final halt instruction from it's instruction list and sets the program counter
back before it queries for all final register values.</p>
</blockquote>
<p>The public interface for a Writer is:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">pre_initialize</span></tt> - used to reset the testwriter.</p>
<p><tt class="docutils literal"><span class="pre">post_initialize</span></tt> - used to tell the testwriter initialization is complete so
that it can capture the memory and register state for initial values.</p>
<p><tt class="docutils literal"><span class="pre">pre_finalize</span></tt> - used to tell the testwriter the test is complete so that it can
capture the memory and register state for final results.</p>
<p><tt class="docutils literal"><span class="pre">post_finalize</span></tt> - used to tell the testwriter to clean up.</p>
<p><tt class="docutils literal"><span class="pre">log_used_addresses</span></tt> - used by initialization to let the testwriter know which
addresses will be used in the testcase.  If a new format comes around that
doesn't initialize all used memory in the input file, then this function may
need to be called by the logging interface rather than the initialization.
For that case an initial value will need to be assumed.</p>
<p>the <a class="reference" href="#logging">Logging</a> methods described above</p>
<p><tt class="docutils literal"><span class="pre">writeResults</span></tt> - called by writeOutput to tell the testwriter to write out the testcase</p>
<p><tt class="docutils literal"><span class="pre">regfile_reg</span></tt>, <tt class="docutils literal"><span class="pre">reg</span></tt>, <tt class="docutils literal"><span class="pre">mmu</span></tt> - these methods are part of the communication mechanism
between the testwriter and the core through the ModelInterface.  Since the
testwriter does not know what resources the core has, it calls getRegs and
getMmu through the ModelInterface which then calls showRegs and showMmu
directly on the core.  Those methods then call back through the
ModelInterface to reg/regfile_reg and mmu which then calls the corresponding
methods in the testwriter.</p>
<p>.</p>
</blockquote>
</div>
<div class="section" id="time-tagged-iss">
<h3><a class="toc-backref" href="#id14" name="time-tagged-iss">3.3&nbsp;&nbsp;&nbsp;Time Tagged ISS</a></h3>
<p>As mentioned earlier, the time-tagged ISS is an untimed ISS with the addition of
time tags on various resources (currently just registers).  This is implemented
by having each register (and each element in a register file) use a <tt class="docutils literal"><span class="pre">Tag</span></tt>
object, which contains a time-tag.  The interface to <tt class="docutils literal"><span class="pre">Tag</span></tt> (which is the same
as <tt class="docutils literal"><span class="pre">NoTag</span></tt>) is:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">get_data()</span></tt>:  Return the data element.  In the non-constant case, this
updates the max-time accumulator (explained later) with the current item's
time tag.</li>
<li><tt class="docutils literal"><span class="pre">set_data()</span></tt>:  Sets the data element.  This updates the max-time accumulator
with the current item's time tag and sets this element's time to the max-time
accumulator plus the instruction's latency.</li>
</ul>
<p>The basic architecture of the system is identical to that of an untimed ISS,
except for the use of the <tt class="docutils literal"><span class="pre">Tag</span></tt> objects.  There is also a max-time accumulator
which keeps track of the times of the instruction's operands.  The main
simulation loop is also modified slightly:  Each core gains a member which
stores current time.  Upon entry to <tt class="docutils literal"><span class="pre">simulate</span></tt>, the global accumulator
variable (AccumTime) is set to the core's current time and at the end of the
function, the core's time is updated with the accumulated value.</p>
</div>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="adl-iss-design.rst">View document source</a>.
Generated on: 2018/02/28 15:14:26 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
