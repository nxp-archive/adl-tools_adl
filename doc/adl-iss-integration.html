<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="standard header">
  <link type="text/css" rel="stylesheet" href="/swo/css/fsl.css" />
  <script type="text/javascript" language="javascript" src="/swo/jscripts/FSLHeader.js"></script>
  <script language="JavaScript"> 
        WriteFSHeader(); 
  </script> 
</div></div>
<div class="footer">
<hr class="footer" />
<a class="first last reference" href="./fsl-header.rst">View document source</a>.
Generated on: 2018/02/28 15:14:25 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<title>ADL ISS Model Integration</title>
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="title section" id="adl-iss-model-integration">
<h1><a>ADL ISS Model Integration</a></h1>
<p>This document provides an overview of how to integrate an ADL-generated ISS
library into another application, such as a system model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Brian Kahne</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body"><a class="reference" href="mailto:bkahne&#64;freescale.com">bkahne&#64;freescale.com</a></td>
</tr>
</tbody>
</table>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first"><a name="table-of-contents">Table of Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#adl-iss-model-integration" id="id2" name="id2">ADL ISS Model Integration</a><ul class="auto-toc simple">
<li><a class="reference" href="#general-overview" id="id3" name="id3">1&nbsp;&nbsp;&nbsp;General Overview</a></li>
<li><a class="reference" href="#building-an-adl-library" id="id4" name="id4">2&nbsp;&nbsp;&nbsp;Building an ADL Library</a></li>
<li><a class="reference" href="#the-adl-iss-api" id="id5" name="id5">3&nbsp;&nbsp;&nbsp;The ADL ISS API</a><ul class="auto-toc simple">
<li><a class="reference" href="#instantiating-the-model" id="id6" name="id6">3.1&nbsp;&nbsp;&nbsp;Instantiating the Model</a></li>
<li><a class="reference" href="#simulation-control" id="id7" name="id7">3.2&nbsp;&nbsp;&nbsp;Simulation Control</a></li>
<li><a class="reference" href="#the-debug-api" id="id8" name="id8">3.3&nbsp;&nbsp;&nbsp;The Debug API</a><ul class="auto-toc simple">
<li><a class="reference" href="#register-modification" id="id9" name="id9">3.3.1&nbsp;&nbsp;&nbsp;Register Modification</a></li>
<li><a class="reference" href="#register-and-exception-callbacks" id="id10" name="id10">3.3.2&nbsp;&nbsp;&nbsp;Register and Exception Callbacks</a></li>
<li><a class="reference" href="#memory-modification" id="id11" name="id11">3.3.3&nbsp;&nbsp;&nbsp;Memory Modification</a></li>
</ul>
</li>
<li><a class="reference" href="#the-introspection-api" id="id12" name="id12">3.4&nbsp;&nbsp;&nbsp;The Introspection API</a></li>
<li><a class="reference" href="#the-logging-api" id="id13" name="id13">3.5&nbsp;&nbsp;&nbsp;The Logging API</a></li>
<li><a class="reference" href="#data-dependency-tracking-api" id="id14" name="id14">3.6&nbsp;&nbsp;&nbsp;Data Dependency Tracking API</a></li>
<li><a class="reference" href="#disassembler-api" id="id15" name="id15">3.7&nbsp;&nbsp;&nbsp;Disassembler API</a></li>
<li><a class="reference" href="#dynamic-parameter-api" id="id16" name="id16">3.8&nbsp;&nbsp;&nbsp;Dynamic Parameter API</a></li>
<li><a class="reference" href="#event-bus-api" id="id17" name="id17">3.9&nbsp;&nbsp;&nbsp;Event Bus API</a></li>
<li><a class="reference" href="#external-interrupt-generation" id="id18" name="id18">3.10&nbsp;&nbsp;&nbsp;External Interrupt Generation</a></li>
<li><a class="reference" href="#external-model-communication-api" id="id19" name="id19">3.11&nbsp;&nbsp;&nbsp;External Model Communication API</a></li>
</ul>
</li>
<li><a class="reference" href="#internal-and-external-memories" id="id20" name="id20">4&nbsp;&nbsp;&nbsp;Internal and External Memories</a><ul class="auto-toc simple">
<li><a class="reference" href="#external-memory-interface" id="id21" name="id21">4.1&nbsp;&nbsp;&nbsp;External Memory Interface</a></li>
<li><a class="reference" href="#direct-memory-interface-api" id="id22" name="id22">4.2&nbsp;&nbsp;&nbsp;Direct-Memory-Interface API</a></li>
</ul>
</li>
<li><a class="reference" href="#system-call-support" id="id23" name="id23">5&nbsp;&nbsp;&nbsp;System-Call Support</a></li>
<li><a class="reference" href="#file-readers" id="id24" name="id24">6&nbsp;&nbsp;&nbsp;File Readers</a></li>
<li><a class="reference" href="#a-simple-example" id="id25" name="id25">7&nbsp;&nbsp;&nbsp;A Simple Example</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="general-overview">
<h2><a class="toc-backref" href="#id3" name="general-overview">1&nbsp;&nbsp;&nbsp;General Overview</a></h2>
<p>An ADL-generated ISS model can be used in multiple ways: If linked with the
appropriate libraries it can function as a stand-alone executable or, without
these libraries, can be embedded into another application, such as a model of a
system.  This document describes the latter use and provides an overview of the
API used to communicate with the model.</p>
<p>This API is designed to be as simple and relatively low-level as possible, since
the model might be used in a relatively wide range of applications.  For
example, the logging and tracing mechanism consists of a set of static functions
which are called whenever an event of interest occurs.  These functions
purposefully avoid any kind of heap allocation; it is up to the external
application to store this data in a container if necessary.  Likewise, only the
current state of memory is stored.  It is up to the external application to
track what addresses have been used, if this information is important.</p>
</div>
<div class="section" id="building-an-adl-library">
<h2><a class="toc-backref" href="#id4" name="building-an-adl-library">2&nbsp;&nbsp;&nbsp;Building an ADL Library</a></h2>
<p>The main tool used to generate an ISS from an ADL source file is <tt class="docutils literal"><span class="pre">adl2iss</span></tt>.
To create a base library, the <tt class="docutils literal"><span class="pre">--target=base-so</span></tt> option is used.  For
example:</p>
<pre class="literal-block">adl2iss model.adl --output=model-base.so --target=base-so 
</pre>
<p>This reads <tt class="docutils literal"><span class="pre">model.adl</span></tt> as input and produces <tt class="docutils literal"><span class="pre">model-base.so</span></tt>, a shared
library which contains the ISS and is linked to the necessary support libraries.</p>
<p>If additional capabilities, such as initializing the model from an input file
and logging simulation activity to a trace file are required, then the
<tt class="docutils literal"><span class="pre">--target=so</span></tt> option may be used, which links the generated model with
additional libraries.  This added functionality is not covered by this document.</p>
<p>By default, the library that is generated depends upon the <tt class="docutils literal"><span class="pre">RNumber</span></tt> library,
which is a dynamic, arbitrary-sized integer class.  This class is used by the
ISS debug API to provide support for getting and setting register values of
arbitrarily-large width.  However, it is possible to disable this support by
using the <tt class="docutils literal"><span class="pre">--no-rnumber</span></tt> option.  If this option is used, then the generated
library will no longer be dependent upon RNumber.  Instead, all register
debug accesses will use a 64-bit integer instead, meaning that it will not be
possible to access registers which are wider than 64-bits.</p>
<p>By default, the generated ISS is contained within the namespace <tt class="docutils literal"><span class="pre">adliss</span></tt>.  If
more than one generated simulator is to be included into a single application,
then each simulator must have a unique namespace.  This can be done by using the
<tt class="docutils literal"><span class="pre">iss-namespace=&lt;name&gt;</span></tt> option.</p>
<p>Various other options may also be specified, such as to disable tracing or debug
support.  Run <tt class="docutils literal"><span class="pre">adl2iss</span> <span class="pre">--help</span></tt> to list all available options.</p>
</div>
<div class="section" id="the-adl-iss-api">
<h2><a class="toc-backref" href="#id5" name="the-adl-iss-api">3&nbsp;&nbsp;&nbsp;The ADL ISS API</a></h2>
<p>The ADL ISS API is declared in the header file <tt class="docutils literal"><span class="pre">ModelInterface.h</span></tt>.  Functions
for controlling the simulation are declared in <tt class="docutils literal"><span class="pre">SimInterface.h</span></tt>.  In a normal
installation, these header files will be installed in <tt class="docutils literal"><span class="pre">&lt;prefix&gt;/include/iss</span></tt>,
where <tt class="docutils literal"><span class="pre">&lt;prefix&gt;</span></tt> is the base path of the ADL installation.</p>
<p>Note that if RNumber support is not included then you must define
<tt class="docutils literal"><span class="pre">__NO_RNUMBER__</span></tt> before including <tt class="docutils literal"><span class="pre">ModelInterface.h</span></tt>.  Also note that all
functions are contained within the <tt class="docutils literal"><span class="pre">adl</span></tt> namespace.</p>
<p>All core models are derived from <tt class="docutils literal"><span class="pre">IssCore</span></tt> while systems of cores are derived
from <tt class="docutils literal"><span class="pre">IssSystem</span></tt>.  Both of these classes are derived from <tt class="docutils literal"><span class="pre">IssNode</span></tt>.  This
class provides various methods for getting and setting various resource values,
an introspection mechanism to allow for querying the model for details of the
resources it contains, and simulation control.</p>
<div class="section" id="instantiating-the-model">
<h3><a class="toc-backref" href="#id6" name="instantiating-the-model">3.1&nbsp;&nbsp;&nbsp;Instantiating the Model</a></h3>
<p>All ADL ISS models are re-entrant.  A given model library has a single top-level
model element which might be a system containing multiple cores or systems of
cores.  Only the top-level element may be explicitly instantiated by an
external application.</p>
<p>The function <tt class="docutils literal"><span class="pre">IssNode</span> <span class="pre">*adliss::createTopLevelNode(unsigned</span> <span class="pre">&amp;id)</span></tt> instantiates
this top-level element and returns a pointer to the object.  This function may
be called multiple times in order to create multiple instances of the model.
The <tt class="docutils literal"><span class="pre">id</span></tt> parameter is used to assign a unique ID to each core that is
allocated.  Each core uses the given value and then post-increments it.</p>
<p>If a model is placed into a unique namespace, then you must change <tt class="docutils literal"><span class="pre">adliss</span></tt> to
the appropriate string.  In order to get the declaration for this function,
<tt class="docutils literal"><span class="pre">ModelInterface.h</span></tt> may be included multiple times with different defines for
<tt class="docutils literal"><span class="pre">ISS_NAMESPACE</span></tt>.  For example:</p>
<pre class="literal-block">#define ISS_NAMESPACE foo
#include ModelInterface.h

#define ISS_NAMESPACE bar
#include ModelInterface.h
</pre>
<p>In this example, the namespaces <tt class="docutils literal"><span class="pre">foo</span></tt> and <tt class="docutils literal"><span class="pre">bar</span></tt> were used to differentiate
between two different generated simulators.</p>
</div>
<div class="section" id="simulation-control">
<h3><a class="toc-backref" href="#id7" name="simulation-control">3.2&nbsp;&nbsp;&nbsp;Simulation Control</a></h3>
<p>An ADL ISS model may be reset on a per-core basis by calling
<tt class="docutils literal"><span class="pre">IssNode::reset()</span></tt>.  This resets a model to its power-on-reset values.  All
global resources, such as memory, may also be reset by calling
<tt class="docutils literal"><span class="pre">resetGlobal()</span></tt>.</p>
<p>The following API functions exist for controlling the model during simulation:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ProgramStatus</span> <span class="pre">exec_from_buffer(uint32_t</span> <span class="pre">*buf,unsigned</span> <span class="pre">n)</span></tt>: Directly
executes an instruction stored in <tt class="docutils literal"><span class="pre">buf</span></tt>, where <tt class="docutils literal"><span class="pre">n</span></tt> specifies the number of
words in <tt class="docutils literal"><span class="pre">buf</span></tt>.  Data is copied from <tt class="docutils literal"><span class="pre">buf</span></tt> to an internal buffer, then
executed, skipping the normal fetch sequence.  This is useful for modeling
features such as an external-debug mode, where an outside controller might
insert instructions directly into the core.</li>
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">run()</span></tt>:  This cycles the model until there are no more active cores.
Execution may be interrupted by throwing a <tt class="docutils literal"><span class="pre">SimInterrupt</span></tt> exception,
explained below.</li>
<li><tt class="docutils literal"><span class="pre">ProgramStatus</span> <span class="pre">step()</span></tt>:  Cycles the model once.  If this is a system, then
all constituent items are cycled once.  Returns a status value, declared in
<tt class="docutils literal"><span class="pre">ModelInterface.h</span></tt>, which describes the resulting state of the model,
e.g. if the model is active, hit a breakpoint or watchpoint, or is halted.
Refer to <a class="reference" href="#log-breakpoint">log_breakpoint</a> for more information about breakpoints.</li>
<li><tt class="docutils literal"><span class="pre">ProgramStatus</span> <span class="pre">stepn(unsigned</span> <span class="pre">n)</span></tt>: Cycles the model <tt class="docutils literal"><span class="pre">n</span></tt> times.  If this is
a system, then all constituent items are cycled <tt class="docutils literal"><span class="pre">n</span></tt> times.  Returns a status
value, declared in <tt class="docutils literal"><span class="pre">ModelInterface.h</span></tt>, which describes the resulting state
of the model, e.g. if the model is active, hit a breakpoint or watchpoint, or
is halted.</li>
</ul>
<p>If the model was generated with tracing and debug support then breakpoints and
watchpoints may be set by an external application.  The API for doing this is:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">setBreakpoint(addr_t,PtBase</span> <span class="pre">*payload</span> <span class="pre">=</span> <span class="pre">0)</span></tt>: Set a breakpoint at
the specified effective address.  Returns an integer handle for the
breakpoint.</li>
<li><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">setTmpBreakpoint(addr_t,PtBase</span> <span class="pre">*payload</span> <span class="pre">=</span> <span class="pre">0)</span></tt>: Set a temporary
breakpoint at the specified effective address.  This type of breakpoint will
be erased once it has been triggered.  Returns an integer handle for the
breakpoint.</li>
<li><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">setWatchpoint(addr_t,WatchType</span> <span class="pre">type,PtBase</span> <span class="pre">*payload</span> <span class="pre">=</span> <span class="pre">0)</span></tt>: Set a
watchpoint at the specified effective address.  <tt class="docutils literal"><span class="pre">type</span></tt> is an enumerated type
describing the types of actions to which the watchpoint is sensitive, e.g. on
a read or a write, and is declared in <tt class="docutils literal"><span class="pre">BasicTypes.h</span></tt>.  Returns an integer
handle for the watchpoint.</li>
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">clearBreakpoints()</span></tt>:  Clear all breakpoints in the model.</li>
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">clearWatchpoints()</span></tt>:  Clear all watchpoints in the model.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">clearBreakpoint(unsigned</span> <span class="pre">h)</span></tt>:  Clear a breakpoint, specified by a
given handle.  Returns true on success, false on failure.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">clearWatchpoint(unsigned</span> <span class="pre">h)</span></tt>:  Clear a watchpoint, specified by a
given handle.  Returns true on success, false on failure.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">clearBreakpointByAddr(addr_t</span> <span class="pre">addr)</span></tt>:  Clear a breakpoint, specified by
an address.  Returns true on success, false on failure.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">clearWatchpointByAddr(addr_t</span> <span class="pre">addr,WatchType</span> <span class="pre">type)</span></tt>: Clear a
watchpoint, specified by an address and type.  Returns true on success, false
on failure.</li>
</ul>
<p>When a breakpoint or watchpoint is encountered, the model will call the
respective logging function, <tt class="docutils literal"><span class="pre">log_breakpoint()</span></tt> or <tt class="docutils literal"><span class="pre">log_watchpoint</span></tt>, with
the handle of the breakpoint or watchpoint and the payload pointer that was
provided..  These functions are described in more detail in <a class="reference" href="#the-logging-api">The Logging API</a>.
The call-back function may then throw a <tt class="docutils literal"><span class="pre">SimInterrupt</span></tt> exception in order to
stop the simulation.</p>
</div>
<div class="section" id="the-debug-api">
<h3><a class="toc-backref" href="#id8" name="the-debug-api">3.3&nbsp;&nbsp;&nbsp;The Debug API</a></h3>
<p>The debug API allows an external program to query the present state of the model
and to modify internal resources.  Various methods of <tt class="docutils literal"><span class="pre">IssNode</span></tt> are used to
perform these actions.  This section describes only a portion of the API; please
refer to <tt class="docutils literal"><span class="pre">ModelInterface.h</span></tt> for a complete description.  In general, <em>get</em> and
<em>set</em> routines exist for various types of resources, enabling an external
application to read and write resource values.</p>
<p>In addition, <em>show</em> routines provide a mechanism for iterating over all
resources of a given type.  A <em>show</em> routine takes a reference to a
<tt class="docutils literal"><span class="pre">ReportBase</span></tt> object and calls a relevant method of this object for each
resource of a given type in the model.  For example, <tt class="docutils literal"><span class="pre">ReportBase::report_req</span></tt>
is called for each register when <tt class="docutils literal"><span class="pre">showRegs</span></tt> is executed.</p>
<div class="section" id="register-modification">
<h4><a class="toc-backref" href="#id9" name="register-modification">3.3.1&nbsp;&nbsp;&nbsp;Register Modification</a></h4>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">setReg(const</span> <span class="pre">std::string</span> <span class="pre">&amp;name,unsigned</span> <span class="pre">index,uint64</span> <span class="pre">value)</span></tt>: Sets a
register of the specified name.  Returns false if the specified register does
not exist.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><strong>name</strong></dt>
<dd>The name of the register to modify.</dd>
<dt><strong>index</strong></dt>
<dd>If this is a register file, <strong>index</strong> may be used to specify an element of
the register file.  An element of a register file may also be modified by
appending the index to its name, e.g. <tt class="docutils literal"><span class="pre">GPR5</span></tt> would modify element 5 of a
register file named <tt class="docutils literal"><span class="pre">GPR</span></tt>.</dd>
<dt><strong>value</strong>:</dt>
<dd>The value to which the register should be set.  Note that this function does
not cause side-effects specified using register write hooks.  However, the
state of the model is updated, such as for activating contexts.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">setReg(const</span> <span class="pre">std::string</span> <span class="pre">&amp;name,unsigned</span> <span class="pre">index,const</span> <span class="pre">rnumber::RNumber</span>
<span class="pre">&amp;value)</span></tt>: Same as above.  However, <strong>value</strong> is an RNumber, which allows a
register of arbitrary width to be set.  This function is only present if the
model was generated with RNumber support.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">getReg(const</span> <span class="pre">std::string</span> <span class="pre">&amp;name,unsigned</span> <span class="pre">index,uint64</span> <span class="pre">&amp;value)</span> <span class="pre">const</span></tt>:
Get the value of a register.  Returns false if the register does not exist.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><strong>name</strong></dt>
<dd>The name of the register.</dd>
<dt><strong>index</strong></dt>
<dd>If this is a register file, <strong>index</strong> may be used to specify an element of
the register file.  An element of a register file may also be read by
appending the index to its name, e.g. <tt class="docutils literal"><span class="pre">GPR5</span></tt> would retrieve element 5 of a
register file named <tt class="docutils literal"><span class="pre">GPR</span></tt>.</dd>
<dt><strong>value</strong></dt>
<dd>The value of the register is stored into this parameter.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">getReg(const</span> <span class="pre">std::string</span> <span class="pre">&amp;name,unsigned</span> <span class="pre">index,rnumber::RNumber</span> <span class="pre">&amp;value)</span>
<span class="pre">const</span></tt>: Same as above.  However, <strong>value</strong> is an RNumber, which allows a
register of arbitrary width to be read.  This function is only present if the
model was generated with RNumber support.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">showRegs(ReportBase</span> <span class="pre">&amp;)</span> <span class="pre">const</span></tt>: Causes the model to iterate through all
registers and register-files, calling the <tt class="docutils literal"><span class="pre">report_reg</span></tt> and
<tt class="docutils literal"><span class="pre">report_regfile</span></tt> methods of <tt class="docutils literal"><span class="pre">ReportBase</span></tt> for each element.  The
<tt class="docutils literal"><span class="pre">ReportBase</span></tt> class is an interface and is declared in <tt class="docutils literal"><span class="pre">ModelInterface.h</span></tt>.</p>
</li>
</ul>
</div>
<div class="section" id="register-and-exception-callbacks">
<h4><a class="toc-backref" href="#id10" name="register-and-exception-callbacks">3.3.2&nbsp;&nbsp;&nbsp;Register and Exception Callbacks</a></h4>
<p>ISS models support register and exception callbacks: The ability to notify a
registered functor when a value has changed or when an exception has been
raised.  At model-build time, the user must specify which registers or exceptions
should have callback support.  This is done via a config file.  For example,
given an ADL model with a core named <tt class="docutils literal"><span class="pre">P</span></tt>, the following code (placed into a
configuration file named, for example <tt class="docutils literal"><span class="pre">config.ttc</span></tt>) would specify that
registers <tt class="docutils literal"><span class="pre">HID0</span></tt> and <tt class="docutils literal"><span class="pre">HID1</span></tt> should have callback support:</p>
<pre class="literal-block">define(core=P) {
  define (config) {
    reg_callbacks = (HID0,HID1);
  }
}
</pre>
<p>For exceptions, the key is <tt class="docutils literal"><span class="pre">exception_callbacks</span></tt>.  This file would then be
specified on the <tt class="docutils literal"><span class="pre">adl2iss</span></tt> command-line using the following option:
<tt class="docutils literal"><span class="pre">--config-file=config.ttc</span></tt>.</p>
<p>A platform model's ADL wrapper could then register callbacks by calling
<tt class="docutils literal"><span class="pre">IssNode::setRegCallback</span></tt>.  Two versions of this function exist:</p>
<pre class="literal-block">virtual bool setRegCallback(unsigned rindex,RegCallback *cb);
virtual bool setRegCallback(const std::string &amp;name,RegCallback *cb);
</pre>
<p>The first version takes an integer handle to specify the register; the second
uses the register's name as a string.</p>
<p>For exceptions, the registration functions are:</p>
<pre class="literal-block">virtual bool setExeptCallback(unsigned index,ExceptCallback *cb);
virtual bool setExceptCallback(const std::string &amp;name,ExceptCallback *cb);
</pre>
<p>A callback is simply an object derived from <em>RegCallback</em> or
<em>ExceptCallback</em>:</p>
<pre class="literal-block">struct RegCallback {
  virtual ~RegCallback() {};
  virtual void operator()(unsigned index,REGTYPE value) {};
};

struct ExceptCallback() {
  virtual ~ExceptCallback() {};
  virtual void operator()() {};
};
</pre>
<p>On an update of the specified register, <tt class="docutils literal"><span class="pre">operator()</span></tt> is called with the new
value.  In the case of a register-file, the index of the update is also called.
ADL does not currently support callbacks for specific elements of a
register-file.  For an exception, <tt class="docutils literal"><span class="pre">operator()</span></tt> is called immediately after the
exception's action code has been executed.</p>
<p>For register callbacks, the value's type, <tt class="docutils literal"><span class="pre">REGTYPE</span></tt>, depends upon how the
model is built.  Normally, it will be of type <tt class="docutils literal"><span class="pre">RNumber</span></tt>, but if the model is
built without RNumber support, then it will be of type <tt class="docutils literal"><span class="pre">uint64_t</span></tt>.  In order
to be consistent, wrapper code which includes <tt class="docutils literal"><span class="pre">ModelInterface.h</span></tt> must define
<tt class="docutils literal"><span class="pre">__NO_RNUMBER__</span></tt> if the model was built with no RNumber support.</p>
</div>
<div class="section" id="memory-modification">
<h4><a class="toc-backref" href="#id11" name="memory-modification">3.3.3&nbsp;&nbsp;&nbsp;Memory Modification</a></h4>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">setMem(const</span> <span class="pre">std::string</span> <span class="pre">&amp;name,</span> <span class="pre">addr_t</span> <span class="pre">addr,</span> <span class="pre">uint32</span> <span class="pre">data,</span> <span class="pre">unsigned</span>
<span class="pre">size)</span></tt>:  Set a value in memory.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><strong>name</strong></dt>
<dd>The name of the memory.  The global memory is named <strong>Mem</strong>.</dd>
<dt><strong>addr</strong></dt>
<dd>The destination address.  This is a real address; no translation is
performed.</dd>
<dt><strong>data</strong></dt>
<dd>The new memory data value.</dd>
<dt><strong>size</strong></dt>
<dd>The number of bytes (1 to 4) to actually write.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">uint32</span> <span class="pre">getMem(const</span> <span class="pre">std::string</span> <span class="pre">&amp;name,</span> <span class="pre">addr_t</span> <span class="pre">addr)</span></tt>:  Read memory.</p>
<dl class="docutils">
<dt><strong>name</strong></dt>
<dd>The name of the memory.  The global memory is named <strong>Mem</strong>.</dd>
<dt><strong>addr</strong></dt>
<dd>The source address.  This is a real address; no translation is performed.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">uint32</span> <span class="pre">getMem(unsigned</span> <span class="pre">id,</span> <span class="pre">addr_t</span> <span class="pre">addr)</span></tt>:  Same as above, except that this
version allows the user to specify the source memory using an integer handle
in order to avoid the overhead of string comparisons.  The global memory
always has an index of 0.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">showMem(ReportBase</span> <span class="pre">&amp;)</span></tt>: Causes the model to iterate through all
registers and register-files, calling the <tt class="docutils literal"><span class="pre">report_memory`</span> <span class="pre">method</span> <span class="pre">of</span>
<span class="pre">``ReportBase</span></tt> for each element.  The <tt class="docutils literal"><span class="pre">ReportBase</span></tt> class is an interface and
is declared in <tt class="docutils literal"><span class="pre">ModelInterface.h</span></tt>.  The model does not track what memory is,
or is not, initialized.  This must be done by an external object if such
information is necessary.</p>
</li>
</ul>
<p>The reason that each <tt class="docutils literal"><span class="pre">IssNode</span></tt> object contains an API for reading and writing
memory is that it is possible to define memories which are local resources of
the core.  In the case where such memories do not exist and there is only a
single global memory, this API can be bypassed.  The following routines can be
used to read and write memory globally:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">uint64</span> <span class="pre">mem_read64</span> <span class="pre">(addr_t</span> <span class="pre">addr)</span></tt>: Read a 64-bit value from the global
memory.</li>
<li><tt class="docutils literal"><span class="pre">uint32</span> <span class="pre">mem_read32</span> <span class="pre">(addr_t</span> <span class="pre">addr)</span></tt>: Read a 32-bit value from the global
memory.</li>
<li><tt class="docutils literal"><span class="pre">uint16</span> <span class="pre">mem_read16(addr_t</span> <span class="pre">addr)</span></tt>: Read a 16-bit value from the global
memory.</li>
<li><tt class="docutils literal"><span class="pre">uint8</span> <span class="pre">mem_read8</span> <span class="pre">(addr_t</span> <span class="pre">addr)</span></tt>: Read an 8-bit value from the global memory.</li>
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">mem_write64</span>&nbsp; <span class="pre">(addr_t</span> <span class="pre">addr,uint64</span> <span class="pre">value,uint64</span>
<span class="pre">mask=0xffffffffffffffffULL)</span></tt>:  Write a 64-bit value to memory.  The mask
specifies what bits of <tt class="docutils literal"><span class="pre">value</span></tt> are written to memory.  The default is to
write the entire 64-bit value.</li>
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">mem_write32</span>&nbsp; <span class="pre">(addr_t</span> <span class="pre">addr,uint32</span> <span class="pre">value,uint32</span> <span class="pre">mask=0xffffffff)</span></tt>:
Write a 32-bit value to memory.</li>
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">mem_write16(addr_t</span> <span class="pre">addr,uint16</span> <span class="pre">value,uint16</span> <span class="pre">mask=0xffff)</span></tt>: Write a
16-bit value to memory.</li>
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">mem_write8</span> <span class="pre">(addr_t</span> <span class="pre">addr,uint8</span> <span class="pre">value)</span></tt>: Write an 8-bit value to memory.</li>
</ul>
<p>As noted above, all addresses are real addresses and no address translation is
performed.  If it is necessary to translate addresses then the translation must
be performed explicitly using the following API.  Note that these are methods of
<tt class="docutils literal"><span class="pre">IssCore</span></tt>, so it may be necessary to perform a <tt class="docutils literal"><span class="pre">dynamic_cast</span></tt> in order to
obtain a pointer of the necessary type.  These translations are meant to not
cause side-effects: Permission checking or miss handling are not performed.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">extInstrReadTranslate(addr_t</span> <span class="pre">&amp;ra,addr_t</span> <span class="pre">ea,bool</span> <span class="pre">log</span> <span class="pre">=</span> <span class="pre">false)</span></tt>:
Translate an effective address to a real address as an instruction-read, using
the core's MMU.  If <tt class="docutils literal"><span class="pre">log</span></tt> is true, then MMU logging events are generated,
even if normal tracing for this type of event is turned off.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">extDataReadTranslate(addr_t</span> <span class="pre">&amp;ra,addr_t</span> <span class="pre">ea,bool</span> <span class="pre">log</span> <span class="pre">=</span> <span class="pre">false)</span></tt>:
Translate an effective address to a real address as a data-read, using the
core's MMU.  If <tt class="docutils literal"><span class="pre">log</span></tt> is true, then MMU logging events are generated, even
if normal tracing for this type of event is turned off.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">extDataWriteTranslate(addr_t</span> <span class="pre">&amp;ra,addr_t</span> <span class="pre">ea,bool</span> <span class="pre">log</span> <span class="pre">=</span> <span class="pre">false)</span></tt>:
Translate an effective address to a real address as a data-write, using the
core's MMU.  If <tt class="docutils literal"><span class="pre">log</span></tt> is true, then MMU logging events are generated, even
if normal tracing for this type of event is turned off.</li>
</ul>
<p>The memory access functions directly read from and write to the memories,
bypassing any caches which might be present.  In order to read or write data
from the top of the memory hierarchy, the following routines are provided.  In
the case of reads, the caches are not modified; if an address is not present,
the routine goes to the next level of the memory hierarchy.  In the case of
writes, the routine visits each level of the memory hierarchy, updating the data
if the address is already present, but not modifying the cache if it is not
present.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">debug_instr_read(uint32_t</span> <span class="pre">&amp;result,bool</span> <span class="pre">trans,addr_t</span> <span class="pre">addr,int</span> <span class="pre">size)</span></tt>:
Reads from the instruction memory hierarchy.</li>
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">debug_instr_write(bool</span> <span class="pre">trans,addr_t</span> <span class="pre">addr,uint32_t</span> <span class="pre">value,int</span> <span class="pre">size)</span></tt>:
Writes to the instruction memory hierarchy.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">debug_data_read(uint32_t</span> <span class="pre">&amp;result,unsigned</span> <span class="pre">id,bool</span> <span class="pre">trans,addr_t</span> <span class="pre">addr,int</span>
<span class="pre">size)</span></tt>: Reads from the data hierarchy.  A specific memory may be designated
via <tt class="docutils literal"><span class="pre">id</span></tt>; 0 represents the global memory.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">debug_data_write(unsigned</span> <span class="pre">id,bool</span> <span class="pre">trans,addr_t</span> <span class="pre">addr,uint32_t</span> <span class="pre">value,int</span>
<span class="pre">size)</span></tt>: Writes to the data hierarchy.  A specific memory may be designated
via <tt class="docutils literal"><span class="pre">id</span></tt>; 0 represents the global memory.</li>
</ul>
</div>
</div>
<div class="section" id="the-introspection-api">
<h3><a class="toc-backref" href="#id12" name="the-introspection-api">3.4&nbsp;&nbsp;&nbsp;The Introspection API</a></h3>
<p>The introspection API allows an external program to query the model for
information about the resources it contains.  These methods are all members of
<tt class="docutils literal"><span class="pre">IssNode</span></tt> and return constant data structures declared in <tt class="docutils literal"><span class="pre">Introspection.h</span></tt>.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">MmuInfo</span> <span class="pre">&amp;getMmuInfo()</span> <span class="pre">const</span></tt>: Return information about the model's
MMU.</li>
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">RegInfos</span> <span class="pre">&amp;getRegInfo()</span> <span class="pre">const</span></tt>: Return information about the model's
registers and register-files.</li>
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">CacheInfos</span> <span class="pre">&amp;getCacheInfo()</span> <span class="pre">const</span></tt>: Return information about the
model's caches.</li>
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">MemInfos</span> <span class="pre">&amp;getMemInfo()</span> <span class="pre">const</span></tt>: Return information about the model's
memories.</li>
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">ExceptionInfos</span> <span class="pre">&amp;getExceptionInfo()</span> <span class="pre">const</span></tt>: Return information about
the model's exceptions.</li>
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">CtxInfos</span> <span class="pre">&amp;getContextInfo()</span> <span class="pre">const</span></tt>: Return information about the
model's contexts.</li>
</ul>
</div>
<div class="section" id="the-logging-api">
<h3><a class="toc-backref" href="#id13" name="the-logging-api">3.5&nbsp;&nbsp;&nbsp;The Logging API</a></h3>
<p>If tracing is enabled, then the model will call logging methods of its installed
logger object when various actions occur, such as when a register is written or
memory is accessed.  The logging interface is defined in <tt class="docutils literal"><span class="pre">ModelInterface.h</span></tt>
and is called <tt class="docutils literal"><span class="pre">LogBase</span></tt>.</p>
<p>If the model has been generated with tracing support then the logging of
different types of events can be controlled on an individual basis.  Event types
are described using the enumerated type <tt class="docutils literal"><span class="pre">TraceType</span></tt>, declared in
<tt class="docutils literal"><span class="pre">ModelInterface.h</span></tt>.  The API for turning tracing on and off is:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">set_tracing(unsigned</span> <span class="pre">flags</span> <span class="pre">=</span> <span class="pre">(unsigned)-1)</span></tt>: Toggle on tracing.
The value is or'd with the current value and the previous value is returned.
The default is to activate all logging.</li>
<li><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">clear_tracing(unsigned</span> <span class="pre">flags</span> <span class="pre">=</span> <span class="pre">(unsigned)-1)</span></tt>: Toggle off tracing.
The bits set in the argument turn off the relevant tracing activities.
Default is to turn off all events.  Returns the prior value.</li>
<li><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">set_tracing_flags(unsigned</span> <span class="pre">flags)</span></tt>: Set the tracing flags
directly.  Returns the prior value.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">tracing_on()</span></tt>:  Returns true if any tracing is activated.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">tracing_on(unsigned</span> <span class="pre">flags)</span></tt>: Returns true if the specified tracing
events are all on.</li>
<li><tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">tracing_flags()</span></tt>:  Returns the current tracing flags.</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">IssNode</span></tt> interface for installing and accessing logging objects is:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">LogBase</span> <span class="pre">&amp;IssNode::logger()</span> <span class="pre">const</span></tt>: Return a reference to the installed
logger.  Some sort of logger is always installed, even if it is just a
place-holder which does nothing.</li>
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">IssNode::setLogger(LogBase</span> <span class="pre">*)</span></tt>: Install a new logger.  If the argument
is 0, then a dummy logger is set instead.  Although this interface is defined
for <tt class="docutils literal"><span class="pre">IssNode</span></tt>, only <tt class="docutils literal"><span class="pre">IssCore</span></tt> objects actually implement the interface.</li>
</ul>
<p>The following are the event logging methods of <tt class="docutils literal"><span class="pre">LogBase</span></tt>:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_instr_prefetch(addr_t</span> <span class="pre">ea)</span></tt>: Logs the fact that an instruction is
going to be fetched.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><strong>ea</strong></dt>
<dd>The effective address of the impending fetch.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_instr_read(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,addr_t</span> <span class="pre">ea,addr_t</span> <span class="pre">ra,uint32</span>
<span class="pre">value)</span></tt>:  Logs the instruction fetch action itself.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the memory.</dd>
<dt><strong>name</strong></dt>
<dd>Memory from which the instruction is being read.</dd>
<dt><strong>ea/ra</strong></dt>
<dd>Effective and real address of the read.</dd>
<dt><strong>value</strong></dt>
<dd>The memory value that was read.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_instr(uint32</span> <span class="pre">*opc,int</span> <span class="pre">num_half_bytes,const</span> <span class="pre">char</span> <span class="pre">*name,Disassembler</span>
<span class="pre">dis,uint32_t</span> <span class="pre">flags)</span></tt>: Logs the instruction usage.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><strong>opc</strong></dt>
<dd>The opcode of the instruction.</dd>
<dt><strong>num_bytes</strong></dt>
<dd>The length of the instruction in bytes.</dd>
<dt><strong>name</strong></dt>
<dd>The name of the instruction.</dd>
<dt><strong>dis</strong></dt>
<dd>A disassembler function, which will write a complete disassembly line to a
supplied stream.</dd>
<dt><strong>flags</strong></dt>
<dd>Information about the instruction.  The bit flags are defined by
<strong>InstrFlags</strong> in <strong>ModelInterface.h</strong>.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_instr_issue_time(ttime_t</span> <span class="pre">issue_time)</span></tt>: For a time-tagged ISS, this
logs the issue time of the instruction.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><strong>issue_time</strong></dt>
<dd>Time when the instruction was issued.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_instr_completion_time(ttime_t</span> <span class="pre">issue_time)</span></tt>: For a time-tagged ISS,
this logs the completion time of the instruction.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><strong>completion_time</strong></dt>
<dd>Time when the instruction was issued.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_reg_write(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,REGTYPE</span> <span class="pre">value)</span></tt>:  Logs a register write operation.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the register.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the register.</dd>
<dt><strong>value</strong></dt>
<dd>The new value of the register.  The type of this parameter is <tt class="docutils literal"><span class="pre">uint64</span></tt> if
the model was generated with <tt class="docutils literal"><span class="pre">--no-rnumber</span></tt> and <tt class="docutils literal"><span class="pre">const</span> <span class="pre">rnumber::RNumber</span>
<span class="pre">&amp;</span></tt> otherwise.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_regfile_write(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,uint32</span> <span class="pre">index,REGTYPE</span>
<span class="pre">value)</span></tt>:  Logs a register-file write operation.</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the register file.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the register.</dd>
<dt><strong>index</strong></dt>
<dd>Index of the element being written.</dd>
<dt><strong>value</strong></dt>
<dd>The new value of the register.  The type of this parameter is <strong>uint64_t</strong> if
the model was generated with <strong>--no-rnumber</strong> and <strong>const rnumber::RNumber
&amp;</strong> otherwise.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_reg_read(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,REGTYPE</span> <span class="pre">value)</span></tt>: Logs a
register read operation.  This is only called if the model was generated with
<strong>--log-reg-reads</strong>.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the register.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the register.</dd>
<dt><strong>value</strong></dt>
<dd>The new value of the register.  The type of this parameter is <strong>uint64_t</strong> if
the model was generated with <strong>--no-rnumber</strong> and <strong>const rnumber::RNumber
&amp;</strong> otherwise.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_regfile_read(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,uint32</span> <span class="pre">index,REGTYPE</span>
<span class="pre">value)</span></tt>: Logs a register-file read operation.  This is only called if the
model was generated with <strong>--log-reg-reads</strong>.</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the register file.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the register.</dd>
<dt><strong>index</strong></dt>
<dd>Index of the element being written.</dd>
<dt><strong>value</strong></dt>
<dd>The new value of the register.  The type of this parameter is <strong>uint64_t</strong> if
the model was generated with <strong>--no-rnumber</strong> and <strong>const rnumber::RNumber
&amp;</strong> otherwise.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_reg_write_mask(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,REGTYPE</span> <span class="pre">value,REGTYPE</span>
<span class="pre">mask)</span></tt>: Logs a partial register write operation.  This is only called if the
model was generated with the <strong>--log-reg-masks</strong> option.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the register.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the register.</dd>
<dt><strong>value</strong></dt>
<dd>The new value of the register.  The type of this parameter is <strong>uint64</strong> if
the model was generated with <strong>--no-rnumber</strong> and <strong>const rnumber::RNumber
&amp;</strong> otherwise.</dd>
<dt><strong>mask</strong></dt>
<dd>The portion of the register accessed.  The type of this parameter is <strong>uint64_t</strong> if
the model was generated with <strong>--no-rnumber</strong> and <strong>const rnumber::RNumber
&amp;</strong> otherwise.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_regfile_write_mask(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,uint32</span>
<span class="pre">index,REGTYPE</span> <span class="pre">value,REGTYPE</span> <span class="pre">mask)</span></tt>: Logs a partial register-file write
operation.  This is only called if the model was generated with the
<strong>--log-reg-masks</strong> option.</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the register file.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the register.</dd>
<dt><strong>index</strong></dt>
<dd>Index of the element being written.</dd>
<dt><strong>value</strong></dt>
<dd>The new value of the register.  The type of this parameter is <strong>uint64_t</strong> if
the model was generated with <strong>--no-rnumber</strong> and <strong>const rnumber::RNumber
&amp;</strong> otherwise.</dd>
<dt><strong>mask</strong></dt>
<dd>The portion of the register accessed.  The type of this parameter is <strong>uint64_t</strong> if
the model was generated with <strong>--no-rnumber</strong> and <strong>const rnumber::RNumber
&amp;</strong> otherwise.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_reg_read_mask(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,REGTYPE</span> <span class="pre">value,REGTYPE</span>
<span class="pre">mask)</span></tt>: Logs a partial register read operation.  This is only called if the
model was generated with the <strong>--log-reg-reads</strong> and <strong>--log-reg-masks</strong>
options.</p>
<p>Arguments:</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the register.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the register.</dd>
<dt><strong>value</strong></dt>
<dd>The new value of the register.  The type of this parameter is <strong>uint64_t</strong> if
the model was generated with <strong>--no-rnumber</strong> and <strong>const rnumber::RNumber
&amp;</strong> otherwise.</dd>
<dt><strong>mask</strong></dt>
<dd>The portion of the register accessed.  The type of this parameter is <strong>uint64_t</strong> if
the model was generated with <strong>--no-rnumber</strong> and <strong>const rnumber::RNumber
&amp;</strong> otherwise.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_regfile_read_mask(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,uint32</span> <span class="pre">index,REGTYPE</span>
<span class="pre">value,REGTYPE</span> <span class="pre">mask)</span></tt>: Logs a register-file read operation.  This is only
called if the model was generated with the <strong>--log-reg-reads</strong> and
<strong>--log-reg-masks</strong> options.</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the register file.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the register.</dd>
<dt><strong>index</strong></dt>
<dd>Index of the element being written.</dd>
<dt><strong>value</strong></dt>
<dd>The new value of the register.  The type of this parameter is <strong>uint64_t</strong> if
the model was generated with <strong>--no-rnumber</strong> and <strong>const rnumber::RNumber
&amp;</strong> otherwise.</dd>
<dt><strong>mask</strong></dt>
<dd>The portion of the register accessed.  The type of this parameter is <strong>uint64_t</strong> if
the model was generated with <strong>--no-rnumber</strong> and <strong>const rnumber::RNumber
&amp;</strong> otherwise.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_core_mem_write(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,addr_t</span> <span class="pre">ea,int</span>
<span class="pre">num_bytes)</span></tt>:  Logs a memory write from the core's point of view.</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the memory.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the memory.</dd>
<dt><strong>ea</strong></dt>
<dd>Effective address of the operation.</dd>
<dt><strong>num_bytes</strong></dt>
<dd>Number of bytes of the operation.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_core_mem_read(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,addr_t</span> <span class="pre">ea,int</span>
<span class="pre">num_bytes)</span></tt>:    Logs a memory read from the core's point of view.</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the memory.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the memory.</dd>
<dt><strong>ea</strong></dt>
<dd>Effective address of the operation.</dd>
<dt><strong>num_bytes</strong></dt>
<dd>Number of bytes of the operation.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_core_mem_write_typed(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,addr_t</span> <span class="pre">ea,int</span>
<span class="pre">num_bytes,CacheAccess</span> <span class="pre">type)</span></tt>:  Logs a memory write from the core's point of
view.  This is used when a <em>typed</em> access is performed, i.e. the user has
specified a specific CacheAccess value for the memory access.</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the memory.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the memory.</dd>
<dt><strong>ea</strong></dt>
<dd>Effective address of the operation.</dd>
<dt><strong>num_bytes</strong></dt>
<dd>Number of bytes of the operation.</dd>
<dt><strong>type</strong></dt>
<dd>The user-specified access type.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_core_mem_read_typed(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,addr_t</span> <span class="pre">ea,int</span>
<span class="pre">num_bytes,CacheAccess</span> <span class="pre">type)</span></tt>: Logs a memory read from the core's point of
view.  This is used when a <em>typed</em> access is performed, i.e. the user has
specified a specific CacheAccess value for the memory access.</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the memory.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the memory.</dd>
<dt><strong>ea</strong></dt>
<dd>Effective address of the operation.</dd>
<dt><strong>num_bytes</strong></dt>
<dd>Number of bytes of the operation.</dd>
<dt><strong>type</strong></dt>
<dd>The user-specified access type.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_mem_write(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,bool</span> <span class="pre">pre,int</span> <span class="pre">seq,addr_t</span> <span class="pre">ea,addr_t</span>
<span class="pre">ra,uint32</span> <span class="pre">value)</span></tt>: This reflects a memory write from the point of view of
the memory's new state.</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the memory.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the memory.</dd>
<dt><strong>pre</strong></dt>
<dd>If true, the call is before the action is taken.  If false, the action has
occurred and the value reflects the new state of memory.</dd>
<dt><strong>seq</strong></dt>
<dd>This indicates which write is occurring.  This will only be non-zero for
misaligned writes.</dd>
<dt><strong>ea/ra</strong></dt>
<dd>Effective and real address of the operation.  This is always a 32-bit
word-aligned address.</dd>
<dt><strong>value</strong></dt>
<dd>The new value of memory.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_mem_read(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,bool</span> <span class="pre">pre,int</span> <span class="pre">seq,addr_t</span> <span class="pre">ea,addr_t</span> <span class="pre">ra,uint32</span>
<span class="pre">value)</span></tt>: This reflects a memory read from the point of view of the memory's
new state.</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the memory.</dd>
<dt><strong>name</strong></dt>
<dd>Name of the memory.</dd>
<dt><strong>pre</strong></dt>
<dd>If true, the call is before the action is taken.  If false, the action has
occurred and the value reflects the new state of memory.</dd>
<dt><strong>seq</strong></dt>
<dd>This indicates which write is occurring.  This will only be non-zero for
misaligned writes.</dd>
<dt><strong>ea/ra</strong></dt>
<dd>Effective and real address of the operation.  This is always a 32-bit
word-aligned address.</dd>
<dt><strong>value</strong></dt>
<dd>The value of memory that was read.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_mmu_translation(TransType</span> <span class="pre">tt,int</span> <span class="pre">seq,int</span> <span class="pre">set,int</span> <span class="pre">way,addr_t</span>
<span class="pre">ea,addr_t</span> <span class="pre">ra,const</span> <span class="pre">MmuBase</span> <span class="pre">*mb)</span></tt>: Logs a memory-translation operation.  Note
that this is called whenever an address translation hits within a TLB,
regardless of whether the translation is legal according to the various
permission checks.</p>
<dl class="docutils">
<dt><strong>tt</strong></dt>
<dd>Type of translation being performed.  This enumerated type is declared in the
header file <tt class="docutils literal"><span class="pre">BasicTypes.h</span></tt>.</dd>
<dt><strong>seq</strong></dt>
<dd>Sequence number for misaligned accesses</dd>
<dt><strong>set</strong></dt>
<dd>The index of the affected set.  Only valid for writes to the array; not
currently reported for lookups.</dd>
<dt><strong>way</strong></dt>
<dd>The index of the affected way.  Only valid for writes to the array; not
currently reported for lookups.</dd>
<dt><strong>ea</strong></dt>
<dd>The effective address which initiated the translation.  For
<tt class="docutils literal"><span class="pre">tt=WriteTrans</span></tt>, the address is invalid and will always be 0.</dd>
<dt><strong>ra</strong></dt>
<dd>The real address result of the translation.  For <tt class="docutils literal"><span class="pre">tt=WriteTrans</span></tt>, the
address is invalid and will always be 0.</dd>
<dt><strong>mb</strong></dt>
<dd>A pointer to the translation object that was picked.  This class is declared
in <strong>ModelInterface.h</strong>.  This pointer may refer to an entry in a TLB, in
which the object pointed to is relatively long-lived, or may refer to a
temporary object logged by the user, in which case the item will be very
short-lived.  Thus, if it is necessary to cache the object for longer than
the lifetime of the logging function, then the object must be tested by
calling <tt class="docutils literal"><span class="pre">MmuBase::user_entry()</span></tt>.  If the result is true, then the object
must be cloned by calling <tt class="docutils literal"><span class="pre">MmuBase::clone()</span></tt>.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_cache_action(const</span> <span class="pre">char</span> <span class="pre">*name,CacheAction</span> <span class="pre">action,CacheAccess</span>
<span class="pre">access,unsigned</span> <span class="pre">level,int</span> <span class="pre">set,int</span> <span class="pre">way,unsigned</span> <span class="pre">linemask,addr_t</span> <span class="pre">ra)</span></tt>: Logs a
cache access/operation.</p>
<dl class="docutils">
<dt><strong>name</strong></dt>
<dd>The name of the cache.</dd>
<dt><strong>action</strong></dt>
<dd>The action type, e.g. hit, miss, evict, etc.  This enumerated type is
declared in <strong>BasicTypes.h</strong>.</dd>
<dt><strong>access</strong></dt>
<dd>The type of access generating the action, e.g. instruction-fetch, data-read,
etc.  This enumerated type is declared in <strong>BasicTypes.h</strong>.</dd>
<dt><strong>level</strong></dt>
<dd>Level in the hierarchy of caches.</dd>
<dt><strong>set/way</strong>   </dt>
<dd>The set/way of the access.  -1 for set or way values indicates invalid
values that should be ignored.</dd>
<dt><strong>linemask</strong></dt>
<dd>The line-mask value for this cache.</dd>
<dt><strong>ra</strong></dt>
<dd>Real address of the cache access.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_breakpoint(addr_t</span> <span class="pre">ea,unsigned</span> <span class="pre">handle,PtBase</span> <span class="pre">*payload)</span></tt>: This logs
the occurrence of a breakpoint.  This function is only relevant when debug
support is enabled when generating the model.</p>
<p id="log-breakpoint">Breakpoints and watchpoints do not halt the model
by default.  Instead, a function, such as <strong>log_breakpoint</strong> must throw a
<strong>SimInterrupt</strong> object.  The model's simulation loop will catch this and
return the appropriate <strong>ProgramStatus</strong> value.</p>
<dl class="docutils">
<dt><strong>ea</strong></dt>
<dd>Effective address of the access generating the break/watchpoint.</dd>
<dt><strong>handle</strong></dt>
<dd>Integer handle of the break/watchpoint.</dd>
<dt><strong>payload</strong></dt>
<dd>A pointer to a <tt class="docutils literal"><span class="pre">PtBase</span></tt> payload object that was supplied during the call
to <tt class="docutils literal"><span class="pre">setBreakpoint</span></tt> or <tt class="docutils literal"><span class="pre">setTmpBreakpoint</span></tt>.  Note that if this is a
temporary breakpoint, it will be erased after the call to this logging
function.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_watchpoint(addr_t</span> <span class="pre">ea,bool</span> <span class="pre">pre,WatchType</span> <span class="pre">type,unsigned</span> <span class="pre">handle,PtBase</span>
<span class="pre">*payload)</span></tt>: This logs the occurrence of a watchpoint.  This function is only
relevant when debug support is enabled when generating the model.  Refer to
<a class="reference" href="#log-breakpoint">log_breakpoint</a> for information about how to stop a model when a watchpoint
occurs.</p>
<p>Note that integration code normally does not want to throw a <tt class="docutils literal"><span class="pre">SimInterrupt</span></tt>
within the watchpoint logging function because this will interrupt the
instruction before it has completed.  Instead, set a temporary breakpoint at
the program-counter location and store relevant watchpoint information within
the payload.  This allows the instruction to complete before stopping the
simulation.</p>
<dl class="docutils">
<dt><strong>ea</strong></dt>
<dd>Effective address of the access generating the break/watchpoint.</dd>
<dt><strong>pre</strong></dt>
<dd>If true, the call is before the action (load or store) is taken.  If false, the action has
occurred.</dd>
<dt><strong>handle</strong></dt>
<dd>Integer handle of the break/watchpoint.</dd>
<dt><strong>type</strong></dt>
<dd>Type of watchpoint (load, store, etc.).</dd>
<dt><strong>payload</strong></dt>
<dd>A pointer to a <tt class="docutils literal"><span class="pre">PtBase</span></tt> payload object that was supplied during the call
to <tt class="docutils literal"><span class="pre">setBreakpoint</span></tt> or <tt class="docutils literal"><span class="pre">setTmpBreakpoint</span></tt>.  Note that if this is a
temporary breakpoint, it will be erased after the call to this logging
function.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_exception(unsigned</span> <span class="pre">handle,bool</span> <span class="pre">pre,const</span> <span class="pre">char</span> <span class="pre">*name)</span></tt>:  Logs the occurrence
of an exception.</p>
<dl class="docutils">
<dt><strong>handle</strong></dt>
<dd>Integer handle of the exception.  This can be obtained by calling
<strong>IssNode::getExceptionInfo()</strong> on a core.</dd>
<dt><strong>pre</strong></dt>
<dd>If true, the call is before the exception has been taken.  If false, the
exception has occurred and all side-effects have occurred.</dd>
<dt><strong>name</strong></dt>
<dd>The exception's name.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_annotation(MsgType</span> <span class="pre">type,unsigned</span> <span class="pre">level,const</span> <span class="pre">std::string</span>
<span class="pre">&amp;msg,unsigned</span> <span class="pre">ndata,Data</span> <span class="pre">data[])</span></tt>: Logs the occurrence of an annotation
message.  This function will be called even if tracing is off, for warnings
and errors.</p>
<dl class="docutils">
<dt><strong>type</strong></dt>
<dd>The type of message: <em>mInfo</em>, <em>mWarn</em>, or <em>mError</em>.</dd>
<dt><strong>level</strong></dt>
<dd>User-defined annotation level.</dd>
<dt><strong>msg</strong></dt>
<dd>The annotation message.</dd>
<dt><strong>ndata</strong></dt>
<dd>The number of data arguments.</dd>
<dt><strong>data</strong></dt>
<dd><p class="first">An array of data arguments, if any, specified by the user.  The <em>Data</em>
structure is:</p>
<pre class="last literal-block">struct Data {
  std::string _key;
  uint64_t    _value;
}; 
</pre>
</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_branch_taken(addr_t</span> <span class="pre">ea)</span></tt>: Logs the fact that an instruction was
considered to be a taken branch.  This corresponds to an update of the
next-instruction-address register.</p>
<dl class="docutils">
<dt><strong>ea</strong></dt>
<dd>Branch target effective address.</dd>
</dl>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_core_change()</span></tt>: Called when a core change is occurring in the
middle of an instruction's intermediate result list, e.g. one core modifies
another core's resources directly.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">void</span> <span class="pre">log_ctx_change(unsigned</span> <span class="pre">id,const</span> <span class="pre">char</span> <span class="pre">*name,unsigned</span> <span class="pre">context_num,CtxType</span> <span class="pre">update)</span></tt>:
Called whenever a context change occurs.</p>
<dl class="docutils">
<dt><strong>id</strong></dt>
<dd>Numerical identifier for the context.</dd>
<dt><strong>name</strong></dt>
<dd>The context's name.</dd>
<dt><strong>context_num</strong></dt>
<dd>The new active index.</dd>
<dt><strong>update</strong></dt>
<dd><p class="first">This enumerated type describes the update type:</p>
<dl class="last docutils">
<dt><strong>ctxSwitch</strong></dt>
<dd>This is a general context switch event.</dd>
<dt><strong>ctxUpdate</strong></dt>
<dd>This is a temporary change due to an update to a resource in a specific
context.</dd>
<dt><strong>ctxDone</strong></dt>
<dd>This signifies an end to the temporary update.</dd>
</dl>
</dd>
</dl>
</li>
</ul>
<p>The events which are logged may be controlled individually, on a per-core basis.
The control API is defined in <tt class="docutils literal"><span class="pre">IssNode</span></tt> and contains two forms: A
non-recursive set of methods which act only upon the current node and a
recursive form, which act upon all children in the hierarchy.  Events are
specified via an enum called <tt class="docutils literal"><span class="pre">TraceType</span></tt>, defined in <tt class="docutils literal"><span class="pre">ModelInterface.h</span></tt>.</p>
<p>The API is:</p>
<ul class="simple">
<li><strong>uint64_t set_tracing(uint64_t flags)</strong>: Toggle on tracing.  The value is
or'd with the current value and the previous value is returned.  The TraceType
enum describes the different types of tracing events.  The default is to set
all values.</li>
<li><strong>uint64_t clear_tracing(uint64_t flags)</strong>: Toggle off tracing.  The bits set
in the argument turn off the relevant tracing activities.  Default is to turn
off all events.  Returns the prior value.</li>
<li><strong>uint64_t set_tracing_flags(uint64_t flags)</strong>: Set the tracing flags
directly.  Returns the prior value.</li>
<li><strong>bool tracing_on() const</strong>: Returns true if any tracing is activated.</li>
<li><strong>bool tracing_on(uint64_t flags) const</strong>: Returns true if any tracing is
activated.</li>
<li><strong>uint64_t tracing_flags() const</strong>: Returns the current tracing flags.</li>
<li><strong>void set_tracing_r(uint64_t flags)</strong>:  Recursively sets the specified flags
in all child nodes.</li>
<li><strong>void clear_tracing_r(uint64_t flags)</strong>:  Recursively clears the specified
flags in all child nodes.</li>
<li><strong>void set_tracing_flags_r(uint64_t flags)</strong>:  Recursively sets the tracing
flags to the value specified.</li>
<li><strong>bool tracing_on_r() const</strong>:  Returns true if any child nodes have tracing
enabled for any events.</li>
<li><strong>bool tracing_on_r(uint64_t flags) const</strong>: Returns true if any child nodes
have tracing enabled for the events specified by <tt class="docutils literal"><span class="pre">flag</span></tt>.</li>
</ul>
</div>
<div class="section" id="data-dependency-tracking-api">
<h3><a class="toc-backref" href="#id14" name="data-dependency-tracking-api">3.6&nbsp;&nbsp;&nbsp;Data Dependency Tracking API</a></h3>
<p>When enabled, an ADL ISS has the capability to correlate resource reads with
resource updates, both for registers and for memory.  This data can then be
queried by the user application, in order, or example, to track undefined data
through the core.</p>
<p>In order for this feature to be enabled, the model must be built with the
<tt class="docutils literal"><span class="pre">--log-reg-reads</span></tt> and <tt class="docutils literal"><span class="pre">--dep-tracking</span></tt> options enabled.  The model must also
contain <tt class="docutils literal"><span class="pre">dependencies</span></tt> blocks for all relevant instructions.  Currently, this
feature is only enabled for normal, interpreter-based ISSs.</p>
<p>The <strong>IssNode</strong> API for dependency tracking is:</p>
<ul class="simple">
<li><strong>bool has_dependency_tracking() const</strong>:  Returns true if the model supports
dependency tracking.</li>
<li><strong>unsigned get_reg_seq_num() const</strong>:  Returns the current register sequence number.</li>
<li><strong>unsigned get_mem_seq_num() const</strong>:  Returns the current memory sequence number.</li>
<li><strong>const DepItems *get_last_dependencies() const</strong>: Returns the last dependency
list which was selected by a write operation.  If the list is empty, then no
dependency information was recorded.</li>
</ul>
<p>The <strong>DepItems</strong> data structure is:</p>
<pre class="literal-block">struct DepItem {
  enum Type { dpReg, dpMem };

  DepItem(Type t,unsigned id,unsigned snum) : _type(t), _id(id), _snum(snum) {};

  Type     _type;  // Type for this item:  register or memory.
  unsigned _id;    // Id for item.
  unsigned _snum;  // Sequence number for this access.  Only valid for sources.
};

// Items in the vector are the sources.  Target information is stored in _trg.
struct DepItems : public std::list&lt;DepItem&gt; {};
</pre>
<p>The basic idea is that, for each register or memory logging event
(<strong>log_reg_read</strong>, <strong>log_regfile_read</strong>, <strong>log_reg_read_mask</strong>,
<strong>log_regfile_read_mask</strong>, <strong>log_core_mem_read</strong>), the user application should
query for the current register or memory sequence number by calling
<strong>IssNode::get_reg_seq_num()</strong> or <strong>IssNode::get_mem_seq_num()</strong>.  Then, on a
write logging event (<strong>log_reg_write</strong>, <strong>log_regfile_write</strong>,
<strong>log_reg_read_mask</strong>, <strong>log_regfile_read_mask</strong>, <strong>log_core_mem_write</strong>), the
user application should call <strong>IssNode::get_last_dependencies()</strong> to retrieve
the dependency list for that write operation.</p>
<p>Each dependency item is a <strong>DepItem</strong> and contains a type specifier (register or
memory), an id (useful for debugging, but not strictly necessary), and a
sequence number, which is used to correlate with a previous read operation.</p>
</div>
<div class="section" id="disassembler-api">
<h3><a class="toc-backref" href="#id15" name="disassembler-api">3.7&nbsp;&nbsp;&nbsp;Disassembler API</a></h3>
<p>A model may be generated with the <tt class="docutils literal"><span class="pre">--disassembler</span></tt> option, which will create a
standalone disassembler within the model.  This allows a user to disassemble
arbitrary memory.</p>
<p>The disassembler function is a method of <tt class="docutils literal"><span class="pre">IssNode</span></tt>:</p>
<pre class="literal-block">// o:      Disassembly output stream
// addr:   Source address.  This is an ea if tran=true, else an ra.
// tran:   Whether to translate.
// tindex: Index of instruction table to use, or -1 to use the current.
virtual unsigned disassemble(std::ostream &amp;o,addr_t addr,bool tran,int tindex) const;
</pre>
<p>Memory at <tt class="docutils literal"><span class="pre">addr</span></tt>, where <tt class="docutils literal"><span class="pre">addr</span></tt> is either a real or effective (virtual)
address, as determined by the <tt class="docutils literal"><span class="pre">tran</span></tt> parameter, is disassembled, and the
textual output is sent to the output stream <tt class="docutils literal"><span class="pre">o</span></tt>.  By default (a value of -1
for <tt class="docutils literal"><span class="pre">tindex</span></tt>) the model's current instruction table is used.  This may be
overridden by supplying a different instruction table index.  These values may
be obtained by retrieving the attribute information via a call to
<tt class="docutils literal"><span class="pre">adl::getAttrData()</span></tt>.</p>
</div>
<div class="section" id="dynamic-parameter-api">
<h3><a class="toc-backref" href="#id16" name="dynamic-parameter-api">3.8&nbsp;&nbsp;&nbsp;Dynamic Parameter API</a></h3>
<p>A model may be generated in such a way that various resources may be modified at
startup-time.  For example, caches can be configured so that their size may be
set dynamically.  An API is provided for modifying these parameters.</p>
<p>This API consists of methods in <tt class="docutils literal"><span class="pre">IssNode</span></tt>.  The methods always exist, but
whether any parameters may be set is dependent upon how the model was built</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">set_dyn_parm(const</span> <span class="pre">std::string</span> <span class="pre">&amp;parm,unsigned</span> <span class="pre">value)</span></tt>: Sets a
parameter value.  Throws a <strong>runtime_error</strong> if the parameter or value are
invalid.</li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">unsigned</span> <span class="pre">get_dyn_parm(const</span> <span class="pre">std::string</span> <span class="pre">&amp;parm)</span> <span class="pre">const</span></tt>:  Retrieves
the value of a dynamic parameter.  Throws a <strong>runtime_error</strong> if the parameter
is invalid.</li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">list_dyn_parm(StrPairs</span> <span class="pre">&amp;parms)</span> <span class="pre">const</span></tt>: Returns a sequence of
pairs describing all dynamic parameters in the model.  The first element of
each pair is the parameter name; the second element is a description of the
parameter.</li>
</ul>
</div>
<div class="section" id="event-bus-api">
<h3><a class="toc-backref" href="#id17" name="event-bus-api">3.9&nbsp;&nbsp;&nbsp;Event Bus API</a></h3>
<p>By default, ADL models send and receive event bus data to all other registered
cores.  Each core that is instantiated is automatically registered and will
receive data on a <strong>send</strong> operation.  For platform integration, however, it may
be necessary for the external model to handle the distribution of this data.  In
order to create code for the following API, the model must be generated with the
<strong>--no-event-bus-send</strong> option.</p>
<p>Event bus data may be sent by the external environment to a core by calling the
following method:</p>
<pre class="literal-block">&lt;core-class&gt;::event_bus_send(const &lt;event-bus-type&gt; &amp;t);
</pre>
<p>where <strong>&lt;core-class&gt;</strong> is the name of the core's class and <strong>&lt;event-bus-type&gt;</strong>
has the form <strong>&lt;event-bus-name&gt;_t</strong>.  This will invoke the core's handler for
this event bus.</p>
<p>In order to access the event bus data types, you must include the generated ADL
model as a header.  If you are also compiling the model separately, then define
<tt class="docutils literal"><span class="pre">ADL_HEADER</span></tt> before including the file in order to avoid duplicate
definitions.  For example, given a model with a core class name of <strong>Core</strong> and
an event bus named <strong>foobar</strong> which has a field named <strong>addr</strong>:</p>
<blockquote>
<p>#define ADL_HEADER
#include "model.cc"</p>
<p>...
Core::foobar_t x;
x.addr = ... ;
core-&gt;event_bus_send(x);
...</p>
</blockquote>
<p>With the <strong>--no-event-bus-send</strong> option set, data will be sent to a registered
functor object and not automatically to other cores.  The external code must
also register an object derived from <strong>&lt;core-class&gt;::EventBusReceiver</strong>.  This
object has <strong>operator()</strong> overloaded for each type of event bus, e.g.:</p>
<pre class="literal-block">struct EventBusReceiver {
  void operator()(&lt;core-class&gt; &amp;core,const foobar_t &amp;data) {};
};
</pre>
<p>On a send operation performed by the core, the appropriate method in
<strong>EventBusReceiver</strong> will be invoked.  To register this object, call
<strong>&lt;core-class&gt;::setEventBusReceiver</strong>.</p>
</div>
<div class="section" id="external-interrupt-generation">
<h3><a class="toc-backref" href="#id18" name="external-interrupt-generation">3.10&nbsp;&nbsp;&nbsp;External Interrupt Generation</a></h3>
<p>Exceptions may be generated by an external application.  The function to do this
is <tt class="docutils literal"><span class="pre">IssNode::genExceptions(unsigned</span> <span class="pre">flag)</span></tt>.  The argument specifies what
interrupts should be taken as a set of bit flags.  These flags correspond to the
<tt class="docutils literal"><span class="pre">_flag</span></tt> values listed in the introspection information which may be obtained by
calling <tt class="docutils literal"><span class="pre">getExceptionInfo()</span></tt>.</p>
<p>When an exception is generated, the side-effects of the interrupt are
immediately performed if the exception is enabled, as specified by its enable
predicate, if present.  The next time the model is cycled, these changes will
be taken into account.  However, if called during the execution of an
instruction, such as within a call to a <tt class="docutils literal"><span class="pre">MemHandler</span></tt> method, this does not
abort the execution of an instruction.  To do this, call
<tt class="docutils literal"><span class="pre">IssNode::genExceptionImm(unsigned</span> <span class="pre">id)</span></tt>.  This generates the specified
exception, aborting the instruction currently being executed.  This should only
be called if in the middle of an instruction execution.</p>
<p>If an exception is disabled and is specified as being level sensitive, then the
side-effects of the exception will not immediately occur.  Instead, the
exception will remain pending until the exception is enabled or it is canceled.
To cancel an exception, call <tt class="docutils literal"><span class="pre">IssNode::cancelException(unsigned</span> <span class="pre">flag)</span></tt>.  As
with <tt class="docutils literal"><span class="pre">genException</span></tt>, the argument is considered a set of bit flags. in this
case identifying the exceptions to be canceled.</p>
</div>
<div class="section" id="external-model-communication-api">
<h3><a class="toc-backref" href="#id19" name="external-model-communication-api">3.11&nbsp;&nbsp;&nbsp;External Model Communication API</a></h3>
<p>An <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt> flag is provided as a means of communication between the ISS
and an external application, such as a performance model.  Within the ISS,
action code may set the flag by calling <tt class="docutils literal"><span class="pre">setExtInstrFlag(unsigned)</span></tt> and
retrieve it by calling <tt class="docutils literal"><span class="pre">getExtInstrFlag()</span></tt>.</p>
<p>When a transactional or hybrid ISS is generated, these functions are declared
virtual so that a class derived from the ISS may implement them.  This can be
useful, for example, to allow the ISS to communicate MMU translation status or
other types of state to an instruction object within a pipeline model.</p>
</div>
</div>
<div class="section" id="internal-and-external-memories">
<h2><a class="toc-backref" href="#id20" name="internal-and-external-memories">4&nbsp;&nbsp;&nbsp;Internal and External Memories</a></h2>
<div class="section" id="external-memory-interface">
<h3><a class="toc-backref" href="#id21" name="external-memory-interface">4.1&nbsp;&nbsp;&nbsp;External Memory Interface</a></h3>
<p>By default, an ADL ISS contains a memory model with support for 64-bit
addresses.  A model may also be generated such that any or all memories are
defined externally.  This may be accomplished by either using the
<tt class="docutils literal"><span class="pre">--extern-mem</span></tt> option with <tt class="docutils literal"><span class="pre">adl2iss</span></tt> or by setting the <tt class="docutils literal"><span class="pre">extern_mem</span></tt> flag
to true for a memory within an ADL ISS configuration file.  For more information
about configuration files, please refer to the <a class="reference" href="adl-language-reference.html">ADL ISS manual</a>.</p>
<p>If a memory is defined externally then the external application must derive a
class from the <tt class="docutils literal"><span class="pre">MemHandler</span></tt> interface and supply it to each core object by
calling the <tt class="docutils literal"><span class="pre">setMemHandler</span></tt> method.  This interface class is declared in
<tt class="docutils literal"><span class="pre">MemHandler.h</span></tt> and consists of the following methods:</p>
<ul class="simple">
<li><em>uint64 read64(CacheAccess ca,addr_t ra)</em>: Read a 64-bit value from memory.</li>
<li><em>uint32 read32(CacheAccess ca,addr_t ra)</em>: Read a 32-bit value from memory.</li>
<li><em>uint16 read16(CacheAccess ca,addr_t ra)</em>: Read a 16-bit value from memory.
Note that this address may be misaligned within a word.</li>
<li><em>uint8 read8(CacheAccess ca,addr_t ra)</em>: Read an 8-bit value from memory.</li>
<li><em>void write64(addr_t ra, uint64 v, uint64 m)</em>: Write a 64-bit
value to memory.  The mask <tt class="docutils literal"><span class="pre">m</span></tt> specifies which bits of the 64-bit value
<tt class="docutils literal"><span class="pre">v</span></tt> should be written.</li>
<li><em>void write32(addr_t ra, uint32 v, uint32 m)</em>: Write a 32-bit
value to memory.  The mask <tt class="docutils literal"><span class="pre">m</span></tt> specifies which bits of the 32-bit value
<tt class="docutils literal"><span class="pre">v</span></tt> should be written.</li>
<li><em>void write16(addr_t ra, uint16 v, uint16 m)</em>: Write a 16-bit value to
memory.  The mask <tt class="docutils literal"><span class="pre">m</span></tt> specifies which bits of the 16-bit value <tt class="docutils literal"><span class="pre">v</span></tt> should
be written.  Note that this address may be misaligned within a word.</li>
<li><em>void write8 (addr_t ra, uint8 v)</em>: Write an 8-bit value to
memory.</li>
<li><em>void readpage(CacheAccess ca,byte_t *t,size_t n,addr_t addr,addr_t
crit_addr)</em>: Read a block from memory into the target <tt class="docutils literal"><span class="pre">t</span></tt> of size <tt class="docutils literal"><span class="pre">n</span></tt>
bytes, starting at address <tt class="docutils literal"><span class="pre">addr</span></tt>, where <tt class="docutils literal"><span class="pre">crit_addr</span></tt> is the critical
address which generated the request.</li>
<li><em>void writepage(byte_t *s,size_t n,addr_t addr,addr_t crit_addr)</em>: Write a
block from source <tt class="docutils literal"><span class="pre">s</span></tt> into external memory of size <tt class="docutils literal"><span class="pre">n</span></tt> bytes, at address
<tt class="docutils literal"><span class="pre">addr</span></tt>, where <tt class="docutils literal"><span class="pre">crit_addr</span></tt> is the critical address which generated the
request.</li>
<li><em>void reset()</em>: Reset memory.</li>
<li><em>void set_latency(unsigned l)</em>: Set a latency value, if using this interface
in conjunction with a performance model.  The performance model will use the
latency value that is set by this call when updating its internal time.</li>
</ul>
<p>The read routines take an extra parameter of <tt class="docutils literal"><span class="pre">CacheAccess</span></tt> to specify whether
the access is for instruction or for data.  Currently, all instruction accesses
are done using 32-bit accesses, so only calls of <tt class="docutils literal"><span class="pre">read32</span></tt> will ever indicate
an instruction access.  If the access is for an instruction fetch then a value
of <tt class="docutils literal"><span class="pre">CacheIFetch</span></tt> will be supplied.  For data, the value will be <tt class="docutils literal"><span class="pre">CacheRead</span></tt>.</p>
</div>
<div class="section" id="direct-memory-interface-api">
<h3><a class="toc-backref" href="#id22" name="direct-memory-interface-api">4.2&nbsp;&nbsp;&nbsp;Direct-Memory-Interface API</a></h3>
<p>ADL provides a direct-memory-interface (DMI) cache for improving performance.
This is an object which may cache memory accesses so that it is not necessary
for the integration code to generate a memory transaction for simple memory
accesses.</p>
<p>This feature is implemented when a model is generated with the <tt class="docutils literal"><span class="pre">--extern-dmi</span></tt>
command-line option or <tt class="docutils literal"><span class="pre">extern_dmi=&lt;bool&gt;</span></tt> configuration-file parameter.  The
entry-size of the cache may be set via <tt class="docutils literal"><span class="pre">--extern-dmi-entry-size=&lt;int&gt;</span></tt>
(command-line) or <tt class="docutils literal"><span class="pre">extern_dmi_entry_size=&lt;int&gt;</span></tt> (configuration file).  It is
expressed in terms of log(2) bytes, e.g. a value of 7 implies an entry size of
128 bytes.  The total number of entries may be set via <tt class="docutils literal"><span class="pre">--extern-dmi-size=&lt;int&gt;</span></tt>
(command-line) or <tt class="docutils literal"><span class="pre">extern_dmi_size=&lt;int&gt;</span></tt> (configuration file).  Internally, a
separate cache is used for data reads, data writes, and instruction data.</p>
<p>The size of the DMI cache may be overridden at build-time by using a
preprocessor define.  Thus, if a model is distributed as source, the final user
of the model may modify the entry-size and number of entries without rebuilding
the model.  Simply redefine <strong>DMI_HANDLER_TYPE</strong>.  This must be done
consistently if the model is used as both a header and as a source file.  The
definition has the form <tt class="docutils literal"><span class="pre">DmiMemHandler&lt;DmiMemType,DmiEntrySize,DmiSize&gt;</span></tt>,
where the first template parameter (DmiMemType) may be either <strong>DmiInternalMem</strong>
or <strong>DmiExternalMem</strong>, based upon whether an internal or external memory is
being used, and <tt class="docutils literal"><span class="pre">DmiEntrySize</span></tt> and <tt class="docutils literal"><span class="pre">DmiSize</span></tt> represent the entry-size and
number of entires in the DMI cache, and exist as enums defined within the
model's class.</p>
<p>The DMI cache may be used with internal or external memory, but only really
makes sense with an external memory interface, such as for a platform
integration.  The internal-memory support is primarily meant for testing; it
allows the user to build a standalone executable in order to check that the DMI
cache is functioning properly.</p>
<p>On a memory access (one which misses in a hardware cache, if there is one) the
appropriate DMI cache is checked.  If the data is not contained in the DMI
cache, the appropriate miss-handler routine is invoked.  For an external memory,
this means that the appropriate method of <tt class="docutils literal"><span class="pre">MemHandler</span></tt> is called.  During this
call, the DMI cache may be updated by calling
<tt class="docutils literal"><span class="pre">IssNode::update_dmi_cache_entry(CacheAccess</span> <span class="pre">ca,addr_t</span> <span class="pre">addr,byte_t</span> <span class="pre">*mem)</span></tt>.
The <tt class="docutils literal"><span class="pre">CacheAccess</span></tt> parameter should be the same as what was supplied to the
<tt class="docutils literal"><span class="pre">MemHandler</span></tt> method, so that the correct DMI cache is updated.  The <tt class="docutils literal"><span class="pre">addr</span></tt>
parameter and <tt class="docutils literal"><span class="pre">mem</span></tt> pointer should correspond, i.e. the pointer should point
to the exact host memory location containing the target's data at location
<tt class="docutils literal"><span class="pre">addr</span></tt>.  The memory data should be in host endian format and the memory block
should be at least as large as the DMI entry size.</p>
<p>Note that, for a model which is built with an internal DMI software cache which
maps effective (virtual) addresses directly to memory, and if that cache
interfaces directly with memory, i.e. there is no hardware data cache, the
update function will also update this cache.  Therefore, any calls to the update
function should only be done during a <tt class="docutils literal"><span class="pre">MemHandler</span></tt> invocation so that the core
will be able to associate an effective address with the DMI update.</p>
<p>The basic idea is that the cache is populated as misses occur.  The user's
<tt class="docutils literal"><span class="pre">MemHandler</span></tt> class should only populate the cache with "simple" memory,
i.e. memory which does not map to peripherals or other memory-mapped registers.
If the system performs access checks on memory transactions, then those access
checks will be performed by the initial miss.  After that, the access is known
to be safe and thus the entry may be placed in the cache.  However, if the
system's configuration changes such that access permissions are modified, then
the DMI cache must be updated.  It may either be completely reset or specific
entries may be invalidated via <tt class="docutils literal"><span class="pre">IssNode::invalidate_dmi_cache_entry(CacheAccess</span>
<span class="pre">ca,addr_t</span> <span class="pre">addr)</span></tt> or <tt class="docutils literal"><span class="pre">IssNode::invalidate_dmi_cache()</span></tt>.  For a model which
contains an internal DMI cache which interfaces directly with memory (i.e. there
is no hardware data cache), both invalidate functions will reset the internal
cache, since the effective address for the invalidate is not known.</p>
</div>
</div>
<div class="section" id="system-call-support">
<h2><a class="toc-backref" href="#id23" name="system-call-support">5&nbsp;&nbsp;&nbsp;System-Call Support</a></h2>
<p>ADL models may contains a mechanism for implementing system-calls.  This is done
via a simple memory-mapped interface: If a write occurs to the designated
<em>porthole</em> address, then the function <tt class="docutils literal"><span class="pre">handle_porthole()</span></tt> is called.  It is up
to the external application to query memory in order to read the arguments of
the system call.</p>
<p>By default, system-call support is enabled but turned off.  It may be activated
by setting the global variable <tt class="docutils literal"><span class="pre">Porthole_enabled</span></tt> to true and setting the
global variable <tt class="docutils literal"><span class="pre">Porthole_address</span></tt> to the desired address value.</p>
</div>
<div class="section" id="file-readers">
<h2><a class="toc-backref" href="#id24" name="file-readers">6&nbsp;&nbsp;&nbsp;File Readers</a></h2>
<p>The various file readers (DAT, UVP, and ELF) supported by ADL are normally not
linked in with a bare-bones ISS.  The <strong>adl-config</strong> option <strong>--readers</strong> may be
used to specify these extra libraries.  This option is only relevant with the
<strong>--basic</strong> option, as otherwise the libraries are included by default.</p>
<p>For example, to use ADL's ELF reader within an external program:</p>
<pre class="literal-block">#include "iss/ElfReader.h"

...

IssNode *root = IssNamespace::createTopLevelNode(id);    

...

ElfReaderFactory erf;
Reader *er = erf.create(filename,*root);
er-&gt;useFileEntryPoint(true);
if (!er-&gt;readFile()) {
  throw runtime_error("Could not read ELF file '" + filename + "'.");
}
</pre>
<p>To obtain the C flags for the compilation process:</p>
<pre class="literal-block">adl-config --cflags --basic
</pre>
<p>For linking:</p>
<pre class="literal-block">adl-config --libs --basic --readers
</pre>
</div>
<div class="section" id="a-simple-example">
<h2><a class="toc-backref" href="#id25" name="a-simple-example">7&nbsp;&nbsp;&nbsp;A Simple Example</a></h2>
<p>The following is an example which demonstrates the use of the ADL ISS API.  The
program instantiates a model, initializes the external memory and the model,
runs the simulation, then displays various results.</p>
<pre class="literal-block">//
// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.
//
// You may distribute under the terms of the Artistic License, as specified in
// the COPYING file.
//

//
// This is a simple driver program that can link against a bare-bones ISS
// that does not have the standalone infrastructure.
//
// You may define IssNamespace to specify an alternate namespace to be included.
//

#include &lt;assert.h&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdarg.h&gt;
#include &lt;sstream&gt;
#include &lt;stdexcept&gt;
#include &lt;memory&gt;

//#define VLE

#ifdef USE_LOGGING_MGR
# include "rnumber/RNumber.h"
#else
# define __NO_RNUMBER__
#endif

#include "helpers/Macros.h"

#ifndef IssNamespace
# define IssNamespace DEFAULT_ISS_NAMESPACE
#endif

#define ISS_NAMESPACE IssNamespace
#include "iss/ModelInterface.h"
#include "iss/Memory.h"
#include "iss/MemHandler.h"

#ifdef UADL
# include "uadl/UadlArchIf.h"
#endif

using namespace std;
using namespace adl;

//
// For this example, the memory is implemented as a 1 Mb array.  The byte_*
// routines are helper functions declared in Memory.h.
//

// External memory.
enum { MemSize = 0x100000, MemMask = (MemSize-1) };

bool MemLogging = true;

byte_t external_mem[MemSize];

uint32_t extern_mem_read32(addr_t ra)
{
  return byte_read32(external_mem,(ra &amp; MemMask));
}

void extern_mem_write32(addr_t ra, uint32_t v, unsigned nb = 4)
{
  byte_write32(external_mem,(ra &amp; MemMask),v,nb);
}

struct MyMem : public MemHandler {

  MyMem(IssNode *node,unsigned excpt,addr_t exception_addr = 0) : _node(node), _excpt(excpt), _exception_addr(exception_addr) {};

  uint64_t read64(CacheAccess ca,addr_t ra)
  {
    log_access(ca,ra &amp; ~DWMask,64);
    return byte_read64(external_mem,(ra &amp; MemMask));
  }

  uint32_t read32(CacheAccess ca,addr_t ra)
  {
    log_access(ca,ra &amp; ~WordMask,32);
    if (_excpt &amp;&amp; ra == _exception_addr) {
      _node-&gt;genExceptionImm(_excpt);
    }
    return byte_read32(external_mem,(ra &amp; MemMask));
  }

  uint16_t read16(CacheAccess ca,addr_t ra)
  {
    log_access(ca,ra &amp; ~HWMask,16);
    return byte_read16(external_mem,(ra &amp; MemMask));
  }

  uint8_t  read8(CacheAccess ca,addr_t ra)
  {
    log_access(ca,ra,8);
    return byte_read8(external_mem,(ra &amp; MemMask));
  }

  void write64(addr_t ra, uint64_t v, unsigned nb)
  {
    log_access(CacheWrite,ra &amp; ~DWMask,64);
    byte_write64(external_mem,(ra &amp; MemMask),v,nb);
  }

  void write32(addr_t ra, uint32_t v, unsigned nb)
  {
    log_access(CacheWrite,ra &amp; ~WordMask,32);
    byte_write32(external_mem,(ra &amp; MemMask),v,nb);
  }

  void write16(addr_t ra, uint16_t v, unsigned nb)
  {
    log_access(CacheWrite,ra &amp; ~HWMask,16);
    byte_write16(external_mem,(ra &amp; MemMask),v,nb);
  }

  void write8 (addr_t ra, uint8_t  v)
  {
    log_access(CacheWrite,ra,8);
    byte_write8(external_mem,(ra &amp; MemMask),v);
  }

  void readpage(CacheAccess ca,byte_t *t,size_t n,addr_t addr,addr_t crit_addr)
  {
    log_access(ca,addr,crit_addr,n);
    byte_pagecopy(t,0,external_mem,(addr &amp; MemMask),n);
  }

  void writepage(byte_t *s,size_t n,addr_t addr,addr_t crit_addr)
  {
    log_access(CacheWrite,addr,crit_addr,n);
    byte_pagecopy(external_mem,(addr &amp; MemMask),s,0,n);
  }

  void reset()
  {
    memset(external_mem,0,MemSize);
  }

  void log_access(CacheAccess ca,addr_t ra,int size)
  {
    if (MemLogging) {
      switch (ca) {
      case CacheIFetch:
        cout &lt;&lt; "# Instruction read:  0x" &lt;&lt; hex &lt;&lt; ra &lt;&lt; "\n";
        break;
      case CacheWrite:
        cout &lt;&lt; "# Data write (" &lt;&lt; dec &lt;&lt; size &lt;&lt; " bits):  0x" &lt;&lt; hex &lt;&lt; ra &lt;&lt; "\n";
        break;
      case CacheRead:
        cout &lt;&lt; "# Data read (" &lt;&lt; dec &lt;&lt; size &lt;&lt; " bits):  0x" &lt;&lt; hex &lt;&lt; ra &lt;&lt; "\n";
        break;
      case CacheLogRead:
        cout &lt;&lt; "# Data log read (" &lt;&lt; dec &lt;&lt; size &lt;&lt; " bits):  0x" &lt;&lt; hex &lt;&lt; ra &lt;&lt; "\n";
        break;
      case CacheILogRead:
        cout &lt;&lt; "# Instruction log read:  0x" &lt;&lt; hex &lt;&lt; ra &lt;&lt; "\n";
        break;
      default:
        ;
      }
    }
  }

  void log_access(CacheAccess ca,addr_t ra,addr_t crit_ra,int size)
  {
    if (MemLogging) {
      switch (ca) {
      case CacheIFetch:
        cout &lt;&lt; "# Instruction read:  0x" &lt;&lt; hex &lt;&lt; ra &lt;&lt; ", critical:  0x" &lt;&lt; crit_ra &lt;&lt; "\n";
        break;
      case CacheWrite:
        cout &lt;&lt; "# Data write (" &lt;&lt; dec &lt;&lt; size &lt;&lt; " bits):  0x" &lt;&lt; hex &lt;&lt; ra &lt;&lt; ", critical:  0x" &lt;&lt; crit_ra &lt;&lt; "\n";
        break;
      case CacheRead:
        cout &lt;&lt; "# Data read (" &lt;&lt; dec &lt;&lt; size &lt;&lt; " bits):  0x" &lt;&lt; hex &lt;&lt; ra &lt;&lt; ", critical:  0x" &lt;&lt; crit_ra &lt;&lt; "\n";
        break;
      case CacheLogRead:
        cout &lt;&lt; "# Data log read (" &lt;&lt; dec &lt;&lt; size &lt;&lt; " bits):  0x" &lt;&lt; hex &lt;&lt; ra &lt;&lt; ", critical:  0x" &lt;&lt; crit_ra &lt;&lt; "\n";
        break;
      case CacheILogRead:
        cout &lt;&lt; "# Instruction log read:  0x" &lt;&lt; hex &lt;&lt; ra &lt;&lt; ", critical:  0x" &lt;&lt; crit_ra &lt;&lt; "\n";
        break;
      default:
        ;
      }
    }
  }

private:
  IssNode *_node;
  unsigned _excpt;
  addr_t   _exception_addr;

};

#ifdef USE_LOGGING_MGR

#include "iss/LoggingMgr.h"

struct MyLogger : public LogParentIface, public LoggingIface {

  addr_t _instr_ea;

  LoggingIface *register_core(IssCore &amp;core)
  {
    return this;
  }

  void logInstrPrefetch(addr_t ea)
  {
    cout &lt;&lt; "\nI ea=0x" &lt;&lt; hex &lt;&lt; ea &lt;&lt; "\n";
  }

  void logInstrRead(unsigned id,const char *name,addr_t ea,
                    addr_t ra,uint32_t data)
  {
    _instr_ea = ea;
  }

  void logInstr(const uint32_t* opc,int num_half_bytes,const char *name,Disassembler dis)
  {
    cout &lt;&lt; "INSTR op=0x" &lt;&lt; hex &lt;&lt; setfill('0') &lt;&lt; setw(num_half_bytes) &lt;&lt; (*opc &gt;&gt; ((8-num_half_bytes)*4)) &lt;&lt; " asm=\"";
    dis(cout,_instr_ea,opc);
    cout &lt;&lt; "\"\n";
  }  

};

#else

//
// These are the logging functions.  For this example, they simply display their
// results in a format similar to the DAT trace format used by the standalone ADL
// ISS executables.
//

static addr_t instr_ea, instr_ra;

namespace adl {

struct MyLogger : public LogBase {

  void log_instr_prefetch(addr_t ea)
  {
    cout &lt;&lt; "\nI ea=0x" &lt;&lt; hex &lt;&lt; ea &lt;&lt; "\n";
  }

  void log_instr_read(unsigned id,const char *name,addr_t ea,
                      addr_t ra,uint32_t data)
  {
    instr_ea = ea;
    instr_ra = ra;
    cout &lt;&lt; "M n=Mem t=ifetch ea=0x" &lt;&lt; hex &lt;&lt; ea &lt;&lt; " ra=0x" 
         &lt;&lt; ra &lt;&lt; " d=0x" &lt;&lt; data &lt;&lt; "\n";
  }

  void log_instr(const uint32_t* opc,int num_half_bytes,const char *name,Disassembler dis,uint32_t flags)
  {
    cout &lt;&lt; "INSTR op=0x" &lt;&lt; hex &lt;&lt; setfill('0') &lt;&lt; setw(num_half_bytes) &lt;&lt; (*opc &gt;&gt; ((8-num_half_bytes)*4)) &lt;&lt; " asm=\"";
    dis(cout,instr_ea,opc);
    cout &lt;&lt; "\"\n";
  }

  void log_reg_write(unsigned id,const char *name,uint64_t value)
  {
    cout &lt;&lt; "R n=" &lt;&lt; name &lt;&lt; " d=0x" &lt;&lt; hex &lt;&lt; value &lt;&lt; "\n";
  }

  void log_regfile_write(unsigned id,const char *name,uint32_t index,
                         uint64_t value)
  {
    cout &lt;&lt; "R n=" &lt;&lt; name &lt;&lt; " i=" &lt;&lt; dec &lt;&lt; index 
         &lt;&lt; " d=0x" &lt;&lt; hex &lt;&lt; value &lt;&lt; "\n";
  }

  void log_core_mem_write(unsigned id,const char *name,
                          addr_t ea,int nb)
  {
    cout &lt;&lt; "D n=Mem t=write ea=0x" &lt;&lt; hex &lt;&lt; ea 
         &lt;&lt; " nb=" &lt;&lt; dec &lt;&lt; nb &lt;&lt; "\n";
  }

  void log_core_mem_read(unsigned id,const char *name,
                         addr_t ea,int nb)
  {
    cout &lt;&lt; "D n=Mem t=read ea=0x" &lt;&lt; hex &lt;&lt; ea 
         &lt;&lt; " nb=" &lt;&lt; dec &lt;&lt; nb &lt;&lt; "\n";
  }

  void log_mem_write(unsigned id,const char *name,bool pre,int seq,addr_t ea,
                     addr_t ra,uint32_t value)
  {
    if (!pre) {
      cout &lt;&lt; "M n=Mem t=write ea=0x" &lt;&lt; hex &lt;&lt; ea 
           &lt;&lt; " ra=0x" &lt;&lt; ra &lt;&lt; " d=0x" &lt;&lt; value &lt;&lt; "\n";
    }
  }

  void log_mem_read(unsigned id,const char *name,bool pre,int seq,addr_t ea,
                    addr_t ra,uint32_t value)
  {
    if (!pre) {
      cout &lt;&lt; "M n=Mem t=read ea=0x" &lt;&lt; hex &lt;&lt; ea 
           &lt;&lt; " ra=0x" &lt;&lt; ra &lt;&lt; " d=0x" &lt;&lt; value &lt;&lt; "\n";
    }
  }

  void log_annotation(MsgType type,unsigned level,const std::string &amp;msg)
  {
    cout &lt;&lt; "A l=" &lt;&lt; level &lt;&lt; " m=\"" &lt;&lt; msg &lt;&lt; "\"\n";
  }

  void log_cache_action(const char *name,CacheAction action,CacheAccess access,unsigned level,
                        int set,int way,unsigned linemask,addr_t ra)
  {
    cout &lt;&lt; "C n=" &lt;&lt; name;
    switch (action) {
    case CacheLoad:
      cout &lt;&lt; " a=load";
      break;
    case CacheHit:
      cout &lt;&lt; " a=hit";
      break;
    case CacheMiss:
      cout &lt;&lt; " a=miss";
      break;
    case CacheEvict:
      cout &lt;&lt; " a=evict";
      break;
    case CacheNone:
      break;
    }

    switch (access) {
    case CacheNoAccess:
      cout &lt;&lt; " t=none";
      break;
    case CacheIFetch:
      cout &lt;&lt; " t=ifetch";
      break;
    case CacheRead:
      cout &lt;&lt; " t=read";
      break;
    case CacheStore:
    case CacheWrite:
      cout &lt;&lt; " t=write";
      break;
    case CacheFlush:
      cout &lt;&lt; " t=flush";
      break;
    case CacheTouch:
      cout &lt;&lt; " t=touch";
      break;
    case CacheAlloc:
      cout &lt;&lt; " t=alloc";
      break;
    case CacheInvalidate:
      cout &lt;&lt; " t=invalidate";
      break;
    case CacheLock:
      cout &lt;&lt; " t=lock";
      break;
    case CacheUnlock:
      cout &lt;&lt; " t=unlock";
      break;
    default:
      break;
    }

    cout &lt;&lt; dec;

    if (set &gt;= 0) {
      cout &lt;&lt; " set=" &lt;&lt; set;
    }
    if (way &gt;= 0) { 
      cout &lt;&lt; " way=" &lt;&lt; way;
    }

    cout &lt;&lt; " lm=0x" &lt;&lt; hex &lt;&lt; linemask &lt;&lt; " ra=0x" &lt;&lt; (ra &amp; ~((addr_t)linemask)) &lt;&lt; dec &lt;&lt; "\n";    
  }

};

}

#endif

MyLogger mylogger;

//
// These are some helper functions for displaying model state.
//

void display_memory(int cnt, ... )
{
  va_list ap;
  va_start(ap,cnt);
  for (int i = 0; i != cnt; ++i) {
    unsigned addr = va_arg(ap,unsigned);
    cout &lt;&lt; "MD n=Mem ra=0x" &lt;&lt; hex &lt;&lt; addr &lt;&lt; " d=0x" &lt;&lt; hex 
         &lt;&lt; extern_mem_read32(addr) &lt;&lt; "\n";
  }
  va_end(ap);
}

struct Reporter : ReportBase
{
    virtual  void report_reg (const IssNode *,unsigned id,const char *name,REGTYPE value,bool shared) {
      cout &lt;&lt; "RD n=" &lt;&lt; name &lt;&lt; " d=0x" &lt;&lt; hex &lt;&lt; setfill('0') &lt;&lt; setw(8) &lt;&lt; value &lt;&lt; "\n";
    }

    virtual  void report_regfile (const IssNode *,unsigned id,const char *name,int index,REGTYPE value,bool shared) {
      cout &lt;&lt; "RD n=" &lt;&lt; name &lt;&lt; " i=" &lt;&lt; dec &lt;&lt; index &lt;&lt; " d=0x" &lt;&lt; hex &lt;&lt; setfill('0') &lt;&lt; setw(8) &lt;&lt; value &lt;&lt; "\n";
    }

    virtual void report_cache(const IssNode *,const char *name,CacheType type,unsigned level,addr_t addr,unsigned set,unsigned way,
                              bool valid,const FieldData &amp;fd,bool shared,const byte_t *data,unsigned n) {
      if (valid) {
        cout &lt;&lt; "CD n=" &lt;&lt; name &lt;&lt; " set=" &lt;&lt; dec &lt;&lt; set &lt;&lt; " way=" &lt;&lt; way &lt;&lt; hex 
             &lt;&lt; " ra=0x" &lt;&lt; setfill('0') &lt;&lt; setw(sizeof(addr_t)*2) &lt;&lt; setfill('0') &lt;&lt; addr &lt;&lt; dec;
        ForEach(fd,i) {
          cout &lt;&lt; " " &lt;&lt; i-&gt;_name &lt;&lt; "=" &lt;&lt; i-&gt;_value;
        }
        cout &lt;&lt; " d=" &lt;&lt; hex;
        bool first = true;
        for (unsigned i = 0; i &lt; n; i += 4) {
          if (!first) cout &lt;&lt; ",";
          first = false;
          cout &lt;&lt; "0x" &lt;&lt; setw(8) &lt;&lt; setfill('0') &lt;&lt; byte_read32(data,i);
        }
        cout &lt;&lt; dec &lt;&lt; "\n";
      }
    }
};

unsigned get_exception_id(IssNode *node,const string &amp;name)
{
  const ExceptionInfos &amp;einfo = node-&gt;getExceptionInfo();
  ForEach(einfo,i) {
    if (i-&gt;_name == name) {
      return i-&gt;_id;
    }
  }
  RError("Unknown exception name " &lt;&lt; name);
}

int main(int argc,const char *argv[])
{
  try {
  bool trace = true;
  int prog = 0;
  unsigned id = 0;

  for (int i = 1; i != argc; ++i) {
    if (!strcmp(argv[i],"-trace")) {
      trace = true;
    }
    else if (!strcmp(argv[i],"-no-trace")) {
      trace = false;
    }
    if (!strcmp(argv[i],"-mem-logging")) {
      MemLogging = true;
    }
    else if (!strcmp(argv[i],"-no-mem-logging")) {
      MemLogging = false;
    }
    else if (!strcmp(argv[i],"-prog")) {
      prog = atoi(argv[++i]);
    }
  }

  // This instantiates the model.
# ifdef UADL
  uadl::UadlArch *model = uadl::createArch("P");
  IssNode *root = &amp;model-&gt;ISS();
# else
  IssNode *root = IssNamespace::createTopLevelNode(id);
# endif


# ifdef TrapAddr
  MyMem mem(root,get_exception_id(root,"DataStorage"),TrapAddr);
# else
  MyMem mem(root,0,0);
# endif  

# ifdef USE_LOGGING_MGR
  auto_ptr&lt;LoggingMgr&gt; mgr(createLoggingMgr(false));
  mgr-&gt;installLoggers(root);
# else
  root-&gt;setLogger(&amp;mylogger);
# endif

  root-&gt;setMemHandler(&amp;mem);

  if (trace) {
    root-&gt;set_tracing_r();
  }

  cout &lt;&lt; "CORE n=:P\n";

  // This initializes memory to the program to be run.
# ifdef VLE
  extern_mem_write32(0x00000100,0x04897f5b);
  extern_mem_write32(0x10000104,0xd051e2fd);

  root-&gt;setReg("NIA",0,0x100);
  root-&gt;setReg("GPR24",0,30);
  root-&gt;setReg("GPR25",0,100);
  root-&gt;setReg("GPR26",0,10);
  root-&gt;setReg("GPR27",0,1);  
# else

  switch (prog) {
  case 0:
    extern_mem_write32(0x00000100,0x80401000);  // lwz r2,0x1000(0)
    extern_mem_write32(0x00000104,0x394A0100);  // addi r10,r10,0x100
    extern_mem_write32(0x00000108,0x7C620A14);  // add r3,r2,r1
    extern_mem_write32(0x0000010c,0x34A5FFFE);  // subic. r5,r5,2
    extern_mem_write32(0x00000110,0x90640000);  // stw r3,0(r4)
    extern_mem_write32(0x00000114,0x90660000);  // stw r3,0(r6)
    extern_mem_write32(0x00000118,0xA0E01004);  // lhz  r7,0x1004(r0)
    extern_mem_write32(0x0000011c,0x89001005);  // lbz  r8,0x1005(r0)
    extern_mem_write32(0x00000120,0x99002004);  // stb  r8,0x2004(r0)
    extern_mem_write32(0x00000124,0xB0E02008);  // sth  r7,0x2008(r0)
    // Some register initializations.
    root-&gt;setReg("NIA",0,0x100);
    root-&gt;setReg("GPR1",0,0x1fff);
    root-&gt;setReg("GPR4",0,0x2000);
    root-&gt;setReg("GPR6",0,0xfffffffe);
    // If there's a cache, enable it.
    root-&gt;setReg("CCR",0,0xc0000000);
    break;
  case 1:
    extern_mem_write32(0x00000100,0x80201000);  // lwz r1,0x1000(r0)
    extern_mem_write32(0x00000104,0x80403000);  // lwz r2,0x3000(r0)
    extern_mem_write32(0x00000108,0x80601004);  // lwz r3,0x1004(r0)
    extern_mem_write32(0x0000010c,0x00000000);  // .long 0
    extern_mem_write32(0x00000110,0x00000000);  // .long 0
    extern_mem_write32(0x00000114,0x7D5A02A6);  // mfspr r10,SRR0
    extern_mem_write32(0x00000118,0x394A0004);  // addi r10,r10,4
    extern_mem_write32(0x0000011c,0x3A801234);  // li r20,0x1234
    extern_mem_write32(0x00000120,0x7D5A03A6);  // mtspr SRR0,r10
    extern_mem_write32(0x00000124,0x4C000064);  // rfi
    // Some register initializations.
    root-&gt;setReg("NIA",0,0x100);
    root-&gt;setReg("IVOR2",0,0x114);
    break;
  case 2:
    extern_mem_write32(0x00000010,0x8040100C);	//	lwz r2,0x100c(r0)
    extern_mem_write32(0x00000014,0x8040200C);  //  lwz r2,0x200c(r0)
    extern_mem_write32(0x00000018,0x90403008);	//	stw r2,0x3008(r0)
    root-&gt;setReg("NIA",0,0x10);
    root-&gt;setReg("CCR",0,0xc0000000);
    break;
  default:
    RError("No program " &lt;&lt; prog &lt;&lt; " defined.");
  }

# endif

  // Data memory initializations.
  extern_mem_write32(0x1000,0xdeadbeef);
  extern_mem_write32(0x1004,0x12345678);
  extern_mem_write32(0x2000,0x00000000);
  extern_mem_write32(0x3000,0x87654321);
  extern_mem_write32(0xfffffffc,0);
  extern_mem_write32(0x00000000,0);

  cout &lt;&lt; "TRACE\n";

# ifdef USE_LOGGING_MGR
  // If using the logging manager, then install our logger.
  mgr-&gt;registerLogger(&amp;mylogger);
# endif

  // This runs the simulation until it halts.  For this model, the core will
  // halt when it encounters an opcode of 0x00000000.
# ifdef UADL
  while (model-&gt;isActive()) {
    model-&gt;proceed();
  }
# else
  root-&gt;run();
# endif

  cout &lt;&lt; "\nRESULTS\n";

# ifdef UADL
  cout &lt;&lt; "\n# time " &lt;&lt; model-&gt;currTime() &lt;&lt; ": simulation terminated.  "
       &lt;&lt; model-&gt;issueCount() &lt;&lt; " instructions issued.\n\n";
# endif

  // Final results display.
  Reporter reporter;

  display_memory(6,0x1000,0x2000,0x2004,0x2008,0xfffffffc,0x00000000);
  root-&gt;showRegs(reporter);
  root-&gt;showCaches(reporter);
  }
  catch (exception &amp;err) {
    cerr &lt;&lt; "Error:  " &lt;&lt; err.what() &lt;&lt; "\n\n";
    return 1;
  }
}

</pre>
<p>The input model is a stripped-down version of a PowerPC.  The model library is
created using the command:</p>
<pre class="literal-block">adl2iss mod1.adl --output=mod1-base.so --target=base-so --no-debug-mode
--no-rnumber --extern-mem --no-porthole-enabled
</pre>
<p>which results in a file named <tt class="docutils literal"><span class="pre">mod1-base.so</span></tt>.  The driver program can be
compiled in the following manner (assuming that the input file is named
<tt class="docutils literal"><span class="pre">driver.C</span></tt>):</p>
<pre class="literal-block">g++ `adl-config --cflags` driver.C -c -o driver.o
</pre>
<p>The final linking is done in the following manner:</p>
<pre class="literal-block">g++ -o driver driver.o mod1-base.so
</pre>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="adl-iss-integration.rst">View document source</a>.
Generated on: 2018/02/28 15:14:27 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
