<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="standard header">
  <link type="text/css" rel="stylesheet" href="/swo/css/fsl.css" />
  <script type="text/javascript" language="javascript" src="/swo/jscripts/FSLHeader.js"></script>
  <script language="JavaScript"> 
        WriteFSHeader(); 
  </script> 
</div></div>
<div class="footer">
<hr class="footer" />
<a class="first last reference" href="./fsl-header.rst">View document source</a>.
Generated on: 2018/02/28 15:14:25 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<title>The uADL Language Reference</title>
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="title section" id="the-uadl-language-reference">
<h1><a>The uADL Language Reference</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Brian Kahne</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body"><a class="reference" href="mailto:bkahne&#64;freescale.com">bkahne&#64;freescale.com</a></td>
</tr>
</tbody>
</table>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first"><a name="table-of-contents">Table of Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#the-uadl-language-reference" id="id16" name="id16">The uADL Language Reference</a><ul class="auto-toc simple">
<li><a class="reference" href="#general-overview" id="id17" name="id17">1&nbsp;&nbsp;&nbsp;General Overview</a></li>
<li><a class="reference" href="#the-uadl-language" id="id18" name="id18">2&nbsp;&nbsp;&nbsp;The uADL Language</a><ul class="auto-toc simple">
<li><a class="reference" href="#operation-state-machine-theory" id="id19" name="id19">2.1&nbsp;&nbsp;&nbsp;Operation State Machine Theory</a><ul class="auto-toc simple">
<li><a class="reference" href="#osm-definition" id="id20" name="id20">2.1.1&nbsp;&nbsp;&nbsp;OSM Definition</a></li>
<li><a class="reference" href="#instruction-scheduling" id="id21" name="id21">2.1.2&nbsp;&nbsp;&nbsp;Instruction Scheduling</a></li>
<li><a class="reference" href="#instruction-classification" id="id22" name="id22">2.1.3&nbsp;&nbsp;&nbsp;Instruction Classification</a></li>
<li><a class="reference" href="#pseudo-instructions" id="id23" name="id23">2.1.4&nbsp;&nbsp;&nbsp;Pseudo Instructions</a></li>
<li><a class="reference" href="#automatic-deallocation-of-resources" id="id24" name="id24">2.1.5&nbsp;&nbsp;&nbsp;Automatic Deallocation of Resources</a></li>
<li><a class="reference" href="#safe-mode-and-normal-mode-models" id="id25" name="id25">2.1.6&nbsp;&nbsp;&nbsp;Safe-Mode and Normal Mode Models</a></li>
</ul>
</li>
<li><a class="reference" href="#core-level-scope-defines" id="id26" name="id26">2.2&nbsp;&nbsp;&nbsp;Core-Level Scope Defines</a><ul class="auto-toc simple">
<li><a class="reference" href="#helper-functions" id="id27" name="id27">2.2.1&nbsp;&nbsp;&nbsp;Helper Functions</a></li>
</ul>
</li>
<li><a class="reference" href="#the-threadthread-group-section" id="id28" name="id28">2.3&nbsp;&nbsp;&nbsp;The Thread/Thread-Group Section</a></li>
<li><a class="reference" href="#the-resources-section" id="id29" name="id29">2.4&nbsp;&nbsp;&nbsp;The Resources Section</a><ul class="auto-toc simple">
<li><a class="reference" href="#fetch-unit" id="id30" name="id30">2.4.1&nbsp;&nbsp;&nbsp;Fetch Unit</a><ul class="auto-toc simple">
<li><a class="reference" href="#parameters" id="id31" name="id31">2.4.1.1&nbsp;&nbsp;&nbsp;Parameters</a></li>
<li><a class="reference" href="#interface-methods" id="id32" name="id32">2.4.1.2&nbsp;&nbsp;&nbsp;Interface Methods</a></li>
</ul>
</li>
<li><a class="reference" href="#pipeline-stage" id="id33" name="id33">2.4.2&nbsp;&nbsp;&nbsp;Pipeline Stage</a><ul class="auto-toc simple">
<li><a class="reference" href="#id1" id="id34" name="id34">2.4.2.1&nbsp;&nbsp;&nbsp;Parameters</a></li>
<li><a class="reference" href="#id2" id="id35" name="id35">2.4.2.2&nbsp;&nbsp;&nbsp;Interface Methods</a></li>
</ul>
</li>
<li><a class="reference" href="#forwarding-paths" id="id36" name="id36">2.4.3&nbsp;&nbsp;&nbsp;Forwarding Paths</a><ul class="auto-toc simple">
<li><a class="reference" href="#id3" id="id37" name="id37">2.4.3.1&nbsp;&nbsp;&nbsp;Parameters</a></li>
<li><a class="reference" href="#id4" id="id38" name="id38">2.4.3.2&nbsp;&nbsp;&nbsp;Interface Methods</a></li>
</ul>
</li>
<li><a class="reference" href="#branch-predictor" id="id39" name="id39">2.4.4&nbsp;&nbsp;&nbsp;Branch Predictor</a><ul class="auto-toc simple">
<li><a class="reference" href="#id5" id="id40" name="id40">2.4.4.1&nbsp;&nbsp;&nbsp;Parameters</a></li>
<li><a class="reference" href="#id6" id="id41" name="id41">2.4.4.2&nbsp;&nbsp;&nbsp;Interface Methods</a></li>
</ul>
</li>
<li><a class="reference" href="#memory" id="id42" name="id42">2.4.5&nbsp;&nbsp;&nbsp;Memory</a><ul class="auto-toc simple">
<li><a class="reference" href="#id7" id="id43" name="id43">2.4.5.1&nbsp;&nbsp;&nbsp;Parameters</a></li>
<li><a class="reference" href="#id8" id="id44" name="id44">2.4.5.2&nbsp;&nbsp;&nbsp;Interface Methods</a></li>
</ul>
</li>
<li><a class="reference" href="#memory-port" id="id45" name="id45">2.4.6&nbsp;&nbsp;&nbsp;Memory Port</a></li>
<li><a class="reference" href="#cache" id="id46" name="id46">2.4.7&nbsp;&nbsp;&nbsp;Cache</a><ul class="auto-toc simple">
<li><a class="reference" href="#id9" id="id47" name="id47">2.4.7.1&nbsp;&nbsp;&nbsp;Interface Methods</a></li>
</ul>
</li>
<li><a class="reference" href="#semaphores" id="id48" name="id48">2.4.8&nbsp;&nbsp;&nbsp;Semaphores</a><ul class="auto-toc simple">
<li><a class="reference" href="#id10" id="id49" name="id49">2.4.8.1&nbsp;&nbsp;&nbsp;Parameters</a></li>
<li><a class="reference" href="#id11" id="id50" name="id50">2.4.8.2&nbsp;&nbsp;&nbsp;Interface Methods</a></li>
</ul>
</li>
<li><a class="reference" href="#flags" id="id51" name="id51">2.4.9&nbsp;&nbsp;&nbsp;Flags</a><ul class="auto-toc simple">
<li><a class="reference" href="#id12" id="id52" name="id52">2.4.9.1&nbsp;&nbsp;&nbsp;Interface Methods</a></li>
</ul>
</li>
<li><a class="reference" href="#custom-resources" id="id53" name="id53">2.4.10&nbsp;&nbsp;&nbsp;Custom Resources</a><ul class="auto-toc simple">
<li><a class="reference" href="#id13" id="id54" name="id54">2.4.10.1&nbsp;&nbsp;&nbsp;Parameters</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#the-machine-section" id="id55" name="id55">2.5&nbsp;&nbsp;&nbsp;The Machine Section</a></li>
<li><a class="reference" href="#the-instruction-class-section" id="id56" name="id56">2.6&nbsp;&nbsp;&nbsp;The Instruction Class Section</a><ul class="auto-toc simple">
<li><a class="reference" href="#the-repeat-label" id="id57" name="id57">2.6.1&nbsp;&nbsp;&nbsp;The Repeat Label</a></li>
<li><a class="reference" href="#operands" id="id58" name="id58">2.6.2&nbsp;&nbsp;&nbsp;Operands</a></li>
<li><a class="reference" href="#interface-functions" id="id59" name="id59">2.6.3&nbsp;&nbsp;&nbsp;Interface Functions</a></li>
<li><a class="reference" href="#id14" id="id60" name="id60">2.6.4&nbsp;&nbsp;&nbsp;Parameters</a></li>
<li><a class="reference" href="#id15" id="id61" name="id61">2.6.5&nbsp;&nbsp;&nbsp;Interface Methods</a><ul class="auto-toc simple">
<li><a class="reference" href="#control-api" id="id62" name="id62">2.6.5.1&nbsp;&nbsp;&nbsp;Control API</a></li>
<li><a class="reference" href="#all-operand-api" id="id63" name="id63">2.6.5.2&nbsp;&nbsp;&nbsp;All-Operand API</a></li>
<li><a class="reference" href="#latency-api" id="id64" name="id64">2.6.5.3&nbsp;&nbsp;&nbsp;Latency API</a><ul class="auto-toc simple">
<li><a class="reference" href="#globals-and-miscellaneous-functions" id="id65" name="id65">2.6.5.3.1&nbsp;&nbsp;&nbsp;Globals and Miscellaneous Functions</a></li>
</ul>
</li>
<li><a class="reference" href="#operand-interface-methods" id="id66" name="id66">2.6.5.4&nbsp;&nbsp;&nbsp;Operand Interface Methods</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#running-a-model" id="id67" name="id67">3&nbsp;&nbsp;&nbsp;Running A Model</a><ul class="auto-toc simple">
<li><a class="reference" href="#creating-a-model" id="id68" name="id68">3.1&nbsp;&nbsp;&nbsp;Creating A Model</a></li>
<li><a class="reference" href="#standalone-models" id="id69" name="id69">3.2&nbsp;&nbsp;&nbsp;Standalone Models</a></li>
</ul>
</li>
<li><a class="reference" href="#integration" id="id70" name="id70">4&nbsp;&nbsp;&nbsp;Integration</a><ul class="auto-toc simple">
<li><a class="reference" href="#processor-core-interface" id="id71" name="id71">4.1&nbsp;&nbsp;&nbsp;Processor Core Interface</a></li>
<li><a class="reference" href="#model-creation" id="id72" name="id72">4.2&nbsp;&nbsp;&nbsp;Model Creation</a></li>
<li><a class="reference" href="#model-configuration-methods" id="id73" name="id73">4.3&nbsp;&nbsp;&nbsp;Model Configuration Methods</a></li>
<li><a class="reference" href="#custom-cachememory-models" id="id74" name="id74">4.4&nbsp;&nbsp;&nbsp;Custom Cache/Memory Models</a></li>
<li><a class="reference" href="#dynamic-parameter-api" id="id75" name="id75">4.5&nbsp;&nbsp;&nbsp;Dynamic Parameter API</a></li>
<li><a class="reference" href="#model-control-methods" id="id76" name="id76">4.6&nbsp;&nbsp;&nbsp;Model Control Methods</a></li>
<li><a class="reference" href="#external-interrupt-methods" id="id77" name="id77">4.7&nbsp;&nbsp;&nbsp;External Interrupt Methods</a></li>
<li><a class="reference" href="#tracing-control" id="id78" name="id78">4.8&nbsp;&nbsp;&nbsp;Tracing Control</a></li>
<li><a class="reference" href="#breakpoints-and-watchpoints" id="id79" name="id79">4.9&nbsp;&nbsp;&nbsp;Breakpoints and Watchpoints</a></li>
<li><a class="reference" href="#systemc-interface" id="id80" name="id80">4.10&nbsp;&nbsp;&nbsp;SystemC Interface</a></li>
<li><a class="reference" href="#custom-branch-predictors" id="id81" name="id81">4.11&nbsp;&nbsp;&nbsp;Custom Branch Predictors</a></li>
<li><a class="reference" href="#external-memory-interface" id="id82" name="id82">4.12&nbsp;&nbsp;&nbsp;External Memory Interface</a><ul class="auto-toc simple">
<li><a class="reference" href="#transaction-interface" id="id83" name="id83">4.12.1&nbsp;&nbsp;&nbsp;Transaction Interface</a></li>
<li><a class="reference" href="#non-transaction-interface" id="id84" name="id84">4.12.2&nbsp;&nbsp;&nbsp;Non-Transaction Interface</a></li>
<li><a class="reference" href="#other-functions" id="id85" name="id85">4.12.3&nbsp;&nbsp;&nbsp;Other Functions</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#a-complete-example" id="id86" name="id86">5&nbsp;&nbsp;&nbsp;A Complete Example</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="general-overview">
<h2><a class="toc-backref" href="#id17" name="general-overview">1&nbsp;&nbsp;&nbsp;General Overview</a></h2>
<p>This manual documents the uADL language, a description language for
processor core micro-architectures.</p>
<p>It is organized as follows:</p>
<ul class="simple">
<li><a class="reference" href="#the-uadl-language">The uADL Language</a> describes the basic syntax and semantics of the
language.</li>
<li><a class="reference" href="#the-resources-section">The Resources Section</a> documents existing processor resource types and their
transaction interfaces.</li>
<li><a class="reference" href="#the-machine-section">The Machine Section</a> documents the finite-state machine description used to
model the processor pipeline.</li>
<li><a class="reference" href="#the-instruction-class-section">The Instruction Class Section</a> documents instruction classes, which group
instructions with common timing together and describes their pipeline
behavior.</li>
<li><a class="reference" href="#running-a-model">Running A Model</a> describes how to create and run your own models.</li>
<li><a class="reference" href="#integration">Integration</a> documents interfaces for integration into a system model.</li>
</ul>
</div>
<div class="section" id="the-uadl-language">
<h2><a class="toc-backref" href="#id18" name="the-uadl-language">2&nbsp;&nbsp;&nbsp;The uADL Language</a></h2>
<p>This chapter explains how to use the uADL language to describe a processor.
The basic syntax used in this language is the same as for ADL, but with
definition blocks relevant to describing a processor pipeline.  Please refer to
the <a class="reference" href="http://cad.freescale.net/adl/chrome/site/adl-language-reference.html">ADL Language Reference Manual</a> for a complete overview of the <em>define</em>
and <em>defmod</em> syntax.</p>
<p>In short, a description consists of blocks named <tt class="docutils literal"><span class="pre">define</span></tt> and <tt class="docutils literal"><span class="pre">defmod</span></tt>.  A
<tt class="docutils literal"><span class="pre">define</span></tt> defines an entity, while a <tt class="docutils literal"><span class="pre">defmod</span></tt> modifies an existing entity.
These blocks may be nested and/or contain key value pairs of data.  The C
preprocessor may be used to break a description into multiple files via the
<tt class="docutils literal"><span class="pre">#import</span></tt> directive and substitutions may be made via the <tt class="docutils literal"><span class="pre">#define</span></tt>
directive.</p>
<p>A define block takes the form of:</p>
<pre class="literal-block">define (type=name) {}
</pre>
<p>or:</p>
<pre class="literal-block">define (type name) {}
</pre>
<p>or:</p>
<pre class="literal-block">define (type=(name1, name2, ...) {}
</pre>
<p>The same syntax is used for a <tt class="docutils literal"><span class="pre">defmod</span></tt> block.  If a list of names are
supplied within the define or defmod, then the definition or modification is
replicated for each named item.</p>
<p>A complete uADL description consists of an outer core define block which then
contains three to four main types of sections: the <strong>resources</strong> section,
<strong>machine</strong> sections, and <strong>instruction class</strong> sections.  A <strong>thread</strong> or
<strong>thread_group</strong> section is optional and is used to describe resource sharing
for a multi-threaded processor.  These sections may occur in any order and may
be split across files via the use of <tt class="docutils literal"><span class="pre">#import</span></tt> and the use of defmod blocks.
Various helper functions and other minor defines and keys may occur within the
core block and are documented in <a class="reference" href="#core-level-scope-defines">Core-Level Scope Defines</a>.  Thus, the basic
structure of a design looks like:</p>
<pre class="literal-block">define (core P) {
  define (resources) {
    ...
    // Define pipeline stages, memories, caches, etc.
    ...
  }
  define (machine &lt;name&gt;) {
    ...
    // Define states used by instruction classes. 
    ...
  }
  define (instr_class &lt;name&gt;) {
    ...
  }
  ...
  // Define additional instruction classes.
  ...
}
</pre>
<p>The <strong>resources</strong> section of a model lists various processor resources, such as
pipeline stages, branch predictors, caches, and memory, and allows the user to configure these
resources.  Custom resources are also supported:  A user may specify a C++
class, via a header file, and configure constructor and template parameters via
the same syntax as used for configuring built-in resources.</p>
<p>Within an instruction class's action code, the resources may be referred to by
name and queried or modified by calling various methods.  These interface
methods are listed below in the documentation for each resource type.</p>
<p>The <strong>machine</strong> section describes the state machines which lie at the heart of
the uADL model.  Each machine consists of a series of states mapped to pipeline
resources.  The mapping may be very general and allows for an arbitrary number
of states to be mapped to a stage.  In addition, exception handling states and
mappings can also be described.  If an exception occurs in a given state, this
describes the state transition which will occur.</p>
<p>Multiple machines may be defined, though for simpler processors it often makes
sense to just define a single machine.  If only a single machine exists, then
this is used as the default and instruction classes will not need to specify it.</p>
<p>Finally, the <strong>instr_class</strong> sections define instruction classes.  In uADL, all
instructions, plus special instructions such as decode misses and fetch
exceptions, are combined into common classes.  Each instruction class represents
the behavior of similar instructions in terms of how they interact with resources
and propagate through the pipeline via state transitions.  Much of the
flexibility of uADL comes from this concept: Adding new instructions does not
require that the pipeline model be ripped up and modified.  Instead, new
instructions are simply assigned to existing or new instruction classes.</p>
<div class="section" id="operation-state-machine-theory">
<h3><a class="toc-backref" href="#id19" name="operation-state-machine-theory">2.1&nbsp;&nbsp;&nbsp;Operation State Machine Theory</a></h3>
<div class="section" id="osm-definition">
<h4><a class="toc-backref" href="#id20" name="osm-definition">2.1.1&nbsp;&nbsp;&nbsp;OSM Definition</a></h4>
<p>The Operational State Machine (OSM) is the pipeline model used by uADL.  An
OSM model is associated with an instruction class.  Each state of an OSM model
is mapped to a pipeline stage, and each edge of an OSM model represents a
pipeline stage transition.  Each state is also associated with C++ code which
inquires and acts upon various processor resources.</p>
<p>Graphically, an OSM model looks like:</p>
<div class="figure">
<img alt="OSM.png" src="OSM.png" /><p class="caption">A sample OSM model: The <em>sfx</em> instruction class of a five-stage pipeline.</p>
</div>
<p>To make an OSM model semantically complete, an artificial initial state is
introduced, which does not correspond to any pipeline stage.  When an OSM is at
the initial state, it is idle with no instruction loaded.  Any edge leading to
the initial state indicates that the instruction retires by following this edge.
Any edge leaving the initial state indicates that a new instruction is loaded by
following this edge.</p>
<p>The behavior being modeled is just the timing behavior of the instructions.  The
functional behavior, such as what an "add" instruction actually does, is modeled
by an ADL description and is not part of the OSM model.  The pipeline model
interacts with the functional description using a small set of interface
methods.  For example, in the figure, the call to <tt class="docutils literal"><span class="pre">exec()</span></tt> causes the
instruction to actually perform its calculation.</p>
<p>Resources and their interface methods are described in <a class="reference" href="#the-resources-section">The Resources Section</a>.
A resource inquiry method returns either success or failure (true or false).  In
order to make a state transition, all inquiries attached to the state must
return success.  In other words, if any inquiry returns false, the transition
cannot occur.</p>
<p>While OSM code interacts with some resources directly, such as memories,
register resources are hidden within <strong>operands</strong> in order to simplify the
description.  An operand maps various register, register-file, or immediate
operands to a name.  Different instructions within the same instruction class
may have different resources mapped to the same name.  For example, a PowerPC
<tt class="docutils literal"><span class="pre">add</span></tt> instruction might have one of its source registers, e.g. <tt class="docutils literal"><span class="pre">GPR(RA)</span></tt>
mapped to the operand <strong>Src1</strong> while the <tt class="docutils literal"><span class="pre">or</span></tt> instruction has <tt class="docutils literal"><span class="pre">GPR(RS)</span></tt>
mapped to <strong>Src1</strong>.  In both cases, these are source registers which behave in a
similar manner.  The action code for the instruction class can thus manipulate
<strong>Src1</strong> and not worry about the differences between the operands of <tt class="docutils literal"><span class="pre">add</span></tt> and
<tt class="docutils literal"><span class="pre">or</span></tt>.</p>
<p>This is also true when operands differ in type, such as between a register-file
operand and an immediate operand.  For example, both a PowerPC <tt class="docutils literal"><span class="pre">add</span></tt> and
<tt class="docutils literal"><span class="pre">addi</span></tt> (add-immediate) instruction might have a <strong>Src1</strong> operand mapped to
<tt class="docutils literal"><span class="pre">GPR(RA)</span></tt>.  However, the <tt class="docutils literal"><span class="pre">add</span></tt> maps <strong>Src2</strong> to <tt class="docutils literal"><span class="pre">GPR(RB)</span></tt> while <tt class="docutils literal"><span class="pre">addi</span></tt>
maps <strong>Src2</strong> to <tt class="docutils literal"><span class="pre">D</span></tt>, its immediate value.  The action code will manipulate
<strong>Src2</strong> using the same interface, but, an inquiry to see whether <strong>Src2</strong> is
available for reading will always return true for <tt class="docutils literal"><span class="pre">addi</span></tt>, as it is an
immediate value.  This optimization is performed at compile-time, using C++
templates, thus eliminating this overhead during model execution.</p>
<p>In summary, the underlying finite state machine of an OSM model depicts the
structural data path of an instruction, while the code attached to the states
models the instruction's pipeline performance behavior.  An OSM model does not
necessarily model the entire pipeline because it only contains pipeline stages
that are reachable by the associated instruction class.  In other words, an OSM
model only represents a local view of the pipeline by the instruction class.</p>
<p>For example, an integer class OSM model does not cover floating-point execution
stages.  The union of OSM models of all instruction classes constitute a global
view of the entire pipeline.  This modeling approach, combined with the
separation of micro-architecture and functional behavior, enables the model
developer to divide the entire pipeline into multiple subsets based on
instruction classification, and model each subset independently.  This can prove
very effective in reducing modeling complexity when dealing with
micro-architectures with complex pipelines.</p>
</div>
<div class="section" id="instruction-scheduling">
<h4><a class="toc-backref" href="#id21" name="instruction-scheduling">2.1.2&nbsp;&nbsp;&nbsp;Instruction Scheduling</a></h4>
<p>The processor model simulates by iterating over pipeline stages and executing
any instructions (OSMs) contained within those stages.  The instruction's
current state action is then executed; if it changes state via a call to
<tt class="docutils literal"><span class="pre">change_state()</span></tt>, and the subsequent state is mapped to a different pipeline
stage, then execution ends for the current cycle.  Otherwise, the next state is
executed.</p>
<p>The ability to execute multiple states in a single cycle, as long as
they correspond to the same pipeline stage allows complex conditionals to be
broken down into smaller pieces.  For example, one common idiom is to perform
some actions immediately when an instruction enters a state, even if the
instruction cannot make further progress because of a stall in a subsequent
instruction.  This may be modeled by breaking the code into two states:  An
initial state which performs the action and a secondary state which tests for
the ability to move to the next stage:</p>
<pre class="literal-block">S1: if ( Src.can_read() ... ) {
  // Perform actions.
  Src.read();
  ...
  change_state(S2);
}
S2: if ( m2.has_space() ) {
  change_state(S3);
}
</pre>
<p>In the above example, S1 and S2 map to the stage <strong>m1</strong>, while S3 maps to the
stage <strong>m2</strong>.  An instruction enters <strong>m1</strong> via state S1 and then performs an
operand read if possible.  It then transitions to S2, where it moves to stage
<strong>m2</strong> (state S3) only if there is space, at which point it is done for the
current cycle.  If a stall has caused an instruction to still be in <strong>m2</strong>, then
the initial actions in S1 are still performed and the instruction will simply
wait in S2 until space is available.</p>
</div>
<div class="section" id="instruction-classification">
<h4><a class="toc-backref" href="#id22" name="instruction-classification">2.1.3&nbsp;&nbsp;&nbsp;Instruction Classification</a></h4>
<p>Instruction classification is arbitrary.  It should normally follow the natural
instruction groups, i.e. integer arithmetic, floating-point arithmetic, load,
store, branch, etc..  Different classes are needed when behavior differs
dramatically, e.g. between instructions which operate upon memory versus those
which do not.</p>
</div>
<div class="section" id="pseudo-instructions">
<h4><a class="toc-backref" href="#id23" name="pseudo-instructions">2.1.4&nbsp;&nbsp;&nbsp;Pseudo Instructions</a></h4>
<p>Normally, instruction classes list instructions which are defined by the
functional (ADL) description.  Several pseudo instructions exist, however, for
dealing with special situations.  These may appear within the <tt class="docutils literal"><span class="pre">instructions</span></tt>
list of an instruction class.</p>
<dl class="docutils">
<dt><em>decode_miss</em>:</dt>
<dd>Used to describe the behavior of an illegal instruction.</dd>
<dt><em>default_instruction</em>:</dt>
<dd>Used to provide default behavior for any instructions not explicitly listed
within any other instruction class.  Normally, all instructions must be listed
if <strong>allow_unimpl_instrs</strong> is false (the default).  Using this pseudo
instruction allows the user to not have to explicitly list all instructions.</dd>
<dt><em>fetch_exception</em>:</dt>
<dd>Used to describe the behavior of a fetch-exception.</dd>
</dl>
</div>
<div class="section" id="automatic-deallocation-of-resources">
<h4><a class="toc-backref" href="#id24" name="automatic-deallocation-of-resources">2.1.5&nbsp;&nbsp;&nbsp;Automatic Deallocation of Resources</a></h4>
<p>When a pipeline flush occurs, resources held by an instruction must be
deallocated. In uADL, resource allocations are virtual, in that the instruction
itself holds no information about what resources have actually been
allocated. Instead, the instruction's location within the instruction-class
state-machine indicates what is allocated.</p>
<p>When a flush occurs, an automatically generated flush function is called. This
attempts to deallocate any resources which have been allocated. The algorithm
for determining this is to examine all prior states and find resource and
operand method calls which start with allocate, e.g, <tt class="docutils literal"><span class="pre">Sem1.allocate()</span></tt>,
<tt class="docutils literal"><span class="pre">Mem.allocate_force_lock()</span></tt>, etc., and then to call the corresponding
deallocate method to deallocate the resource. For this reason, all resources,
including custom resources, should follow the guideline that all allocation
methods start with <strong>allocate</strong> and all deallocation resources start with
<strong>deallocate</strong>.</p>
</div>
<div class="section" id="safe-mode-and-normal-mode-models">
<h4><a class="toc-backref" href="#id25" name="safe-mode-and-normal-mode-models">2.1.6&nbsp;&nbsp;&nbsp;Safe-Mode and Normal Mode Models</a></h4>
<p>A single uADL description may be used to produce two different types of models,
known as <strong>normal</strong> and <strong>safe-mode</strong>.  In a normal-mode model, each instruction
stores within it all operand values.  Instruction execution acts upon these
copied values and architectural state is only updated when the instruction
explicitly writes its operands.  A safe-mode model, on the other hand, acts as a
loosely coupled ISS and pipeline model.  The functional portion (the ISS)
executes the complete instruction immediately at issue-time; the instruction travels through
the pipeline simply for timing purposes.</p>
<p>On the one-hand, a normal-mode model can more accurately describe the timing of
a complex core, with respect to its external interactions, since memory
operations can be performed in the appropriate pipeline stage, rather than all
at once.  This type of model can also more easily handle speculative execution,
since architectural state is only updated when an instruction is committed.
Finally, it can also be used for discovering model issues; a timing error
resulting from not reading a forwarding path and advancing with incorrect data
will result in a wrong value which can be easily detected.</p>
<p>On the other hand, in some situations it is more important to have 100% correct
functional behavior and the timing behavior need be only approximate or needs to
only model a portion of a processor.  In this case, a safe-mode model is
appropriate.  Timing errors will not produce bad functional values, as
forwarding paths are simply used for timing purposes.</p>
</div>
</div>
<div class="section" id="core-level-scope-defines">
<h3><a class="toc-backref" href="#id26" name="core-level-scope-defines">2.2&nbsp;&nbsp;&nbsp;Core-Level Scope Defines</a></h3>
<p>This section describes core-level configuration parameters and miscellaneous define
blocks.</p>
<ul>
<li><p class="first"><em>allow_unimpl_instrs = &lt;bool&gt;</em>: If false (the default), then all instructions
found in the functional (ADL) description must exist in an instruction class
in the uADL description, or else an instruction class must exist which
contains the special <tt class="docutils literal"><span class="pre">default_instr</span></tt> pseudo-instruction.</p>
</li>
<li><p class="first"><em>branch_hook = func(InstrType &amp;) {}</em>: If present, this is called after a
branch's instruction handler has executed, for safe-mode models.  This hook
may be used, for example, to set the speculative state of the model based upon
the branch predictor's prediction.</p>
</li>
<li><p class="first"><em>commit_on_exception = &lt;bool&gt;</em>: This controls whether an exception's actions
should be taken immediately when the exception occurs, or whether the user
will explicitly control the behavior.  If true, then the model automatically
generates calls to <tt class="docutils literal"><span class="pre">commit_exceptions</span></tt> and <tt class="docutils literal"><span class="pre">flush</span></tt> on the state transition
to an exception state.  The default is true.</p>
</li>
<li><p class="first"><em>dead_lock_timeout = &lt;int&gt;</em>: This specifies the
timeout value (in cycle) of a dead/live-lock situation.  For example:</p>
<pre class="literal-block">dead_lock_timeout = 100
</pre>
<p>This means after 100 idle cycles, an instruction that gets stuck is deemed
locked and will be removed.  This parameter is only used by the safe mode.  It
is ignored otherwise.</p>
</li>
<li><p class="first"><em>mem_access = func(UadlMemAcess) { }</em>: If present, this hook is called
whenever a memory access is performed.  It may be used to modify the status of
the memory access object, such as turning on the serialized flag if the
address falls within a certain range or a certain translation parameter is
set.  Note that this function is instantiated in the scope of the ADL ISS
object, and thus the ADL registers, MMU, etc., are accessible.</p>
</li>
<li><p class="first">Definition: <em>mem_alias</em>: Allows the user to create memory aliases.  This maps
alias names to memory or cache resources, allowing instruction-class behavior
to be generic.  For example, an alias of <tt class="docutils literal"><span class="pre">DataMem</span></tt> might map to memory for
one model and a data cache for another model.</p>
<p>Each key in the define block is an alias name.  The value is the name of a
memory, cache, or memory port.  For example:</p>
<pre class="literal-block">define (mem_alias) {
  InstrMem = L1i;
  DataMem  = Mem.D;
}
</pre>
<p>In this example, <tt class="docutils literal"><span class="pre">InstrMem</span></tt> maps to a cache named <tt class="docutils literal"><span class="pre">L1i</span></tt> and <tt class="docutils literal"><span class="pre">DataMem</span></tt>
maps to the <tt class="docutils literal"><span class="pre">D</span></tt> port in the memory <tt class="docutils literal"><span class="pre">Mem</span></tt>.</p>
</li>
</ul>
<div class="section" id="helper-functions">
<h4><a class="toc-backref" href="#id27" name="helper-functions">2.2.1&nbsp;&nbsp;&nbsp;Helper Functions</a></h4>
<p>A model may also contain helper functions within the core-level scope.  These
functions may access resources, such as caches, just as instruction-class action
code is able to, and are provided as a way to re-factor and simplify a design.</p>
<p>Since helper functions are written at the core-level scope, they do not have
automatic access to an instruction class's operands.  They do have access to the
objects declared in the <strong>resources</strong> section and are also able to call helper
functions declared in the ADL description.</p>
<p>It should also be noted that when a resource's method is called within an
instruction class, three special parameters are automatically added to the front
of the method call: A reference to the core's class, a reference to the current
instruction, and a pointer to the logger.  These parameters are not
automatically added within a helper function and must thus be added by the user.</p>
<p>For example, within an instruction class, a cache method can be called with no
arguments:</p>
<pre class="literal-block">L1d.can_requests_cmd();
</pre>
<p>Within a helper function, this call would have to be changed to add on the
necessary parameters:</p>
<pre class="literal-block">bool check_l1d (InstrType &amp;instr,Logger *logger) {
  L1d.can-request_cmd(thisCore(),instr,logger);
}

...
S_Exec: if (check_l1d(thisInstr(),logger)) { ... }
</pre>
<p>Since the helper is a member of the core's class, a reference can be supplied by
calling <tt class="docutils literal"><span class="pre">thisCore()</span></tt>.  The type <tt class="docutils literal"><span class="pre">InstrType</span></tt> may be used as the instruction's
type and the logger's type is <tt class="docutils literal"><span class="pre">Logger</span></tt>.  The function <tt class="docutils literal"><span class="pre">thisInstr()</span></tt> can be
used to retrieve a reference to the current instruction within an instruction
class.</p>
</div>
</div>
<div class="section" id="the-threadthread-group-section">
<h3><a class="toc-backref" href="#id28" name="the-threadthread-group-section">2.3&nbsp;&nbsp;&nbsp;The Thread/Thread-Group Section</a></h3>
<p>The <strong>thread</strong> and <strong>thread_group</strong> defines are used to describe resource
sharing within a multi-threaded design.  These blocks must match the system/core
hierarchy within the corresponding ADL description.  The basic structure is:</p>
<pre class="literal-block">define (thread=&lt;name&gt;) {
  define (resources) {
    ...
  }
}

define (thread_group=&lt;name&gt;) {
  define (resources) {
    ...
  }

  &lt;thread or thread_group definition&gt;

}
</pre>
<p>A <strong>thread</strong> definition must correspond to a <strong>core</strong> definition in the ADL
description; it will contain a <strong>resources</strong> block describing resources local to
the thread.  A <strong>thread_group</strong> definition may contain nested thread groups or
<strong>thread</strong> definitions, as well as a <strong>resources</strong> definition.</p>
<p>Note that the thread hierarchy should only match the system/core declarations in
the ADL description, not the instances of those systems or cores.  For example,
given an ADL hierarchy such as the following:</p>
<pre class="literal-block">define (system=top) {
  define (system=Foo) {
    define (core=Bar) {
      ...
    }
    Bar b0;
    Bar b1;
  }
  Foo f0;
  Foo f1;
}
</pre>
<p>the corresponding uADL hierarchy would be:</p>
<pre class="literal-block">define (core=top) {
  define (thread_group=Foo) {
    define (thread=Bar) {
    }
  }
}
</pre>
<p>The uADL front-end will take care of replicating <tt class="docutils literal"><span class="pre">Foo</span></tt> and <tt class="docutils literal"><span class="pre">Bar</span></tt> in the uADL
description as necessary, based upon the instances found in the ADL hierarchy.</p>
<p>Within each thread-group or thread block should be a resources block which
defines what resources are local to the thread or group of threads.  So, for
example, if each thread contains its own simple-fixed-point pipeline, then those
stages should be placed within the resources section of that thread define.  If
the core contains a shared complex-fixed-point pipeline, then those pipeline
stages would be declared at the outer-most level.</p>
<p>Resources declared in the ADL hierarchy are automatically imported at the
correct hierarchy level.  For example, a shared L2 in the ADL description is
automatically imported at the top-level, whereas thread-private L1 caches would
be imported into the corresponding thread resources.</p>
</div>
<div class="section" id="the-resources-section">
<h3><a class="toc-backref" href="#id29" name="the-resources-section">2.4&nbsp;&nbsp;&nbsp;The Resources Section</a></h3>
<p>The resources section contains definitions of various processor resources, e.g.  register
files, caches, etc., of the processor.  It has the following structure:</p>
<pre class="literal-block">define (reources) {
  define (&lt;type&gt; &lt;name&gt;) {
    &lt;parameter&gt; = &lt;value&gt;;
    ...
  }
}
</pre>
<div class="section" id="fetch-unit">
<h4><a class="toc-backref" href="#id30" name="fetch-unit">2.4.1&nbsp;&nbsp;&nbsp;Fetch Unit</a></h4>
<p>Type name:  <tt class="docutils literal"><span class="pre">fetchunit</span></tt>.</p>
<p>A uADL model must have one fetch unit.</p>
<p>Below is a typical fetch unit definition:</p>
<pre class="literal-block">define (fetchunit fetcher) {
  fetch_memory = MEM;   // fetch from MEM
  entries      = 2;     // 2-entry instruction buffer
  entry_size   = 4;     // four-byte entry
  fetch_size   = (4,2);
  min_fetch_entries = 0;
  can_cancel   = true;
  reuse_data   = false;
} 
</pre>
<div class="section" id="parameters">
<h5><a class="toc-backref" href="#id31" name="parameters">2.4.1.1&nbsp;&nbsp;&nbsp;Parameters</a></h5>
<ul class="simple">
<li><em>fetch_memory = &lt;ident&gt;</em>:  Instruction source memory.  Must be a defined
memory or cache in the architecture (ADL) description.</li>
<li><em>entries = &lt;int&gt;</em>:  Number of entries.</li>
<li><em>entry_size = &lt;int&gt;</em>:  Entry size, in bytes.</li>
<li><em>fetch_size = &lt;int&gt;|&lt;list(int)&gt;</em>:  Set of valid fetch sizes, in bytes.</li>
<li><em>interleaved = &lt;bool&gt;</em>: If true, then for a multi-threaded architecture, the
fetch operations of the threads are interleaved, rather than each thread fully
executing fetch and issue before passing control to the next thread.</li>
<li><em>max_fetch_count = &lt;int&gt;</em>: Specify the maximum number of fetches to be
performed in a single cycle.  Defaults to unlimited, which means that the main
restriction will be the memory subsystem.</li>
<li><em>min_fetch_entries = &lt;int&gt;</em>: This parameter, if not 0, specifies the minimal
number of instruction buffer entries that should be vacant before the fetch
unit can initiate a new fetch.  When it is 0, the mininal required space for a
new fetch is the greatest fetch size.</li>
<li><em>branch_predictor = &lt;ident&gt;</em>: Name of an associated branch predictor.  This is
an optional parameter.  If this parameter is defined, the fetch unit will
consult the associated branch predictor for predictions during fetch time, and
direct fetch flow accordingly.  You cannot use fetch-time branch prediction
and explicit branch prediction at a stage (through instruction class's action
code) at the same time.</li>
</ul>
<a id="can-cancel"></a><ul class="simple">
<li><em>can_cancel = &lt;bool&gt;</em>: Specifies whether the fetch unit can cancel pending
fetch requests upon an instruction buffer flushing caused by change of flow.
Specifically, the fetch unit will instruct its instruction memory to do deep
cancellation (can_cancel = true) or weak cancellation (can_cancel = false)
when it needs to abandon some pending fetch requests.</li>
<li><em>reuse_data = &lt;bool&gt;</em>: This parameter affects how the fetch unit respondes to
change-of-flows.  If reuse_data = false, which is the default, when a
change-of-flow occurs, the fetch unit does a full flush of the instruction
buffer and start fetching from the target address.  If reuse_data = true, when
a change-of-flow occurs, the fetch unit first checks if the target address is
already in the instruction buffer or is covered by an outstanding fetch
request, and if such a hit condition exists, the fetch unit only flushes to
the point before the target address and does not re-fetch.</li>
<li><em>lazy_fetch = &lt;bool&gt;</em>: When <em>lazyFetch</em> is set to <tt class="docutils literal"><span class="pre">true</span></tt>, the processor will
issue fetch requests only if at the beginning of the cycle, the instruction
buffer has space for more instructions.  When <em>lazy_fetch</em> is set to <tt class="docutils literal"><span class="pre">false</span></tt>,
the processor will issue fetch requests even if at the beginning of the cycle,
the instruction buffer is full, but will have space by the end of the cycle
because some instructions are dispatched during that cycle.  For most
processors, <em>lazy_fetch</em> should be set to <tt class="docutils literal"><span class="pre">true</span></tt>.</li>
<li><em>flush_fetch = &lt;bool&gt;</em>: If true, then a new fetch is always attempted after a
pipeline flush.</li>
</ul>
</div>
<div class="section" id="interface-methods">
<h5><a class="toc-backref" href="#id32" name="interface-methods">2.4.1.2&nbsp;&nbsp;&nbsp;Interface Methods</a></h5>
<dl class="docutils">
<dt><em>void cancel()</em>:</dt>
<dd>Cancel outstanding transactions in the fetch unit.  Similar to
<tt class="docutils literal"><span class="pre">flush()</span></tt> except that held data is not flushed; only new transactions
are stopped.  As in <tt class="docutils literal"><span class="pre">flush()</span></tt>, the optional boolean parameter allows
the user to override the default <a class="reference" href="#can-cancel">can_cancel</a> behavior of the fetch unit.</dd>
<dt><em>void flush()</em>:</dt>
<dd><p class="first">Flush just the fetch unit.  If there were existing entries, or pending
requests, then the next fetch will be to the first entry or pending
request that was in the unit.  This is not intended for a change in
control flow, but as a means of reseting the unit, due to special
instructions which might change machine state.</p>
<p class="last">A boolean parameter may be specified to override the normal <a class="reference" href="#can-cancel">can_cancel</a>
behavior of the fetch unit.</p>
</dd>
<dt><em>void force()</em>:</dt>
<dd>Force a new fetch operation to occur.</dd>
<dt><em>void pause()</em>:</dt>
<dd>Pause the operation of the fetch unit.</dd>
<dt><em>void set_cancel(bool)</em>:</dt>
<dd>This allows the user to override the default <em>can_cancel</em> policy of the
fetch unit.  This command is only relevant for the next call to a
fetch-unit method, such as <strong>cancel</strong>.</dd>
</dl>
</div>
</div>
<div class="section" id="pipeline-stage">
<h4><a class="toc-backref" href="#id33" name="pipeline-stage">2.4.2&nbsp;&nbsp;&nbsp;Pipeline Stage</a></h4>
<p>Type name:  <tt class="docutils literal"><span class="pre">pipestage</span></tt>.</p>
<p>This describes a stage in a processor's pipeline.  A pipeline can store one or
more instructions and can behave in various ways, such as in a lock-step manner
(instructions march through together) or as a queue, such as to model a re-order
buffer.</p>
<p>Below is a typical pipeline stage definition:</p>
<pre class="literal-block">define (pipestage=foo) {
  size = 1;
  issue = false;
}
</pre>
<p>The issue stage (the stage mapped to the <a class="reference" href="#init-state">init_state</a>) is not explicitly
declared by the user, but can be referenced using the name <em>Issue</em>.  It can
store a single instruction in the case of stalls from the decode stage.
Normally, the only reason to reference this stage is to query its instruction
for attribute information.</p>
<div class="section" id="id1">
<h5><a class="toc-backref" href="#id34" name="id1">2.4.2.1&nbsp;&nbsp;&nbsp;Parameters</a></h5>
<ul class="simple">
<li><em>bandwidth = &lt;int&gt;</em>:  Number of instructions that can enter the stage in one
cycle.  Default value is 1.</li>
<li><em>issue = &lt;bool&gt;</em>:  Whether this stage is the issue stage.  Default value is
<tt class="docutils literal"><span class="pre">false</span></tt>.</li>
<li><em><a class="target" id="lock-step">lock_step</a> = &lt;bool&gt;</em>: If true, all instructions in the stage transition only
if all instructions' state-actions evaluated to true.  This allows for the
modeling of in-order multi-issue machines, in which instructions travel
together down the pipeline.</li>
<li><em>size = &lt;int&gt;</em>:  Number of instructions the stage can simultaneously hold.
Default value is 1.</li>
<li><em>rigid = &lt;bool&gt;</em>: If true, then this stage is to be considered part of a rigid
pipeline. The has_space() predicate returns false if a stall has occurred.</li>
</ul>
</div>
<div class="section" id="id2">
<h5><a class="toc-backref" href="#id35" name="id2">2.4.2.2&nbsp;&nbsp;&nbsp;Interface Methods</a></h5>
<ul class="simple">
<li><em>unsigned capacity()</em>: Returns the total capacity for this stage.</li>
<li><em>bool has_space()</em>: Returns true if the stage has the necessary space.</li>
<li><em>bool has_space(unsigned n)</em>: Returns true if the stage has space for n
instructions.</li>
<li><em>bool empty()</em>:  Returns true if the stage is currently empty of all
instructions.</li>
<li><em>bool has_attr(unsigned index,unsigned attr)</em>:  Returns true if the
instruction at the specified position in the stage contains any attributes as
specified by <tt class="docutils literal"><span class="pre">attr</span></tt>.  Attributes are defined within instruction classes
using the <tt class="docutils literal"><span class="pre">attrs</span></tt> key.</li>
<li><em>bool has_attr(unsigned attr)</em>: Returns true if the first instruction in the
stage (position 0) has the specified attributes.</li>
<li><em>unsigned instr_class(unsigned index = 0)</em>: Returns the instruction class
currently located at the specified position in the stage.  Enumerated values
are automatically created for all instruction classes, of the form
<tt class="docutils literal"><span class="pre">name_class</span></tt>, where <tt class="docutils literal"><span class="pre">name</span></tt> is the name of the instruction class.</li>
<li><em>unsigned size()</em>: Returns the number of instructions currently in the
pipeline stage.</li>
</ul>
</div>
</div>
<div class="section" id="forwarding-paths">
<h4><a class="toc-backref" href="#id36" name="forwarding-paths">2.4.3&nbsp;&nbsp;&nbsp;Forwarding Paths</a></h4>
<p>Type name:  <tt class="docutils literal"><span class="pre">forwarding_path</span></tt>.</p>
<p>A forwarding path allows an instruction in the pipeline to send computed results
to other instructions further back in the pipeline, allowing them to proceed
before architectural state has been updated.  A forwarding path may store one or
more items of data; each item of data is tagged and can be checked to make sure
that it is valid.</p>
<p>Below is a typical forwarding path definition:</p>
<pre class="literal-block">define (forwarding_path foo) {
  size = 4;
}
</pre>
<div class="section" id="id3">
<h5><a class="toc-backref" href="#id37" name="id3">2.4.3.1&nbsp;&nbsp;&nbsp;Parameters</a></h5>
<ul class="simple">
<li><em>broadcast = &lt;int&gt;</em>: If false, then a forwarding path will only return a match
if its tag (identifier of the instruction which wrote the value into the
forwarding path) matches the register's last allocator.  If false, then this
value is not checked, making it suitable for use as a broadcast completion
bus.</li>
<li><em>size = &lt;int&gt;</em>: Number of operand values the forwarding path can hold.</li>
<li><em>width = &lt;int&gt;</em>:  Maximum width of the data.  Automatically set to the size of
the program counter if not specified.</li>
</ul>
</div>
<div class="section" id="id4">
<h5><a class="toc-backref" href="#id38" name="id4">2.4.3.2&nbsp;&nbsp;&nbsp;Interface Methods</a></h5>
<p>Rather than use member functions of the forwarding path, checking for data
availability is performed via the <strong>can_read_fp()</strong> function and reading of the
actual data is done via the <strong>read()</strong> function.</p>
<ul class="simple">
<li><em>void write(Operand)</em>: Write data from the operand to the forwarding path.</li>
</ul>
</div>
</div>
<div class="section" id="branch-predictor">
<h4><a class="toc-backref" href="#id39" name="branch-predictor">2.4.4&nbsp;&nbsp;&nbsp;Branch Predictor</a></h4>
<p>Type name:  <tt class="docutils literal"><span class="pre">branch_predictor</span></tt>.</p>
<p>Below is a typical branch predictor definition:</p>
<pre class="literal-block">define (branch_predictor foo) {
  algorithm     = Counter;
  size          = 8;
  counter_width = 2;
}
</pre>
<p>Currently, only the <tt class="docutils literal"><span class="pre">Counter</span></tt> branch predictor is built into uADL, but custom
branch predictors may be supplied by the user.  A custom branch predictor
behaves like a custom resource, in that template and constructor parameters for
the class may be specified within the <strong>args</strong> define block.</p>
<div class="section" id="id5">
<h5><a class="toc-backref" href="#id40" name="id5">2.4.4.1&nbsp;&nbsp;&nbsp;Parameters</a></h5>
<ul>
<li><p class="first"><em>algorithm = &lt;ident&gt;</em>:  Specifies the branch predictor algorithm to be used.
If the algorithm is not recognized as an internally supported one, then it is
assumed that the algorithm is custom.  Refer to <a class="reference" href="#custom-branch-predictors">Custom Branch Predictors</a>
for more information about how to use this feature.</p>
<p>Currently, the only internally supported algorithm is <tt class="docutils literal"><span class="pre">Counter</span></tt>, a simple
single-counter branch predictor with a maximum number of entries and a fixed
counter width.</p>
</li>
<li><p class="first"><em>counter_width = &lt;int&gt;</em>: Bit-width of the prediction counters, for the
standard <tt class="docutils literal"><span class="pre">Counter</span></tt> type.</p>
</li>
<li><p class="first"><em>enable = func() {}</em>: A boolean predicate which specifies whether or not the
predictor is enabled.  This may reference any architectural resource, such as
registers.</p>
</li>
<li><p class="first"><em>header = &lt;str&gt;</em>: Specify the header file name for a custom branch
predictor. Defaults to <tt class="docutils literal"><span class="pre">&lt;algorithm&gt;.h</span></tt>, where <tt class="docutils literal"><span class="pre">algorithm</span></tt> is the value of
the <strong>algorithm</strong> parameter. The file is searched for in the current
directory, then in any additional directories specified using the
<strong>--include</strong> or <strong>-I</strong> command-line options.</p>
</li>
<li><p class="first"><em>reg_compares = &lt;ident|ident.ident|list(ident|ident.ident)&gt;</em>:  This feature
allows the user to specify additional criteria to match against when searching
entries in the branch predictor.  This may be either a single element or list,
where each element is either a register name or of the form
<strong>register.field</strong>.  For example:</p>
<pre class="literal-block">reg_compares = (MSR.IR,PID);
</pre>
<p>In the example above, when the predictor is updated, the current architectural
state of the <strong>IR</strong> field of the <strong>MSR</strong> register and the <strong>PID</strong> register
will be stored in the branch predictor entry.  During a prediction, the
current architectural state of these registers must be equal to the values
stored in an entry in order to be considered a match.</p>
</li>
<li><p class="first"><em>size = &lt;int&gt;</em>: Number of entries in the predictor, for the standard
<tt class="docutils literal"><span class="pre">Counter</span></tt> type.</p>
</li>
<li><p class="first">Definition: <em>args</em>: For custom branch predictors, each key/value pair within
this block is considered an argument. Both template and constructor arguments
will be searched.</p>
</li>
</ul>
</div>
<div class="section" id="id6">
<h5><a class="toc-backref" href="#id41" name="id6">2.4.4.2&nbsp;&nbsp;&nbsp;Interface Methods</a></h5>
<dl class="docutils">
<dt><em>bool enabled()</em>:</dt>
<dd>Returns true if the predictor is enabled.</dd>
<dt><em>bool last_predict_taken()</em>:</dt>
<dd>Returns true if the last branch was predicted taken.</dd>
<dt><em>bool last_predict_taken(addr_t &amp;target)</em>:</dt>
<dd>Returns true if the last branch was predicted taken.  If it was taken, then
target is updated with the branch target.</dd>
<dt><em>std::pair&lt;Prediction,addr_t&gt; predict()</em>:</dt>
<dd>Read branch prediction from the branch predictor.  This returns a pair, where
the first item is an enum with the values <tt class="docutils literal"><span class="pre">Miss</span></tt>, <tt class="docutils literal"><span class="pre">Taken</span></tt>, <tt class="docutils literal"><span class="pre">NotTaken</span></tt>,
or <tt class="docutils literal"><span class="pre">NoPrediction</span></tt>.  The second element is the predicted target address, if
relevant.  This generally only needs to be called if the branch predictor is
not implicitly used by the fetch unit (via the <strong>branch_predictor</strong> key).</dd>
<dt><em>void update()</em>:</dt>
<dd>Update the branch predictor with branch outcome.  Only relevant if called by a
branch instruction, which internally updates the core's branch-target.</dd>
</dl>
</div>
</div>
<div class="section" id="memory">
<h4><a class="toc-backref" href="#id42" name="memory">2.4.5&nbsp;&nbsp;&nbsp;Memory</a></h4>
<p>Type name:  <tt class="docutils literal"><span class="pre">memory</span></tt>.</p>
<p>Below is a typical memory definition:</p>
<pre class="literal-block">define (memory mem) {
  addr_bandwidth = 1;
  data_bandwidth = 1;
  read_latency   = 1;
  write_latenchy = 1;
  max_requests   = 1;
  allow_bus_wait = false;
  preemptive     = false;
  read_only      = false;
}
</pre>
<div class="section" id="id7">
<h5><a class="toc-backref" href="#id43" name="id7">2.4.5.1&nbsp;&nbsp;&nbsp;Parameters</a></h5>
<ul>
<li><p class="first"><em>addr_bandwidth = &lt;int&gt;</em>: Maximum number of requests that can be received per
cycle for address handling (requests).  Default is 1.</p>
</li>
<li><p class="first"><em>data_bandwidth = &lt;int&gt;</em>: Maximum number of data transactions (reads/writes)
that can be done per cycle.  Default is 1.</p>
</li>
<li><p class="first"><em>data_width = &lt;int&gt;</em>: Width, in bits, of the largest data access.</p>
</li>
<li><p class="first"><em>read_latency = &lt;int&gt;</em>:  Read latency in cycles.  Default is 1.</p>
</li>
<li><p class="first"><em>write_latency = &lt;int&gt;</em>:  Write latency in cycles.  Default is 1.</p>
</li>
<li><p class="first"><em>max_requests = &lt;int&gt;</em>:  Maximum number of pending requests.  Default is 1.</p>
</li>
<li><p class="first"><em>allow_bus_wait = &lt;bool&gt;</em>: True if the memory can have a request waiting on
the "bus" if the request queue is full.  Default value is <tt class="docutils literal"><span class="pre">true</span></tt>.</p>
<p>uADL does not explicitly model buses, so this merely provides one additional
request buffer space.  A request under bus-waiting status is not processed
until it is moved into the request queue.</p>
</li>
<li><p class="first"><em>preemptive = &lt;bool&gt;</em>: A preemprive memory gives higher priority to
loads/stores over instruction fetches.  Specifically, when the pipeline tries
to send a read/write request to the memory, and the memory has no space to
receive new requests, if the last request is a fetch and has not been "taken"
by the memory, then the memory will accept the read/write request and let it
"preempt" (in other words, overwrite) the last fetch request.  The fetch unit
then needs to re-send the preempted request.</p>
<p>A request is considered "taken" if it is in the request queue, hence only a
fetch request that is waiting on the bus can be preempted.  So a preemptive
memory must have allow_bus_wait set to true.  There are two limitations on
defining a memory to be preemptive.  A preemptive memory must be a unified
memory, i.e., it cannot be instruction-only or data-only memory.  A preemptive
memory must be the first-level memory in the memory system, i.e., the closest
to the pipeline.  If preemptive is set to true but the memory does not meet
these requirements or has allow_bus_wait set to false, the preemptive
attribute is ignored.</p>
<p>The default is non-preemptive.</p>
</li>
<li><p class="first"><em>read_only = &lt;bool&gt;</em>:  True if read-only.  Default value is <tt class="docutils literal"><span class="pre">false</span></tt>.</p>
</li>
</ul>
</div>
<div class="section" id="id8">
<h5><a class="toc-backref" href="#id44" name="id8">2.4.5.2&nbsp;&nbsp;&nbsp;Interface Methods</a></h5>
<dl class="docutils">
<dt><em>bool request_queue_empty()</em>:</dt>
<dd>Returns true if the memory has no active/pending memory requests.  Returns
false otherwise.</dd>
<dt><em>bool is_inactive()</em>:</dt>
<dd>Returns true if the memory has had no activity for this cycle.  For example,
<tt class="docutils literal"><span class="pre">request_queue_empty</span></tt> might return true if a fetch transaction completed in
this cycle, whereas this would return false, since there was activity during
the cycle.</dd>
<dt><em>bool can_request_read()</em>:</dt>
<dd>Returns true if the memory can accept a read request.</dd>
<dt><em>bool can_request_write()</em>:</dt>
<dd>Returns true if the memory can accept a write request.</dd>
<dt><em>bool can_read()</em>:</dt>
<dd>Returns true if the memory can accept a read.</dd>
<dt><em>bool can_write()</em>:</dt>
<dd>Returns true if the memory can accept a write.</dd>
<dt><em>bool can_accept_read_request()</em>:</dt>
<dd>Returns true if the cache can accept additional read requests.</dd>
<dt><em>bool can_accept_write_request()</em>:</dt>
<dd>Returns true if the cache can accept additional write requests.</dd>
<dt><em>void send_read_request([unsigned num_bytes])</em>:</dt>
<dd>Send a read request to memory.  This transaction requires that the request
address is already calculated, so <tt class="docutils literal"><span class="pre">exec()</span></tt> must already have been called.
The size is normally set by the instruction's functional behavior.  However,
in some circumstances, the user will want to override this default size, in
order to fetch a larger chunk of memory at once.  For example, a load which
fetches data in 64-bit chunks, even though the instruction acts as though it is
fetching multiple 32-bit chunks.  In this case, <em>num_bytes</em> bytes of data are
requested.</dd>
<dt><em>void send_write_request([unsigned num_bytes])</em>:</dt>
<dd>Send a write request to memory.  This transaction requires that the request
address is already calculated, so <tt class="docutils literal"><span class="pre">exec()</span></tt> must already have been called.
The size is normally set by the instruction's functional behavior.  However,
in some circumstances, the user will want to override this default size, in
order to fetch a larger chunk of memory at once.  For example, a store which
writes data in 64-bit chunks, even though the instruction acts as though it is
writing multiple 32-bit chunks.  In this case, <em>num_bytes</em> bytes of data are
sent.</dd>
<dt><em>void read()</em>: </dt>
<dd>Perform the actual read.  This is usually not explicitly called by the user,
but rather implicitly via a call to <tt class="docutils literal"><span class="pre">exec_and_read()</span></tt>.</dd>
<dt><em>post_read()</em></dt>
<dd>Must be called after the exec() call which follows the read operation.  This
is usually not explicitly called by the user, but rather implicitly via a call
to <tt class="docutils literal"><span class="pre">exec_and_read()</span></tt>.</dd>
<dt><em>void pre_write():</em></dt>
<dd>Must be called before the exec() call which precedes the memory-write
operation.  This is usually not explicitly called by the user, but rather
implicitly via a call to <tt class="docutils literal"><span class="pre">exec_and_write()</span></tt>.</dd>
<dt><em>void write():</em></dt>
<dd>Perform the actual write.  This is usually not explicitly called by the user,
but rather implicitly via a call to <tt class="docutils literal"><span class="pre">exec_and_write()</span></tt>.</dd>
<dt><em>void next():</em></dt>
<dd>If more memory was requested by the pipeline model than is used by a single
call of exec(), then this advances to the next memory to be used by the next
exec() call.  This is not normally called explicitly, but rather implicitly
via a call to <tt class="docutils literal"><span class="pre">exec_and_read()</span></tt> or <tt class="docutils literal"><span class="pre">exec_and_write()</span></tt>.</dd>
<dt><em>void set_size(unsigned num_bytes):</em></dt>
<dd>Override the current memory transaction's size. This is useful if a previous
request requested too much memory and a write will be smaller than originally
anticipated.</dd>
<dt><em>bool can_force_lock():</em></dt>
<dd>True if we can force-lock the memory.</dd>
<dt><em>void allocate_force_lock():</em></dt>
<dd>Force-lock memory.  Same as allocating a lock, but can be performed when the
memory has outstanding requests.</dd>
<dt><em>bool can_lock():</em></dt>
<dd>True if we can lock memory.</dd>
<dt><em>void allocate_lock():</em></dt>
<dd>Lock the memory for exclusive access or just to prevent accesses from other
instructions and the fetch unit.  All other memory accesses are rejected,
including loads, stores and fetches.  For an instruction to successfully lock
an unlocked memory, the memory must have no outstanding requests, i.e., its
request queue must be empty.  A locked memory can be locked again by the same
instruction who locks it, although doing that has no additional side effects.</dd>
<dt><em>bool can_unlock():</em></dt>
<dd>True if we can unlock the memory.</dd>
<dt><em>void deallocate_unlock([unsigned latency])</em>: </dt>
<dd>Unlock the memory.  If a latency/delay parameter is supplied, then the unlock
operation will be delayed by that many cycles.  For example, <tt class="docutils literal"><span class="pre">L1.unlock(1)</span></tt>
means that the L1 cache will not be unlocked until the following cycle.</dd>
<dt><em>void deallocate_force_unlock([unsigned latency]):</em></dt>
<dd>Same as deallocate_unlock.</dd>
</dl>
</div>
</div>
<div class="section" id="memory-port">
<h4><a class="toc-backref" href="#id45" name="memory-port">2.4.6&nbsp;&nbsp;&nbsp;Memory Port</a></h4>
<p>Type name: <tt class="docutils literal"><span class="pre">port</span></tt>.</p>
<p>Ports are optional and use to differentiated accesses to Memory, Cache Write
Queue memory elements. Port definitions are nested in the definition of the
memory element.</p>
<p>The connectivity of an element with ports must exlicitly refer to both a given
port and the memory element. Any access to an element with ports must obey the
same rule. Port accesses are denoted using the '.' notation.</p>
<p>Below are a typical port definition and usage:</p>
<pre class="literal-block">define(memory foo) {
    ...
  define(port I) {
        addr_bandwidth = 1;
        data_bandwidth = 1;
    read_latency = 1;
    write_latency = 1;
  }
}

define(fetchunit bar) {
  fetch_memory = foo.I;
}
</pre>
<p>in transaction:</p>
<pre class="literal-block">foo.I.send_read_request();
</pre>
<p>Parameters:</p>
<ul>
<li><p class="first"><em>type = [instr|data|unified]</em>: Specify the primary purpose of the port.  The
default is <tt class="docutils literal"><span class="pre">unified</span></tt>, meaning that the port may be used for both instruction
and data.  This option needs to be set for a Harvard architecture, where
transactions will be targeting different instruction and data memories.  The
uADL front-end enforces consistency amongst top-level memory accesses, but
allows for separate data and instruction memories.</p>
</li>
<li><p class="first"><em>allow_bus_wait = &lt;bool&gt;</em>: True if the memory can have a request waiting on
the "bus" if the request queue is full.  Default value is <tt class="docutils literal"><span class="pre">true</span></tt>.</p>
<p>uADL does not explicitly model buses, so this merely provides one additional
request buffer space.  A request under bus-waiting status is not processed
until it is moved into the request queue.</p>
</li>
<li><p class="first"><em>bandwidth = &lt;int&gt;</em>: This sets the maximum number of requests that can be
received per cycle, for both address and data.  Using this option combines
together address and data bandwidths into a single allowed bandwidth amount.</p>
</li>
<li><p class="first"><em>addr_bandwidth = &lt;int&gt;</em>: Maximum number of requests that can be received per
cycle for address handling (requests).  Default is 1.  This splits bandwidth
handling into separate address and data quantities.</p>
</li>
<li><p class="first"><em>data_bandwidth = &lt;int&gt;</em>: Maximum number of data transactions (reads/writes)
that can be done per cycle.  Default is 1.  This splits bandwidth handling
into separate address and data quantities.</p>
</li>
<li><p class="first"><em>read_latency = &lt;int&gt;</em>:  Port read latency.  Default value is 0.</p>
</li>
<li><p class="first"><em>write_latency = &lt;int&gt;</em>:  Port write latency.  Default value is 0.</p>
</li>
<li><p class="first"><em>max_request = &lt;int&gt;</em>:  Maximum number of pending requests.  Default is 1.</p>
</li>
</ul>
</div>
<div class="section" id="cache">
<h4><a class="toc-backref" href="#id46" name="cache">2.4.7&nbsp;&nbsp;&nbsp;Cache</a></h4>
<p>Type name:  <tt class="docutils literal"><span class="pre">cache</span></tt>.</p>
<p>All caches described in an architecture are automatically included in the uADL
description.  Cache blocks are thus only necessary for describing
micro-architectural parameters.</p>
<p>Below is a typical cache description:</p>
<pre class="literal-block">define (cache foo) {
       next_level_memory                   = MEM;
       write_mode                          = WriteThrough;
       addr_bandwidth                      = 1;
       data_bandwidth                      = 1;
       read_hit_latency                    = 1;
       write_hit_latency                   = 1;
       linefill_read_latency               = 1;
       linefill_write_latency              = 1;
       linefill_writeback_latency          = 0;
       linefill_lock_cycle                 = 0;
       evict_lock_cycle                    = 0;
       taken_to_write_latency              = 0;
       write_to_next_level_request_latency = 0;
       zero_latency                        = 1;
       lock_latency                        = 1;
       unlock_latency                      = 1;
       touch_latency                       = 0;
       invalidate_latency                  = 1;
       max_request                         = 1;
       allow_bus_wait                      = false;
       preemptive                          = false;
       critical_word_first                 = true;
       store_buffer_enable                 = func() { return true; };
}
</pre>
<p>Parameters:</p>
<ul>
<li><p class="first"><em>custom = ( &lt;class-name&gt; , &lt;header-file-name&gt; )</em>: A custom cache model may be
specified.  The header-file-name will be inserted as an include directive into
the resulting model and a class with the specified class-name will be
instantiated.  If a custom model is specified, then extra configuration
parameters in the cache declaration will be stored and passed to the model.
Otherwise, unrecognized parameters produce an error.</p>
</li>
<li><p class="first"><em>next_level_memory = &lt;ident&gt;</em>: The next memory in the hierarchy.  Default
value is the architectural next-level memory or cache.</p>
</li>
<li><p class="first"><em>write_mode = &lt;WriteThrough | WriteBack&gt;</em>: Write-mode for the cache.</p>
</li>
<li><p class="first"><em>addr_bandwidth = &lt;int&gt;</em>:  Maximum number of requests that can be received per cycle.
Default is 1.</p>
</li>
<li><p class="first"><em>data_bandwidth = &lt;int&gt;</em>: Maximum number of data transactions (reads/writes)
that can be done per cycle.  Default is 1.</p>
</li>
<li><p class="first"><em>read_hit_latency = &lt;int&gt;</em>:  Read hit latency, in cycles.  Default is 1.</p>
</li>
<li><p class="first"><em>write_hit_latency = &lt;int&gt;</em>:  Write hit latency, in cycles.  Default is 1.</p>
</li>
<li><p class="first"><em>linefill_access_width = &lt;int&gt;</em>: Width, in bits, of each access for a linefill
operation (loading or eviction).</p>
</li>
<li><p class="first"><em>linefill_current_access_width = func(addr_t ea,addr_t ra) {}</em>: Hook function
for dynamically specifying the width of a linefill access, in bits.  Should
return the appropriate width based upon system state, e.g. return 128 for
performing 128-bit reads during a linefill operation.</p>
</li>
<li><p class="first"><em>linefill_read_latency = &lt;int&gt;</em>: Read latency from line-fill buffer, in
cycles.  Default is 1.</p>
</li>
<li><p class="first"><em>linefill_write_latency = &lt;int&gt;</em>: Write latency from line-fill buffer, in
cycles.  Default is 1.</p>
</li>
<li><p class="first"><em>linefill_writeback_latency = &lt;int&gt;</em>: Latency from when a linefill is done,
i.e., all data in that line are read from the next-level memory, to when the
data are ready for read from the data array.  Default is 0.</p>
</li>
<li><p class="first"><em>linefill_lock_cycle = &lt;int&gt;</em>: Number of cycles during which the cache cannot
do lookup after a linefill is initiated.  Default is 0.</p>
</li>
<li><p class="first"><em>linefill_lock_holdoff_cycle = &lt;int&gt;</em>: Number of cycles from start of line-fill
operation until the linefill lock is applied.  This allows the user to model
situations such as where the critical-word forwarding means that the first
access from a new linefill operation is available immediately, but that the
next data may be delayed due to cache maintenance operations.</p>
<p>The default is 1, meaning that if there is a lock cycle count, it is applied
on the first cycle after the initiation of a linefill.</p>
</li>
<li><p class="first"><em>linefill_lazy_writeback = &lt;bool&gt;</em>: If true, then linefill writeback
operations occur when a new linefill operation is requested and the existing
linefill is valid.  Otherwise, the linefill writeback occurs upon completion
of the linefill operation.  The default is false.</p>
</li>
<li><p class="first"><em>linefill_lock_on_valid = &lt;bool&gt;</em>: If true, then linefill lock cycles only
occur if a linefill was previously valid.  Otherwise, lock cycles always
occur.  The default is false.</p>
</li>
</ul>
<a id="block-on-critical-word"></a><ul class="simple">
<li><em>block_on_critical_word = &lt;true|false|serialized&gt;</em>:  Block a request if a
critical word is received.  If set to <tt class="docutils literal"><span class="pre">serialized</span></tt>, then this is only done
if the current request is serialized.  This behavior applies to the
<a class="reference" href="#linefill-block-inquire">linefill_block_inquire</a> transaction.</li>
<li><em>consecutive_linefills = &lt;bool&gt;</em>: If true, the first request of a pending
linefill will be issued before the current linefill has received all of its
data.  All requests for the current linefill must have already been sent for
this to occur.  This enables consecutive linefills to occur without any
delays.  The default is false.</li>
<li><em>evict_lock_cycle = &lt;int&gt;</em>: Additional number of cycles during which the cache
cannot do lookup after a linefill is initiated, if the linefill is accompanied
by an eviction.  Default is 0.</li>
<li><em>taken_to_write_latency = &lt;int&gt;</em>: Minimal latency from when a write request is
taken to when the data can be written.  Default is 0.</li>
<li><em>write_to_next_level_request_latency = &lt;int&gt;</em>: For a write that is
write-through, this parameter specifies the minimal latency from when the data
is written to when the write request to the next-level memory can be sent.
Default is 0.</li>
<li><em>zero_latency = &lt;int&gt;</em>:  Cache line zero latency in cycles.
Default is 1.</li>
<li><em>lock_latency = &lt;int&gt;</em>:  Cache line lock latency in cycles.
Default is 1.</li>
<li><em>unlock_latency = &lt;int&gt;</em>:  Cache line unlock latency in cycles.
Default is 1.</li>
<li><em>touch_latency = &lt;int&gt;</em>:  Cache line touch latency in cycles.
Default is 0.</li>
<li><em>invalidate_latency = &lt;int&gt;</em>:  Cache line invalidate latency in cycles.
Default is 1.</li>
<li><em>max_request = &lt;int&gt;</em>:  Maximum number of pending requests.  Default is 1.</li>
<li><em>allow_bus_wait = &lt;bool&gt;</em>: See the same Memory parameter.</li>
<li><em>preemptive = &lt;bool&gt;</em>: See the same Memory parameter.</li>
<li><em>critical_word_first = &lt;bool&gt;</em>:  Load from the critical word (true) or from
the beginning of the cache line (false).  Default is <tt class="docutils literal"><span class="pre">true</span></tt>.</li>
<li><em>store_buffer_enable = func() {}</em>:
A boolean predicate which specifies whether or not the store buffer is enabled.
This may reference any architectural resource, such as registers.</li>
<li><em>store_buffer_size = &lt;int&gt;</em>:
Store buffer maximum size.</li>
<li><em>streaming_linefill = &lt;bool&gt;</em>:
Enable streaming linefill.</li>
</ul>
<div class="section" id="id9">
<h5><a class="toc-backref" href="#id47" name="id9">2.4.7.1&nbsp;&nbsp;&nbsp;Interface Methods</a></h5>
<p>Caches are derived from memories and thus inherit all memory interface methods.</p>
<dl class="docutils">
<dt><em>bool can_request_cmd()</em>:</dt>
<dd>True if the cache can accept a cache command, such as a fill, allocate, zero,
etc. command.</dd>
<dt><em>void send_cmd()</em>: </dt>
<dd>Send the actual cache command.</dd>
<dt><em>cmds_done()</em>:</dt>
<dd>Stall (return false) until the last cache command sent to the cache is
completed.</dd>
<dt><em>store_buf_done()</em>:</dt>
<dd>Stall (return false) until all store buffer entries for the current
instruction have completed.</dd>
</dl>
<a id="linefill-block-inquire"></a><dl class="docutils">
<dt><em>linefill_block_inquire(name)</em>:</dt>
<dd>Stall the instruction if the cache is blocking requests due to the
<a class="reference" href="#block-on-critical-word">block_on_critical_word</a> parameter being set.</dd>
</dl>
</div>
</div>
<div class="section" id="semaphores">
<h4><a class="toc-backref" href="#id48" name="semaphores">2.4.8&nbsp;&nbsp;&nbsp;Semaphores</a></h4>
<p>Type name:  <tt class="docutils literal"><span class="pre">semaphore</span></tt>.</p>
<p>These resources can be used as either counting semaphores or as a general
counter for communicating across instructions. When used as a semaphore, the
user declares a maximum value for the semaphore in the resource declaration. The
instruction class can query to see if the current value is less than this
maximum and then acquire (increment) the semaphore or release (decrement) the
semaphore.</p>
<div class="section" id="id10">
<h5><a class="toc-backref" href="#id49" name="id10">2.4.8.1&nbsp;&nbsp;&nbsp;Parameters</a></h5>
<ul class="simple">
<li><em>count = &lt;int&gt;</em>: Maximum semaphore value (when the semaphore is considered
fully reserved). Default is 1.</li>
</ul>
</div>
<div class="section" id="id11">
<h5><a class="toc-backref" href="#id50" name="id11">2.4.8.2&nbsp;&nbsp;&nbsp;Interface Methods</a></h5>
<dl class="docutils">
<dt><em>bool can_allocate()</em>: </dt>
<dd>Returns true if the semaphore is available.</dd>
<dt><em>bool check_allocate()</em>:</dt>
<dd>Same as <tt class="docutils literal"><span class="pre">can_allocate()</span></tt>, except that it does not log a return of false as a
stall.  This is useful for when a semaphore is used to communicate between
instruction classes and not directly for flow-control purposes.</dd>
<dt><em>void allocate()</em>: </dt>
<dd>Increment the semaphore.</dd>
<dt><em>void deallocate()</em>: </dt>
<dd>Decrement the semaphore.</dd>
<dt><em>unsigned count()</em>: </dt>
<dd>Return the current semaphore value.</dd>
</dl>
</div>
</div>
<div class="section" id="flags">
<h4><a class="toc-backref" href="#id51" name="flags">2.4.9&nbsp;&nbsp;&nbsp;Flags</a></h4>
<p>Type name:  <tt class="docutils literal"><span class="pre">flag</span></tt>.</p>
<p>A flag is similar to a semaphore with a count of 1, except that the flag may be
deallocated such that it becomes available only in the future. This allows an
instruction to affect other instructions even though it may have been committed.</p>
<div class="section" id="id12">
<h5><a class="toc-backref" href="#id52" name="id12">2.4.9.1&nbsp;&nbsp;&nbsp;Interface Methods</a></h5>
<dl class="docutils">
<dt><em>bool can_allocate()</em>: </dt>
<dd>Returns true if the flag is available.</dd>
<dt><em>bool check_allocate()</em>:</dt>
<dd>Same as <tt class="docutils literal"><span class="pre">can_allocate()</span></tt>, except that it does not log a return of false as a
stall.  This is useful for when a flag is used to communicate between
instruction classes and not directly for flow-control purposes.</dd>
<dt><em>void allocate():</em></dt>
<dd>Allocate the flag.</dd>
<dt><em>void deallocate(int delay = 0)</em>: </dt>
<dd>Release the flag. If a delay is specified, then the flag will be released
<tt class="docutils literal"><span class="pre">delay</span></tt> cycles in the future. A value of 0 means that the flag is released
immediately.</dd>
</dl>
</div>
</div>
<div class="section" id="custom-resources">
<h4><a class="toc-backref" href="#id53" name="custom-resources">2.4.10&nbsp;&nbsp;&nbsp;Custom Resources</a></h4>
<p>Type name:  <tt class="docutils literal"><span class="pre">custom</span></tt>.</p>
<p>The user may specify custom resource objects using a custom define block. The
header file and type name may be specified, along with arguments. These
arguments will be used as template or constructor arguments- the class is parsed
in order to determine what parameters exist. Any template or constructor
argument with no default value must have an argument specified in the <strong>args</strong>
define within the custom define, except for built-in template parameters. These
are:</p>
<ul class="simple">
<li><strong>ModelType</strong>: Automatically set to the uADL model type.</li>
<li><strong>InstrType</strong>: Automatically set to the uADL instruction packet type.</li>
</ul>
<p>The basic idea with the argument handling is that the user can start with a
non-template class, where all arguments are constructor arguments, then create a
template class, in order to improve performance, by converting constructor
arguments to template arguments as appropriate.</p>
<p>All custom resources must take at least one constructor argument, which is
assigned a reference to the uADL model. The base class for this is <tt class="docutils literal"><span class="pre">Timer</span></tt> and
allows the custom resource to install itself as a dynamic parameter handler.
All custom resources must also derive from the class <tt class="docutils literal"><span class="pre">Resource</span></tt>, which provides
an interface for various low-level activities such as logging control.</p>
<p>Within instruction class code, the user may call any class method. However, any
method called must conform to the basic interface of all resource methods:</p>
<pre class="literal-block">method(ModelType &amp;,InstrType &amp;,uadl::Logger *, [args...] );
</pre>
<p>For classes which are not templates and do not need access to specifics of the
model or instruction packet, <tt class="docutils literal"><span class="pre">UadlArch</span></tt> may be used in place of <tt class="docutils literal"><span class="pre">ModelType</span></tt> and
<tt class="docutils literal"><span class="pre">InstrBase</span></tt> may be used in place of <tt class="docutils literal"><span class="pre">InstrType</span></tt>.</p>
<p>If the class contains the methods <tt class="docutils literal"><span class="pre">preCycle</span></tt>, <tt class="docutils literal"><span class="pre">postCycle</span></tt>, or <tt class="docutils literal"><span class="pre">postSim</span></tt>,
then calls to these methods will be made at the appropriate times in the model,
e.g. at the beginning of each cycle, at the end of each cycle, and at the end of
simulation.</p>
<div class="section" id="id13">
<h5><a class="toc-backref" href="#id54" name="id13">2.4.10.1&nbsp;&nbsp;&nbsp;Parameters</a></h5>
<ul class="simple">
<li><em>header = &lt;str&gt;</em>: Specify the header file name for this custom
resource. Defaults to <tt class="docutils literal"><span class="pre">name.h</span></tt>, where name is the custom resource's name. The
file is searched for in the current directory, then in any additional
directories specified using the <strong>--include</strong> or <strong>-I</strong> command-line options.</li>
<li><em>type = &lt;str&gt;</em>: Specify the type name of the custom resource class. Defaults
to <tt class="docutils literal"><span class="pre">name_t</span></tt>.</li>
<li>Definition: <em>args</em>: Each key/value pair within this block is considered an
argument for the custom resource. Both template and constructor arguments will
be searched.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="the-machine-section">
<h3><a class="toc-backref" href="#id55" name="the-machine-section">2.5&nbsp;&nbsp;&nbsp;The Machine Section</a></h3>
<p>Type name:  <tt class="docutils literal"><span class="pre">machine</span></tt>.</p>
<p>The machine section defines the states of the finite state machine
representation of the pipeline and their mappings to pipeline stages.  Multiple
states may be mapped to a single pipeline stage</p>
<p>Below is an example of machines defined on a four-stage pipeline:</p>
<pre class="literal-block">define (machine normal) {
  init_state = S_INIT;
  states = ( S_ID, S_IDe, S_EX, S_EXp, S_EXe, S_MM, S_MMp, S_MMe, S_WB, S_WBp, S_WBe );

  // Maps states to stages.
  define (mapping) {
    mID = (S_ID,S_IDe);
    mEX = (S_EX,S_EXp,S_EXe);
    mMM = (S_MM,S_MMp,S_MMe);
    mWB = (S_WB,S_WBp,S_WBe);
  };

  // Defines the state transition on an exception:
  //  Lhs:  exception state.
  //  Rhs:  states which might generate an exception.
  define (exception_mapping) {
    S_IDe = S_ID;
    S_EXe = S_EX;
    S_MMe = S_MM;
    S_WBe = S_WB;
 }
}
</pre>
<p>Parameters:</p>
<a id="init-state"></a><ul>
<li><p class="first"><em>init_state = &lt;ident&gt;</em>:  The name of the initial state.</p>
</li>
<li><p class="first"><em>states = &lt;list(ident)&gt;</em>:  Names of states in the machine.</p>
</li>
<li><p class="first">Definition: <em>mapping</em>:  Defines the mapping of pipeline stages to states.  The
right-hand-side of each statement is a pipeline stage and the left-hand side
is a state or list of states:</p>
<pre class="literal-block">&lt;pipeline-stage&gt; = state | list(states);
</pre>
</li>
<li><p class="first">Definition: <em>exception_mapping</em>: Maps states to exception-states.  When an
exception occurs in a state, the finite-state machine will transition to the
specified exception state.  The right-hand-side of each statement is an
exception state and the left-hand-side is a non-exception state or list of
non-exception states:</p>
<pre class="literal-block">&lt;exception-state&gt; = state | list(states);
</pre>
</li>
</ul>
</div>
<div class="section" id="the-instruction-class-section">
<h3><a class="toc-backref" href="#id56" name="the-instruction-class-section">2.6&nbsp;&nbsp;&nbsp;The Instruction Class Section</a></h3>
<p>Type name:  <tt class="docutils literal"><span class="pre">instr_class</span></tt>.</p>
<p>The instruction class section defines instruction classes.  An instruction class
is a group of instructions with identical timing behavior.</p>
<p>An instruction class definition consists of an instruction list, an operands
section, an interface-function section, and an action section.  The instruction
list lists all instructions that belong to this instruction class.  The operand
section describes the operands which will be used within the action section and
maps these to register resources.  The action section associate each state to
code to be executed.</p>
<p>An instruction class bound to a finite state machine defined in the machine
section is called an operation state machine (OSM).</p>
<p>An explicit machine binding is not necessary if only one machine is defined for
the core.</p>
<p>Below is a sample instruction class definition:</p>
<pre class="literal-block">define (instr_class sfx) {
  instructions = ( add, addi );

  machine = normal;

  attrs = sfx_instrs;

  define (operands) {
    Src = sources;
    Trg = targets;
  };

  action = {
  S_INIT: { 
    change_state(S_ID); 
  };
  S_ID:  if (Src.can_read_fp(FwdEX,FwdMM) &amp;&amp; Trg.can_write() &amp;&amp; mEX.has_space()) {
      Src.read(FwdEX,FwdMM);
      Trg.allocate();
      change_state(S_EX);
    }
  // No space-check, so one will be inserted.
  S_EX: {
    exec();
    FwdEX.write(Trg);
    change_state(S_MM);
  }
  S_MM: { 
    FwdMM.write(Trg);
    change_state(S_WB); 
  }
  S_WB: {
    write_ops();
    change_state(S_INIT);
  }
  };
}
</pre>
<p>The heart of the model is the <strong>action</strong> section of the instruction classes;
this is where the timing behavior of all instructions is described.  It takes
the form of a block of C++ code, where each state is identified by a label.  The
relevant code must then follow the label and be enclosed in either a
brace-delimited block or an if-then-else conditional.</p>
<p>Resources declared in the <tt class="docutils literal"><span class="pre">resources</span></tt> section or implicitly imported from the
functional model may be referenced by name.  For example, a pipeline stage may
simply be referred to using the name of the stage.  The special variable <tt class="docutils literal"><span class="pre">top</span></tt>
may be used to refer to the top architecture block, in the case of a
multi-threaded model.  This allows code to refer to other threads' private
resources.  For example, to check if the second thread in a two-thread core has
any instructions in its <tt class="docutils literal"><span class="pre">mIF</span></tt> stage:  <tt class="docutils literal"><span class="pre">top.t1.mIF.size()</span> <span class="pre">!=</span> <span class="pre">0</span></tt>.</p>
<p>When a <strong>defmod</strong> block is used to modify an action definition, replacement
occurs on a per-state basis.  For example, consider the code above.  A
<strong>defmod</strong> block may replace just the S_ID state as follows:</p>
<pre class="literal-block">defmod (instr_class sfx) {
  action = {
  S_ID:  if (Src.can_read_fp(FwdEX,FwdMM) &amp;&amp; Trg.can_write() &amp;&amp; mEX.has_space() &amp;&amp; all_stall.can_allocate()) {
      Src.read(FwdEX,FwdMM);
                              Trg.allocate();
                              change_state(S_EX);
    }
  }
}
</pre>
<p>In this example, just the S_ID state was modified, adding an additional inquiry
to a flag called <strong>all_stall</strong>.</p>
<p>The behavior of each state action follows an inquire/action format: The code
checks to see if certain actions may be taken, then performs those actions if
allowed.  For example, an instruction in the decode stage might check to make
sure that source registers may be read and that there is space in the next
stage.  If this is the case, then the action will be to read the relevant
registers and transition to a state mapped to the next stage.  All transitions
to other states are handled explicitly via calls to the <tt class="docutils literal"><span class="pre">change_state()</span></tt>
function.</p>
<p>If the action code does not contain an outer conditional than an implicit
conditional is inserted which checks to make sure that there is space in the
stage which corresponds to the state identified by a <tt class="docutils literal"><span class="pre">change_state</span></tt> call.  If
the action code does contain a conditional, then the user must explicitly insert
a space check via a call to <tt class="docutils literal"><span class="pre">has_space()</span></tt> or <tt class="docutils literal"><span class="pre">empty()</span></tt>.</p>
<p>All action code must contain at least one call to <tt class="docutils literal"><span class="pre">change_state</span></tt> so that the
instruction may progress through the pipeline.  The instruction is retired upon
a transition back to the initial state.  An instruction executes action code in
the current cycle as long as it does not change to a state mapped to a different
pipeline stage.  In other words, if an instruction is in state <strong>S1</strong> and
changes to <strong>S2</strong>, then <strong>S2</strong> action code will be executed if those <strong>S1</strong> and
<strong>S2</strong> map to the same state.  Refer to the <a class="reference" href="#osm-definition">OSM Definition</a> section for an
example of how this can be useful.</p>
<div class="section" id="the-repeat-label">
<h4><a class="toc-backref" href="#id57" name="the-repeat-label">2.6.1&nbsp;&nbsp;&nbsp;The Repeat Label</a></h4>
<p>If a statement in action code is labeled with <strong>Repeat</strong>, then if the action is
associated with <a class="reference" href="#lock-step">lock_step</a> scheduling, the statement will be repeated each
cycle that the instruction remains in the same state due to a stall caused by
another instruction in the same stage.</p>
<p>In lock-step scheduling, all instructions in a stage move together.  By default,
each instruction that is capable of moving executes its action code, then
changes its action to a special null-action which simply returns true.  Each
cycle after that, if another instruction stalls, the instruction which is
capable of moving simply does nothing.  This can be problematic, for example, if
an instruction should repeatedly broadcast a result on a forwarding path.  The
<strong>Repeat</strong> label causes these actions to be repeated for each cycle that an
instruction is stalled in a stage due to another instruction.</p>
<p>For example, to repeatedly write to a forwarding path called <tt class="docutils literal"><span class="pre">FwdMM</span></tt>:</p>
<pre class="literal-block">S_MM: {
  Repeat: FwdMM.write(Trg);
  change_state(S_MM);
}
</pre>
<p>Statements with the <strong>Repeat</strong> label are meant to be relatively simple.
Exceptions are not handled and interaction with the ISS should be avoided.</p>
</div>
<div class="section" id="operands">
<h4><a class="toc-backref" href="#id58" name="operands">2.6.2&nbsp;&nbsp;&nbsp;Operands</a></h4>
<p>The syntax for interacting with register, register-files, and immediate values
is encapsulated within operands.  These are declared using a <strong>define</strong> block:</p>
<pre class="literal-block">define (instr_class foo) {
  define (operands) {
    Src1 = GPR(RA);
    Src2 = (GPR(RB));
  }
}
</pre>
<p>These operands can then be used in the action code by calling various methods,
e.g. <tt class="docutils literal"><span class="pre">can_read()</span></tt>, <tt class="docutils literal"><span class="pre">read()</span></tt>, etc. For each operand, if it is just an
immediate value, then a stub is substituted which, for example, returns true if
an inquiry is made to see if it is readable.</p>
<p>If an instruction contains extra operands not listed by the operands in an
instruction class, then an error is produced, unless <strong>allow_missing_operands</strong>
(default is false) is set to true, in which case a stub operand is used. If an
instruction does not use a listed operand, then an error is produced if
<strong>allow_extra_operands</strong> is false (default is true). In other words, by default, all
register resources must be covered by the listed operands, but extras are
allowed (they will just map to stubs).</p>
<p>Any sources or targets not specified are grouped into an "other" class. This
"other" class is handled by default when <tt class="docutils literal"><span class="pre">can_read_operands()</span></tt> and <tt class="docutils literal"><span class="pre">read_operands()</span></tt>
are called, which are special functions which test and read all operands for the
instruction.</p>
<p>The basic syntax of each right-hand-side element is:</p>
<ul class="simple">
<li><em>register[(source-mask)]</em></li>
<li><em>register-file</em></li>
<li><em>register-file(Instruction-Field | Integer)[(source-mask)]</em></li>
<li><em>field(name)</em></li>
<li><em>&lt;int&gt;</em></li>
</ul>
<p>To add multiple items to an operand, simply repeat it, e.g.:</p>
<pre class="literal-block">define (operands) {
  Flags = CR;
  Flags = XER;
}
</pre>
<p>In the case of simply specifying a register-file, testing and reading the
operand results in testing and reading all operands in the instruction which
refer to that register file.</p>
<p>An immediate operand may be created using the <tt class="docutils literal"><span class="pre">field(name)</span></tt> syntax,
e.g. <tt class="docutils literal"><span class="pre">field(D)</span></tt> for a PowerPC <tt class="docutils literal"><span class="pre">lwz</span></tt> instruction.  This is generally only
required when the operand's value needs to be directly queried.</p>
<p>A constant value operand may be created by using the <tt class="docutils literal"><span class="pre">&lt;int&gt;</span></tt> syntax.  This
operand will always return this value when its <tt class="docutils literal"><span class="pre">value()</span></tt> or <tt class="docutils literal"><span class="pre">field_value()</span></tt>
method is called.  Since missing (dummy) operands always return a value of 0 for
<tt class="docutils literal"><span class="pre">value()</span></tt> and <tt class="docutils literal"><span class="pre">field_value()</span></tt>, using such an operand as a flag only requires
that the non-zero operand be specified.  This format is useful when combined
with per-instruction operand overrides: The instruction class may use the
operand within a test to select between two different behaviors.</p>
<p>Note that it is legal for an operand to have the same name as a register,
e.g. CR = CR. However, operands take precedence over registers when encountered
in action code. As in ADL, the user may access registers directly in the code,
but these always use architected state. Thus, it is only valid to query overall
processor state registers.</p>
<p>When the user wants to use the same instruction class, but there is ambiguity
between instruction fields for different registers, then operands may be
assigned based on specific instructions. For example, in PowerPC, <tt class="docutils literal"><span class="pre">add</span></tt> and
<tt class="docutils literal"><span class="pre">or</span></tt> are both simple fixed-point instructions which conceivably might have the
same timing and thus would use the same instruction class. However, the <tt class="docutils literal"><span class="pre">add</span></tt> target
is <tt class="docutils literal"><span class="pre">GPR(RT)</span></tt> and its sources are <tt class="docutils literal"><span class="pre">GPR(RA)</span></tt> and <tt class="docutils literal"><span class="pre">GPR(RB)</span></tt>, whereas the <tt class="docutils literal"><span class="pre">or</span></tt> target is
<tt class="docutils literal"><span class="pre">GPR(RA)</span></tt> and its sources are <tt class="docutils literal"><span class="pre">GPR(RS)</span></tt> and <tt class="docutils literal"><span class="pre">GPR(RB)</span></tt>. This could be encoded as
follows:</p>
<pre class="literal-block">define (instr=(add,addi)) {
  define (operands) {
    Src1 = GPR(RA);
    Src2 = GPR(RB);
    Trg  = GPR(RT);
  };
}

define (instr=(or,ori)) {
  define (operands) {
    Src1 = GPR(RS);
    Src2 = GPR(RB);
    Trg  = GPR(RA);
  };
}
</pre>
<p>If an instruction is not listed, then the default operand block is used (the
outer-operand block directly within the instruction-class definition). When
searching for matching operands, the search will start with an
instruction-specific operand block and then check the default, outer block.</p>
<p>Another way to accomplish the above is to use the special keywords <tt class="docutils literal"><span class="pre">sources</span></tt> and
<tt class="docutils literal"><span class="pre">targets</span></tt> to indicate that an operand represents all sources or all targets of an
instruction, regardless of name. For example:</p>
<pre class="literal-block">define (operands) {
  Src = sources;
  Trg = targets;
}
</pre>
<p>By default, partial usage masks are extracted from ADL. Should a situation arise
where this is not correct. e.g. a version of a function exists which only
accesses part of a register, but ADL cannot detect that statically, a mask may
be specified using a pair notation:</p>
<pre class="literal-block">define (operands) {
  Src = (Foo,0xf0000000);
}
</pre>
<p>Here, the <strong>Src</strong> operand contains the register <strong>Foo</strong>, where only the top 4
bits matter.</p>
<p>In some cases, it may be necessary to use a source mask, even though the entire
register is being accessed. This can be the case when a class of instructions
performs a whole access, but the source register is partially updated by other
instructions. An example of this is the PowerPC condition register (CR). The
conditional branch, <tt class="docutils literal"><span class="pre">bc</span></tt>, instruction must read the entire register, but some
instructions, such as <tt class="docutils literal"><span class="pre">addic.</span></tt>, updates only the first nibble. In order for the
branch to be able to partially read the first nibble from a forwarding path,
then read the rest from the actual register, the mask must be specified in order
to force uADL to treat this as a partial access.</p>
<p>An explicit target or source specifier may also be used. This may be useful when
a single instruction field is used as both a source and a target. For example:</p>
<pre class="literal-block">define (operands) {
  Src = (GPR(RT),source);
  Trg = (GPR(RT),target);
}
</pre>
<p>This may also be combined with a mask:</p>
<pre class="literal-block">define (operands) {
  Src = (GPR(RT),source,0x0000000f);
}
</pre>
<p>This is technically redundant, since only sources may have masks.</p>
<p>It is also possible to force a register to be a source or target, even if the instruction
does not use it, in order to model a false dependency.  This is done via the
<tt class="docutils literal"><span class="pre">force_source</span></tt> and <tt class="docutils literal"><span class="pre">force_target</span></tt> specifiers, e.g.:</p>
<pre class="literal-block">define (operands) {
  FalseSrc1 = (CR,force_source);
  FalseSrc2 = (XER,force_source,0xf0000000);
}
</pre>
<p>The operand can then be used for flow-control purposes via the use of the
<tt class="docutils literal"><span class="pre">can_read</span></tt> and <tt class="docutils literal"><span class="pre">can_read_fp</span></tt> methods.</p>
</div>
<div class="section" id="interface-functions">
<h4><a class="toc-backref" href="#id59" name="interface-functions">2.6.3&nbsp;&nbsp;&nbsp;Interface Functions</a></h4>
<p>Interface functions make it possible to have an instruction class call different
helper functions depending upon what instruction the instruction class
represents.  For example, given an instruction class for cache operations, the
class can call an instruction cache checking function for all instruction cache
instructions and a data cache checking function for all data cache instructions.</p>
<p>The syntax consists of a define block called <tt class="docutils literal"><span class="pre">functions</span></tt>, within which are
listed key/value pairs, where the key is the name of the function called by the
instruction class and the value is the name of a helper function which will be
called.  Per-instruction overrides, using <tt class="docutils literal"><span class="pre">instr</span></tt> blocks may be used to
specify different functions to be called for different instructions.  An
outer-block, declared directly in the instruction class define, acts as a
default.  For the set of interface functions declared in an instruction class,
all instructions must define the actual helper function which will be called.
In other words, a default behavior, as exists for operands, does not exist for
interface functions.</p>
<p>An example of usage is as follows:</p>
<pre class="literal-block">bool l1d_check_cache(InstrType &amp;instr,Logger *logger)
{
  return L1d.can_request_read(thisCore(),instr,logger) &amp;&amp; L1d.linefill_not_blocked(thisCore(),instr,logger);
}

bool l1i_check_cache(InstrType &amp;instr,Logger *logger)
{
  return L1i.can_request_read(thisCore(),instr,logger) &amp;&amp; L1i.linefill_not_blocked(thisCore(),instr,logger);
}

define (instr_class=cache_ops) {

  instrs = (dcbt,dcbf,dcbi,icbt,icbi);

  define (functions) {
    check_cache = l1d_check_cache;
  }

  define (instr=(icbt,icbi)) {
    define (functions) {
      check_cache = l1i_check_cache;
    }
  }

  action = {
    ...
    S_Decode: if (mEX.has_space() &amp;&amp; check_cache(thisInstr(),logger)) { ... }
    ...
  };

}
</pre>
<p>In the example above, all data-cache instructions (<strong>dcbt</strong>, <strong>dcbf</strong>, and
<strong>dcbi</strong>) will call <tt class="docutils literal"><span class="pre">l1d_check_cache</span></tt> when the function <tt class="docutils literal"><span class="pre">check_cache</span></tt> is
called in the instruction class's action code, whereas the instruction-cache
instructions (<strong>icbt</strong> and <strong>icbi</strong>) will invoke <tt class="docutils literal"><span class="pre">l1i_check_cache</span></tt>.</p>
</div>
<div class="section" id="id14">
<h4><a class="toc-backref" href="#id60" name="id14">2.6.4&nbsp;&nbsp;&nbsp;Parameters</a></h4>
<ul>
<li><p class="first">Definition: <em>operands</em>: Declare operands.  Refer to the <a class="reference" href="#operands">Operands</a> section
for more information.</p>
</li>
<li><p class="first">Definition: <em>instr = &lt;name&gt;</em>:  Allows for the grouping of operands by instruction,
within an instruction class.  The contents of this definition is an
<tt class="docutils literal"><span class="pre">operands</span></tt> define block, which is then applied to the listed instructions.
For example:</p>
<pre class="literal-block">define (instr_class sfx) {
  instructions = (add,or,subf);

  define (instr=(add,subf) {
    define (operands) {
      Src1 = GPR(RA);
      ...
    }
  }

  define (instr=or) {
    define (operands) {
      Src1 = GPR(RS);
      ...
    }
  }

  ...
}
</pre>
<p>In the above example, the <tt class="docutils literal"><span class="pre">or</span></tt> instruction will have <strong>Src1</strong> mapped to
<tt class="docutils literal"><span class="pre">GPR(RS)</span></tt> while <tt class="docutils literal"><span class="pre">add</span></tt> and <tt class="docutils literal"><span class="pre">subf</span></tt> have <strong>Src1</strong> mapped to <tt class="docutils literal"><span class="pre">GPR(RA)</span></tt>.</p>
</li>
<li><p class="first"><em>attrs = &lt;ident | list(ident)&gt;</em>: Specify one or more attributes to be
associated with the instruction class.  These attributes may be queried by
other instruction classes via <tt class="docutils literal"><span class="pre">PipelineStage::has_attr()</span></tt> in order to make
scheduling decisions, such as to decide whether an instruction may be issued
in parallel with another.</p>
</li>
<li><p class="first"><em>allow_missing_operands = &lt;bool&gt;</em>: If true, then an error will not be produced
if any of the listed instructions contain register resources not mapped to
operands.  This should generally not be used, but may be useful for
prototyping.</p>
</li>
<li><p class="first"><em>allow_extra_operands = &lt;bool&gt;</em>: If an instruction does not use a listed
operand, then an error is produced if <strong>allow_extra_operands</strong> is false (default
is true).</p>
</li>
<li><p class="first"><em>commit_on_exception = &lt;bool&gt;</em>: This controls whether an exception's actions
should be taken immediately when the exception occurs, or whether the user
will explicitly control the behavior.  If true, then the model automatically
generates calls to <tt class="docutils literal"><span class="pre">commit_exceptions</span></tt> and <tt class="docutils literal"><span class="pre">flush</span></tt> on the state transition
to an exception state.  The default is true.  This overrides the core-level
default value.</p>
</li>
<li><p class="first"><em>instructions = &lt;list(ident|ident(ident(int)[,...]))&gt;</em>: List of instructions
in the architecture.  Unknown instructions produce a warning, but processing
proceeds.  The elements of the list may be either identifiers, strings, or
function-calls.</p>
<p>If the latter, the function-name identifies the instruction and each argument
is of the form <tt class="docutils literal"><span class="pre">field(value)</span></tt>, where <tt class="docutils literal"><span class="pre">field</span></tt> is an operand instruction
field that is valid for the instruction and <tt class="docutils literal"><span class="pre">value</span></tt> is an integer value.
This form allows the user to constrain instructions to have specific operand
values in order to be considered part of the instruction class.  For example,
a <tt class="docutils literal"><span class="pre">mtspr</span></tt> instruction with an <tt class="docutils literal"><span class="pre">SPRN</span></tt> value of 60 might need special
behavior, such as cache serialization.  The syntax for this would be:</p>
<pre class="literal-block">instructions = mtspr(SPRN(60));
</pre>
</li>
<li><p class="first"><em>instr_attrs = &lt;ident | list(ident)&gt;</em>: This allows instruction classes to
select instructions based upon ADL attributes.  Any instruction containing one
or more of the listed attributes will be added to the instruction class.</p>
</li>
<li><p class="first"><em>machine = &lt;ident&gt;</em>:  Identifies the machine associated with this instruction
class.  This must be a valid machine name.  This is not required if only one
machine is defined for the core.</p>
</li>
<li><p class="first"><em>action = &lt;block&gt;</em>: As described above, the <strong>action</strong> key defines the
pipeline semantics of the instructions in the instruction class.  This is a
code block which must consist of labels associated with brace-delimited blocks
or conditional blocks.  Each label must correspond to a legal state for the
machine associated with this instruction class.  When a <tt class="docutils literal"><span class="pre">defmod</span></tt> block is
used, replacement occurs on a per-state basis.</p>
</li>
</ul>
</div>
<div class="section" id="id15">
<h4><a class="toc-backref" href="#id61" name="id15">2.6.5&nbsp;&nbsp;&nbsp;Interface Methods</a></h4>
<p>Note that these methods are called directly within the instruction-class code,
with no dot-notation used.</p>
<div class="section" id="control-api">
<h5><a class="toc-backref" href="#id62" name="control-api">2.6.5.1&nbsp;&nbsp;&nbsp;Control API</a></h5>
<dl class="docutils">
<dt><em>addr_t addr()</em>:</dt>
<dd>Returns the address of the current instruction.</dd>
<dt><em>unsigned size()</em>:</dt>
<dd>Returns the size of the current instruction, in bytes.</dd>
<dt><em>unsigned capacity()</em>:  </dt>
<dd>Returns the capacity of the stage associated with the state containing the
call to this method.</dd>
<dt><em>void exec()</em>: </dt>
<dd>Execute the instruction.</dd>
<dt><em>void exec_and_read(&lt;memory|cache&gt; [,exec-count])</em>: </dt>
<dd>Convenience function for performing a memory/cache read. This performs the
read/exec/post-read sequence on the memory-object argument. The same sequence
could be done by the user, but this routine is provided as a convenience. If
an execution count is provided, then this specifies how many times <tt class="docutils literal"><span class="pre">exec()</span></tt>
should be called. This is useful for grouping loads, so that a single memory
operation can correspond to more than one load from a functional point of
view.</dd>
<dt><em>void exec_and_write(&lt;memory|cache&gt;[,exec-count][,final-size])</em>: </dt>
<dd>Convenience function for performing a memory/cache write. This performs the
pre-write/exec/write sequence on the memory-object argument. An optional
execution-count allows this to be repeated in order to group writes. If the
optional final-size parameter is specified, then if the last grouped exec is
not performed, the size is adjusted to the specified value.</dd>
<dt><em>bool exec_done()</em>: </dt>
<dd>Returns true if execution is finished (no more memory ops).</dd>
<dt><em>void change_state(&lt;state&gt;)</em>: </dt>
<dd>Change state.  The argument must be a literal corresponding to a valid state
for the machine associated with this instruction.</dd>
<dt><em>bool stalled()</em>: </dt>
<dd>Return true if the pipeline is stalled.</dd>
<dt><em>void flush()</em>: </dt>
<dd>Flush the pipeline. This updates the <strong>NIA</strong> register to the next instruction
address, so it should not be used with a branch. Use <tt class="docutils literal"><span class="pre">taken_flush()</span></tt>
instead. This instruction can be tricky to use with safe-mode models because,
in such models, all instructions execute when they are issued. Therefore, an
instruction which needs to call <tt class="docutils literal"><span class="pre">flush()</span></tt>, such as a PowerPC <tt class="docutils literal"><span class="pre">isync</span></tt> instruction,
should call <tt class="docutils literal"><span class="pre">set_speculative()</span></tt> in its init-state action code. This will turn
off subsequent execution of instructions until a flush occurs. For
completeness, <tt class="docutils literal"><span class="pre">set_speculative()</span></tt> is defined for normal-mode models, though it
does nothing.</dd>
<dt><em>void taken_flush()</em>: </dt>
<dd>Flush the pipeline for a taken branch.</dd>
<dt><em>InstrType &amp;thisInstr()</em>:</dt>
<dd>Returns a reference to the current instruction.  Such a reference is needed
when helper functions are invoked which then make calls to resource methods.</dd>
<dt><em>bool branch_taken()</em>: </dt>
<dd>Returns true if instruction is a branch and it is taken.</dd>
<dt><em>addr_t branch_target()</em>:</dt>
<dd>Returns the target of the branch, if the instruction is a branch and was
taken.</dd>
<dt><em>void clr_serialized(unsigned s)</em>:</dt>
<dd>If the instruction has a memory transaction, then clear its serialized flags
using the mask <strong>s</strong>.</dd>
<dt><em>bool is_misaligned(unsigned mask)</em>: </dt>
<dd>Returns true if the current memory access for this instruction is misaligned
according to the given mask. For example, a mask of 0x3 implies
word-alignment. Note that memory accesses are removed after a read or write
operation, so this may only be applied between a send-request operation and
the corresponding <tt class="docutils literal"><span class="pre">read()</span></tt> or <tt class="docutils literal"><span class="pre">write()</span></tt>.</dd>
<dt><em>bool is_serialized(unsigned level_mask = -1)</em>:</dt>
<dd>Returns true if the current memory access for this instruction has a
serialized mask set according to the supplied parameter.</dd>
<dt><em>bool has_more_mem()</em>:</dt>
<dd>Returns true if the instruction has another memory item.  Currently only
implemented for safe-mode models.</dd>
<dt><em>bool has_next_request()</em>:</dt>
<dd>Returns true if the instruction has another memory request to be sent.
Currently only implemented for safe-mode models.  This is useful for when a
design issues multiple memory requests, such as in a misaligned situation,
before issuing the corresponding read or write.</dd>
<dt><em>bool has_requested_mem_op()</em>: </dt>
<dd>Returns true if the instruction has a memory operation and its request has
been sent. This is useful for when one stage has possibly sent a request and
another stage needs to determine if a read or write should be performed.</dd>
<dt><em>bool last_branch_prediction_correct()</em>:</dt>
<dd>This is a safer method for checking whether a branch prediction was incorrect:
It not only checks the predictor status versus the instruction's
taken/not-taken status, but also checks that the predicted target equals the
actual branch target.  This extra check is unnecessary for non-calculated
branches, but is provided for extra safety.</dd>
<dt><em>bool last_branch_prediction_correct(BranchPredictor &amp;)</em>:</dt>
<dd>Same as above, but allows the branch predictor to be specified, in
architectures where there is more than one predictor.</dd>
<dt><em>void next_req_mem()</em>:</dt>
<dd>Advance to the next memory request, if multiple exist.  Mainly useful when
combining multiple functional memory requests into a larger
micro-architectural memory request.</dd>
<dt><em>void set_serialized(unsigned s)</em>:</dt>
<dd>If the instruction has a memory transaction, then set its serialized flags to
<strong>s</strong>.</dd>
<dt><em>void set_serialized_level(unsigned l)</em>:</dt>
<dd>If the instruction has a memory transaction, then set the serialize flags
corresponding to the memory-hierarchy level <strong>l</strong>.</dd>
<dt><em>void set_speculative(&lt;bool&gt;)</em>:</dt>
<dd>Designate that this instruction will be causing a flush, and so subsequent
instructions should execute speculatively until a flush occurs.  This is only
required for safe-mode models, but exists as a stub for normal-mode models in
order to present a consistent interface.</dd>
</dl>
</div>
<div class="section" id="all-operand-api">
<h5><a class="toc-backref" href="#id63" name="all-operand-api">2.6.5.2&nbsp;&nbsp;&nbsp;All-Operand API</a></h5>
<p>These are methods for interacting with all relevant operands for the instruction
class.</p>
<dl class="docutils">
<dt><em>bool can_read_ops()</em>: </dt>
<dd>Returns true if all source operands can be read.</dd>
<dt><em>bool can_write_ops()</em>: </dt>
<dd>Returns true if all target operands can be written.</dd>
</dl>
<p><em>void read_ops()</em>: Read all source operands.</p>
<dl class="docutils">
<dt><em>void allocate_ops()</em>: </dt>
<dd>Reserve all target operands for writing.</dd>
<dt><em>void deallocate_ops()</em>: </dt>
<dd>Deallocate all allocated operands.</dd>
<dt><em>void write_ops()</em>: </dt>
<dd>Write all target operands and deallocate.</dd>
</dl>
</div>
<div class="section" id="latency-api">
<h5><a class="toc-backref" href="#id64" name="latency-api">2.6.5.3&nbsp;&nbsp;&nbsp;Latency API</a></h5>
<p>Each instruction contains a counter which may be set and queried by an
instruction class and is initialized to 0 at issue time. The counter itself is just
an arbitrary counter, but it is most commonly used in order to add latency to an
instruction within a pipeline stage. This is usually done by associating two
states with a stage. The first state sets the counter and transitions to the
second state. The second state then queries the counter and transitions to a new
state if the counter is 0, otherwise it decrements the counter.</p>
<dl class="docutils">
<dt><em>bool check_latency()</em>:</dt>
<dd>Returns true if latency is 0.  This is equivalent to <tt class="docutils literal"><span class="pre">(latency()</span> <span class="pre">==</span> <span class="pre">0)</span></tt>,
except that if the latency is non-zero, a stall message is generated if
pipeline tracing is enabled.</dd>
<dt><em>void clear_latency()</em>:</dt>
<dd>Set the latency counter to 0.</dd>
<dt><em>void decr_latency()</em>: </dt>
<dd>Decrement the counter by 1.</dd>
<dt><em>unsigned latency()</em>: </dt>
<dd>Return the current value of the latency counter.</dd>
<dt><em>void set_latency(unsigned)</em>: </dt>
<dd>Set the latency to a specified value.</dd>
</dl>
<div class="section" id="globals-and-miscellaneous-functions">
<h6><a class="toc-backref" href="#id65" name="globals-and-miscellaneous-functions">2.6.5.3.1&nbsp;&nbsp;&nbsp;Globals and Miscellaneous Functions</a></h6>
<dl class="docutils">
<dt><em>unsigned getChildId()</em>:</dt>
<dd>The <strong>child id</strong> represents a unique identifier for each thread in the core,
starting with a value of 0.</dd>
<dt><em>position</em>:</dt>
<dd>This variable is available to all action code and specifies the position of
the instruction in the stage.  For dependent-scheduled stages, the position
records the original position, rather than the current position, since the
instruction will always be at the front of the queue if its action code is
being executed.</dd>
<dt><em>top</em>:</dt>
<dd>Reference to the top-level architecture block, for use in querying other
threads' stages.</dd>
</dl>
</div>
</div>
<div class="section" id="operand-interface-methods">
<h5><a class="toc-backref" href="#id66" name="operand-interface-methods">2.6.5.4&nbsp;&nbsp;&nbsp;Operand Interface Methods</a></h5>
<p>These methods are invoked using dot-notation, with the name of the operand on
the left-hand-side, e.g. <tt class="docutils literal"><span class="pre">Src.can_read()</span></tt>.</p>
<dl class="docutils">
<dt><em>bool can_read()</em>: </dt>
<dd>Returns true if all elements of the operand can be read. An alternate version
is supplied for use with forwarding paths. This function is implemented for
both sources and targets; in both cases, a real check is made.</dd>
<dt><em>bool can_read_fp(&lt;fwd path&gt;,[fwd path, ...])</em>: </dt>
<dd>The user may specify forwarding paths as arguments to be checked as well as
the real resource, e.g. <tt class="docutils literal"><span class="pre">Src1.can_read_fp(FwdEX,FwdMM)</span></tt>. Versions of this
function are generated for the number of forwarding paths in the system. Note
that this can be used with non-fowarding-path resources as long as they have
the expected <tt class="docutils literal"><span class="pre">can_read()</span></tt>, <tt class="docutils literal"><span class="pre">read()</span></tt> interface.</dd>
<dt><em>bool can_write()</em>: </dt>
<dd>Returns true if we can write to the operand's element(s).</dd>
<dt><em>void read()</em>: </dt>
<dd>Read the operand. Versions of this function are generated for use with
forwarding paths, e.g. <tt class="docutils literal"><span class="pre">Src.read(FwdEX,FwdMM)</span></tt>.</dd>
<dt><em>bool read_avail([&lt;fwd path&gt;...])</em>:</dt>
<dd><p class="first">This predicate acts like <strong>can_read_fp</strong> and <strong>read</strong>.  It attempts to read
the sub-operands if they haven't already been read, then returns true if
everything has been read.  This allows a state to act like a reservation
station, monitoring a fowarding path which implements a completion bus.</p>
<p><strong>Very important</strong>: You must call the operand's <strong>record_sources()</strong> method
first before ever calling <strong>read_avail()</strong>.  This is because <strong>read_avail()</strong>
only reads results from the completion bus if they match the source
information stored in the instruction from the call to <strong>record_sources()</strong>.</p>
<p class="last"><strong>Note</strong>: This predicate, unlike all other predicates, has side effects.</p>
</dd>
<dt><em>void record_sources()</em>:</dt>
<dd>Records source information, storing this in the instruction packet.  For each
source operand, if it can be read, then a tag of 0 is stored.  Otherwise, the
last allocator's ID is stored.  This is then used by <strong>read_avail()</strong> to make
sure that the proper value is read on the forwarding-path/completion bus it is
monitoring.</dd>
<dt><em>void allocate()</em>: </dt>
<dd>Reserve all resources for writing.</dd>
<dt><em>void deallocate()</em>: </dt>
<dd>Remove the reservation for all resources.</dd>
<dt><em>void write()</em>: </dt>
<dd>Write the operand. This also deallocates the resource.</dd>
<dt><em>void is_real()</em>: </dt>
<dd>Returns true if this is a real field, or false if this is just a dummy
field. Dummy fields are present when an instruction does not have a particular
operand, e.g. a PowerPC  <tt class="docutils literal"><span class="pre">lwz</span></tt> does not have an RB operand, thus an operand
mapped to <tt class="docutils literal"><span class="pre">GPR(RB)</span></tt> would exist as a stub for <tt class="docutils literal"><span class="pre">lwz</span></tt>.</dd>
<dt><em>unsigned field_value()</em>: </dt>
<dd>Returns the value of the operand instruction field. This may be used with
immediates or with register operands.</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section" id="running-a-model">
<h2><a class="toc-backref" href="#id67" name="running-a-model">3&nbsp;&nbsp;&nbsp;Running A Model</a></h2>
<div class="section" id="creating-a-model">
<h3><a class="toc-backref" href="#id68" name="creating-a-model">3.1&nbsp;&nbsp;&nbsp;Creating A Model</a></h3>
<p><tt class="docutils literal"><span class="pre">uadl2model</span></tt> is the command to create model executables from ADL and uADL
description files.</p>
<p>Usage:</p>
<pre class="literal-block">uadl2model [options] &lt;.adl file&gt; &lt;.uadl file&gt;
</pre>
<p>Options:</p>
<dl class="docutils">
<dt><em>--help, --h</em>:</dt>
<dd>Display help</dd>
<dt><em>--man, -m</em>:</dt>
<dd>Display the complete help as a man page.</dd>
<dt><em>--version, -v</em>:</dt>
<dd>Display the ADL/uADL version number.</dd>
<dt><em>--prefix=str</em>:</dt>
<dd>Specify the prefix directory.</dd>
<dt><em>--verbose[=level]</em>:</dt>
<dd>Show the output of all internally executed commands. This may be
set to a numerical value, in which case extra verbosity may be
enabled. Off is equal to a value of 0, 1 is minimal, 2 is more,
etc.</dd>
<dt><em>--config-file=file, -cf=file</em>:</dt>
<dd>Specify a configuration file for model generation.</dd>
<dt><em>--trace-mode, -t</em>:</dt>
<dd>Generate code for tracing (producing intermediate results). This
is a negatable option. The default is TRUE.</dd>
<dt><em>--debug-mode, -dm</em>:</dt>
<dd>Generate a model with debug support. This is a negatable option.
The default is TRUE.</dd>
<dt><em>--syscall-enabled</em>:</dt>
<dd>Enable system-call support. This is a negatable option. The
default is TRUE.</dd>
<dt><em>--rnumber</em>:</dt>
<dd>Generate the model with RNumber support. This is a negatable
option. The default value is TRUE.</dd>
<dt><em>--safe-mode</em>:</dt>
<dd>Create a model that always produces correct functional results.</dd>
<dt><em>--iss-mem-mode</em>:</dt>
<dd>Create a model using the ISS memory interface. This option is
ignored if safe mode is not enabled.</dd>
<dt><em>--hybrid-iss</em>:</dt>
<dd>Generate a hybrid ISS. This is only applicable for safe mode.
With this option, no data is stored within each individual
instruction packet.</dd>
<dt><em>--trans-pool-size=int</em>:</dt>
<dd>Specify the maximum number of outstanding instruction packets
for the model.</dd>
<dt><em>--mem-pool-size=int</em>:</dt>
<dd>Specify the maximum number of outstanding memory transactions
for the model.</dd>
<dt><em>--log-usage[=prog:verr]</em>:</dt>
<dd><p class="first">Turn usage logging on or off. The user may supply an optional
program-name and version string to be logged. If omitted, then
the input-file root will be used as the program-name and the
version will default to &lt;year&gt;.&lt;month&gt;.&lt;day&gt;.</p>
<p class="last">To disable the option, use --log-usage=false or --log-usage=no.
You may also use the negated form of --no-log-usage.</p>
</dd>
<dt><em>--namespace=str</em>:</dt>
<dd>Specify the model namespace. The default namespace is "uadl".
This option implies "compile-only" because the default main()
function requires namespace "uadl".</dd>
<dt><em>--detect-deadlock[=cycle-count]</em>:</dt>
<dd>Specify a cycle-count for detecting deadlock. Valid only for
safe-mod models. A value of 0 disables this feature or the
option may be negated to disable it, e.g. --no-detect-deadlock.
The default is 0 (the feature is disabled).</dd>
<dt><em>--systemc[=type]</em>:</dt>
<dd><p class="first">Create the model as a SystemC module. This option implies
"compile-only" or a shared-object target because it is
incompatible with the default main() function.</p>
<p class="last">The type may be either method or thread, implying the use of
their SC_METHOD or SC_THREAD. If no value is specified, method
is assumed.</p>
</dd>
<dt><em>--extern-mem</em>:</dt>
<dd>Use external memory models. This option implies compile-only or
--target=base-so because it is incompatible with the default
main() function.</dd>
<dt><em>--extern-mem-hybrid</em>:</dt>
<dd>Use an external memory model for uADL only. This option implies
compile-only or --target=base-so or --target=so because it is
incompatible with the default main() function.</dd>
<dt><em>--preamble=str</em>:</dt>
<dd>Add a preamble string to the model, which is displayed at
startup time.</dd>
<dt><em>--define=str, -D=str</em>:</dt>
<dd>Specify a preprocessor define.</dd>
<dt><em>--include=path, -I=path</em>:</dt>
<dd>Specify a preprocessor include directory.</dd>
<dt><em>--depfile=file, -df=file</em>:</dt>
<dd>Instruct the preprocessor to generate a dependency file suitable
for inclusion by a Makefile. This is done as a side-effect and
does not affect the compilation process.</dd>
<dt><em>--gen</em>:</dt>
<dd>Controls whether new C++ files are generated or not. If negated,
e.g. --no-gen, then the model is just recompiled. This feature
can be used to compile a model when only generated C++ files are
distributed.</dd>
<dt><em>--gen-only, -go</em>:</dt>
<dd>Generate the model source code only.</dd>
<dt><em>--compile-only, -co</em>:</dt>
<dd>Generate the model source code and compile it, producing an
object file.</dd>
<dt><em>--target=[exe|so|base-so]</em>:</dt>
<dd><p class="first">Specify the target type. The default is exe which means that a
standalone executable will be produced. If the so option is
selected, a standalone shared object will be generated.</p>
<p class="last">If the base-so option is selected, a barebones shared object
will be created which contains only the minimum support
libraries. This is generally only useful if the model is to be
linked against another application.</p>
</dd>
<dt><em>--output=file, -o=file</em>:</dt>
<dd>Specify the output file name. If not specified, the base name of
the uADL input file will be used.</dd>
<dt><em>--src-prefix=path</em>:</dt>
<dd>Specify a directory for storing the generated source files.</dd>
<dt><em>--no-optimize</em>:</dt>
<dd>Turn off compiler optimization.</dd>
<dt><em>--optimize=[level]</em>:</dt>
<dd>Compile the model with optimization. The default optimization
level is 3, corresponding to compiling with -O3. Another level
may be specified. A value of 0 turns off optimization
(equivalent to using the --no-optimize option).</dd>
<dt><em>--static</em>:</dt>
<dd>Link all dependent libraries statically, including the compiler
run-time.  Only standard system libraries are dynamically linked.  This
creates a model which is as portable as possible.</dd>
<dt><em>--mflags=str</em>:</dt>
<dd>Specify flags to be given to the model generator.</dd>
<dt><em>--cflags=str</em>:</dt>
<dd>Specify flags to be given to the compiler. This option may be
repeated.</dd>
<dt><em>--ldflags=str</em>:</dt>
<dd>Specify flags to be given to the linker. This option may be
repeated.</dd>
<dt><em>--cleanup=all|obj|none</em>:</dt>
<dd>Remove temporary, intermediate files. By default, this is set to
obj, which means that object file sare cleaned up. if none is
selected, then no cleanup is performed. If all is selected, then
all intermediate files, including source files, are removed.</dd>
<dt><em>--iss-separate-compile, -isc</em>:</dt>
<dd>Compile the ISS as a separate object file. This can reduce
compile times and is the default for non-optimized builds. This
option may be negated.</dd>
<dt><em>--jobs=n,-j=n</em>:</dt>
<dd>Specify the number of jobs into which to break the model
compilation.</dd>
<dt><em>--low-mem,-lm</em>:</dt>
<dd>Enable code generation that requires less memory to compile.
Logic in the decode tree is broken up into separate functions.</dd>
<dt><em>--uadl-low-mem,-ulm</em>:</dt>
<dd>Enable code generation for uADL that requires less memory to
compile. Each instruction class is written to a separate file.</dd>
<dt><em>--instr-class-vd</em>:</dt>
<dd>Use virtual dispatch, rather than templates, for instruction
class operands. This will produce a slower model, but with a
faster compilation time. The default is false. This option may
be negated.</dd>
<dt><em>--instr-cache</em>:</dt>
<dd>Generate an instruction cache for the model. This improves
performance by caching instruction packets but does not
currently support self-modifying code.</dd>
<dt><em>--instr-cache-page-size=int</em>:</dt>
<dd>Specify the size of a page (maps to number of instructions,
based upon instruction size.</dd>
<dt><em>--instr-cache-size=int</em>:</dt>
<dd>Specify the size of the instruction object cache (number of
pages).</dd>
<dt><em>--parallel-build[=max-jobs],-p[=max-jobs]</em>:</dt>
<dd>Run the compile jobs in parallel. This is the default. Negate
this feature to compile all items sequentially. An optional
maximum number of parallel jobs may be specified. This option
may be negated to disable parallel builds.</dd>
<dt><em>--disassembler</em>:</dt>
<dd>Generate a disassembler function in the model. This allows an
external program to disassemble arbitrary memory, using the
model's memory-hierarchy access routines.</dd>
<dt><em>--strict</em>:</dt>
<dd>Use strict mode for parsering ADL and uADL.</dd>
<dt><em>--adl-strict</em>:</dt>
<dd>Use strict mode for parsering ADL only.</dd>
<dt><em>--uadl-strict</em>:</dt>
<dd>Use strict mode for parsering uADL only.</dd>
<dt><em>--check-cr-args</em>:</dt>
<dd>Parse custom-resource headers and check arguments. False by
default if --print-data is true.</dd>
<dt><em>--warn-redefine</em>:</dt>
<dd>Warn if a define block overwrites another define block. This
option may be negated. The default is true.</dd>
<dt><em>--lsf=str</em>:</dt>
<dd>Use as a prefix for running commands. The string defining prefix
is optional, default value is 'bsub -Ip -P adl'</dd>
<dt><em>--print-data</em>:</dt>
<dd>Print the uADL data model and exit.</dd>
<dt><em>--print-all-data</em>:</dt>
<dd>Print both the ADL and uADL data model and exit.</dd>
</dl>
</div>
<div class="section" id="standalone-models">
<h3><a class="toc-backref" href="#id69" name="standalone-models">3.2&nbsp;&nbsp;&nbsp;Standalone Models</a></h3>
<p>Usage:</p>
<pre class="literal-block">&lt;exec_name&gt; [options] &lt;dat|uvp|elf file...&gt;
</pre>
<p>Options:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-c=<var>&lt;val&gt;</var></span></kbd></td>
<td>specify maximum simulation cycles</td></tr>
<tr><td class="option-group">
<kbd><span class="option">--help</span>, <span class="option">-h</span></kbd></td>
<td>display help</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--output=<var>&lt;val&gt;</var></span>, <span class="option">-o=<var>&lt;val&gt;</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>specify an output file</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--start-time=<var>&lt;val&gt;</var></span>, <span class="option">-s=<var>&lt;val&gt;</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>specify a start time</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--time-out=<var>&lt;val&gt;:</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>specify time-out cycle count for safe mode</td></tr>
<tr><td class="option-group">
<kbd><span class="option">--trace</span>, <span class="option">--ti</span></kbd></td>
<td>enable instruction tracing</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--trace-all</span>, <span class="option">--ta</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>enable all pipeline tracing information</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--trace-memory</span>, <span class="option">--tm</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>enable memory activity tracing</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--trace-operand</span>, <span class="option">--to</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>enable instruction operand tracing</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--trace-pipeline</span>, <span class="option">--tp</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>enable pipeline tracing</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--trace-stall</span>, <span class="option">--ts</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>enable pipeline stall tracing</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--trace-target</span>, <span class="option">--tt</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>enable instruction target tracing</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="integration">
<h2><a class="toc-backref" href="#id70" name="integration">4&nbsp;&nbsp;&nbsp;Integration</a></h2>
<p>This section describes various aspects and APIs for integrating a uADL model
into another application.</p>
<div class="section" id="processor-core-interface">
<h3><a class="toc-backref" href="#id71" name="processor-core-interface">4.1&nbsp;&nbsp;&nbsp;Processor Core Interface</a></h3>
<p>Two versions of processor of the core interface are provided, one for
SystemC-based integration, defined in <tt class="docutils literal"><span class="pre">uadl/uadlArchSystemCIf.h</span></tt>, and another
for non-SystemC-based integration, defined in <tt class="docutils literal"><span class="pre">uadl/uadlArchIf.h</span></tt>.  Shown
below is the interface for SystemC-based integration:</p>
<pre class="literal-block">uadl::UadlArchSystemC *createArch(
  const std::string &amp;name,
  unsigned &amp;id,
  uadl::UadlMemoryIf *memory = NULL,
  adl::ttime_t startTime = 0
);
</pre>
<p>The interface for non-SystemC-based integration is identical except that the
model type is <em>UadlArch</em> instead of <em>UadlArchSystemC</em>.</p>
<p>Listed below are the relevant interface methods of the model class.</p>
</div>
<div class="section" id="model-creation">
<h3><a class="toc-backref" href="#id72" name="model-creation">4.2&nbsp;&nbsp;&nbsp;Model Creation</a></h3>
<dl class="docutils">
<dt><em>createArch()</em>: </dt>
<dd><p class="first">creates a uADL model.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>name</em> is the name of the model.</li>
<li><em>id</em> is a reference to an unsigned integer storing the numerical ID for the
core.  Each core will increment this value by 1.</li>
<li><em>memory</em>, when not NULL, points to an external memory model that should be
used instead of the internal memory model,</li>
<li><em>startTime</em> is the start time.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="model-configuration-methods">
<h3><a class="toc-backref" href="#id73" name="model-configuration-methods">4.3&nbsp;&nbsp;&nbsp;Model Configuration Methods</a></h3>
<dl class="docutils">
<dt><em>bindClock(sc_signal&lt;bool&gt; &amp;clk)</em>:</dt>
<dd><p class="first">Binds a clock signal to the SystemC model.
The model is then driven by that clock signal.</p>
<p>Parameters:</p>
<ul class="simple">
<li><em>clk</em> specifies the clock signal.</li>
</ul>
<p>For a non-SystemC model, there is no clock signal.  The model can be driven by
calling <em>proceed()</em> (see below).</p>
<p class="last">A SystemC model can be driven by calling <em>proceed()</em> as well, however, this is
not recommended.</p>
</dd>
<dt><em>setExtMemory(UadlMemoryIf &amp;mem)</em>:</dt>
<dd><p class="first">Set the uADL core model to use an external memory model.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>mem</em> specifies the external memory.</li>
</ul>
</dd>
<dt><em>setLogStream(std::ostream &amp;out)</em>:</dt>
<dd><p class="first">Set the uADL core model to use <em>out</em> instead of std::cout to output pipeline trace.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>out</em> specifies an alternate output stream.</li>
</ul>
</dd>
<dt><em>setIssMemHandler(adl::MemHandler</em>)*:</dt>
<dd>Specify the memory handler object for the functional (ISS) model.</dd>
</dl>
</div>
<div class="section" id="custom-cachememory-models">
<h3><a class="toc-backref" href="#id74" name="custom-cachememory-models">4.4&nbsp;&nbsp;&nbsp;Custom Cache/Memory Models</a></h3>
<p>A custom cache model maybe be specified by defining a cache and setting the
<strong>custom</strong> key, as described in the <a class="reference" href="#cache">Cache</a> section.  The custom model may
derive from the generic uADL cache model but it need not do so.  It may also
represent any kind of memory-like object.  However, the model must have a
constructor with parameters equivalent to the built-in cache model and it must
have the same basic interface.</p>
<p>The constructor is:</p>
<pre class="literal-block">Cache(const Timer &amp;timer, const string &amp;name, uADLMemoryIf &amp;memory,
      unsigned memoryPort, unsigned lineWidth, unsigned addrBandwidth,
       unsigned dataBandwidth, unsigned queueSize, bool allowBusWait, 
      bool preemptive, const CacheConfigMap &amp;configmap,
      bool withData = true);
</pre>
<p>Most configuration parameters are stored in the <tt class="docutils literal"><span class="pre">CacheConfigMap</span></tt> object, which
contains key/value pairs, where the value may store an integer or a string.
When a custom cache model is declared, no error checking is performed for
unrecognized cache parameters.  This allows the custom model to be configured
beyond the standard set of configuration parameters recognized by the generic
uADL model.</p>
<p>In addition to the cache model, a template wrapper class is required.  This
template provides an interface between the cache object and the uADL action
code.  New cache transactions may be created by simply adding new methods to the
template object which then call the appropriate methods in the cache object.</p>
<p>The template must have the same name as the custom class's name with <strong>T</strong>
appended.  For example, if the custom-cache class name is <strong>MyCache</strong>, then
the template must be named <strong>MyCacheT</strong>.  The format of the template class is:</p>
<pre class="literal-block">template &lt;class CacheType,class ModelType,bool safeMode&gt;
struct MyCacheT : public uadl::CacheT&lt;CacheType,ModelType,safeMode&gt; {
  typedef uadl::CacheT&lt;CacheType,ModelType,safeMode&gt; Base;

  MyCacheT (CacheType &amp;cache) : Base(cache), _cache(cache) {};

  CacheType &amp;_cache;
};
</pre>
<p>The <tt class="docutils literal"><span class="pre">CacheT</span></tt> baseclass is the standard uADL cache wrapper.  Use of this class
is not required, but recommended if the custom class derives from the standard
uADL cache model.</p>
<p>The template parameters are:</p>
<dl class="docutils">
<dt>CacheType:</dt>
<dd>The type of the cache object.</dd>
<dt>ModelType:</dt>
<dd>The type of the uADL processor model.</dd>
<dt>safeMode:</dt>
<dd>A flag indicating whether the model is a safe-mode model.</dd>
</dl>
<p>New transaction types may be added by simply adding a new method to this class.
The method must take three hidden parameters.  Any extra parameters correspond
to arguments visible to the user.  The return type is up to the user.</p>
<p>For example:</p>
<pre class="literal-block">bool has_some_space(ModelType &amp;uarch,uadl::InstrBase &amp;instr,uadl::Logger *logger,unsigned n) {   
  return _cache.check_for_space(logger,n);
}
</pre>
<p>A new transaction is added to <tt class="docutils literal"><span class="pre">MyCacheT</span></tt> called <tt class="docutils literal"><span class="pre">has_some_space</span></tt>.  This
returns a boolean, allowing it to be used within an action's guard condition.
The first three parameters, <tt class="docutils literal"><span class="pre">uarch</span></tt>, <tt class="docutils literal"><span class="pre">instr</span></tt>, and <tt class="docutils literal"><span class="pre">logger</span></tt>, are standard
parameters, giving the user access to the processor model, the instruction
invoking this method, and a logger object.  The logger object may be 0 if
logging is off.  The final parameter, <tt class="docutils literal"><span class="pre">n</span></tt>, is a user-visible parameter.  This
method then calls a method in the underlying cache object to complete the
query.  The user may then use this transaction in their action code:</p>
<pre class="literal-block">S_ID:  if (L1d.has_some_space(5) &amp;&amp; mExec.has_space()) { ... }
</pre>
</div>
<div class="section" id="dynamic-parameter-api">
<h3><a class="toc-backref" href="#id75" name="dynamic-parameter-api">4.5&nbsp;&nbsp;&nbsp;Dynamic Parameter API</a></h3>
<p>uADL models support various startup-time dynamic configuration parameters using
an API similar to the one present for ADL models.  These parameters are only
meant to be modified at the beginning of a simulation.  The following are
methods of <tt class="docutils literal"><span class="pre">uadlArch</span></tt>:</p>
<ul class="simple">
<li><em>virtual void set_dyn_parm(const std::string &amp;parm,unsigned value)</em>: Sets a
parameter value.  Throws a <strong>runtime_error</strong> if the parameter or value are
invalid.</li>
<li><em>virtual unsigned get_dyn_parm(const std::string &amp;parm) const</em>:  Retrieves
the value of a dynamic parameter.  Throws a <strong>runtime_error</strong> if the parameter
is invalid.</li>
<li><em>virtual void list_dyn_parm(StrPairs &amp;parms) const</em>: Returns a sequence of
pairs describing all dynamic parameters in the model.  The first element of
each pair is the parameter name; the second element is a description of the
parameter.</li>
</ul>
<p>If a parameter is not recognized as a valid uADL parameter, the underlying ISS
is queried.  If neither model recognizes a parameter, then a <strong>runtime_error</strong>
is thrown.</p>
<p>A standalone executable uADL model may have its dynamic parameters modified
through the TCL interface using the same functions as for an ADL model.</p>
</div>
<div class="section" id="model-control-methods">
<h3><a class="toc-backref" href="#id76" name="model-control-methods">4.6&nbsp;&nbsp;&nbsp;Model Control Methods</a></h3>
<dl class="docutils">
<dt><em>bool is_active()</em>:</dt>
<dd>Returns true if the model is active.</dd>
<dt><em>void proceed()</em>:</dt>
<dd>Progress the model by one time step (clock cycle).</dd>
<dt><em>void preRun()</em>:</dt>
<dd>Must be called before the first call to <tt class="docutils literal"><span class="pre">proceed()</span></tt> in order to synchronize
activity.  This is called automatically by <tt class="docutils literal"><span class="pre">run()</span></tt>, so you only need to call it if
you are calling <tt class="docutils literal"><span class="pre">proceed()</span></tt>.</dd>
<dt><em>void run(ttime_t endTime)</em>:</dt>
<dd>Execute the model until some stopping condition is met, e.g. breakpoint,
end-of-simulation, etc.</dd>
<dt><em>void postSim()</em>:</dt>
<dd>Called at the end of simulation, to ensure proper shutdown/flusing of any
necessary resources.</dd>
<dt><em>void reset()</em>:</dt>
<dd>Reset the model so that it returns to a clean idle state, and can restart
execution from a new address that is set by the program or environment.  This
automatically resets the ISS.</dd>
<dt><em>void setProgramCounter(adl::addr_t)</em>:</dt>
<dd>Set the model's program counter.  This routine must be called, rather than the
underlying ISSs, in order to ensure that the fetch unit is synchronized with
the model.</dd>
<dt><em>adl::addr_t getProgramCounter() const</em>:</dt>
<dd>Return the current program-counter value.</dd>
<dt><em>adl::IssNode&amp; iss()</em>:</dt>
<dd>Access/query the underlying functional model.</dd>
</dl>
</div>
<div class="section" id="external-interrupt-methods">
<h3><a class="toc-backref" href="#id77" name="external-interrupt-methods">4.7&nbsp;&nbsp;&nbsp;External Interrupt Methods</a></h3>
<dl class="docutils">
<dt><em>genExceptions(uint64_t exception)</em>:</dt>
<dd>Sets an external exception flag.</dd>
<dt><em>cancelExceptions(uint64_t exception)</em>:</dt>
<dd>Clears an external exception flag.</dd>
</dl>
<p>In both functions, parameter <em>exception</em> is interpreted as a bit flag with each
bit representing a particular exception type.  For example, to signal an
edge-triggered exception, call <em>genExceptions()</em> then call <em>cancelExceptions()</em>
with the same exception flag at the next cycle.</p>
<p>The system model does not need to check whether the exception is enabled or
disabled by the processor core.</p>
</div>
<div class="section" id="tracing-control">
<h3><a class="toc-backref" href="#id78" name="tracing-control">4.8&nbsp;&nbsp;&nbsp;Tracing Control</a></h3>
<p>A uADL simulator object inherits from <tt class="docutils literal"><span class="pre">LogControl</span></tt>, declared in <tt class="docutils literal"><span class="pre">OSM.h</span></tt>.
This class controls all tracing.  By default, all tracing is disabled.  It may
be enabled by calling <tt class="docutils literal"><span class="pre">set_tracing</span></tt> with various bit flags for controlling
individual tracing events.  Please refer to <tt class="docutils literal"><span class="pre">OSM.h</span></tt> for the complete
interface.</p>
<p>For example, to enable tracing of the pipeline, memory, and stalls:</p>
<pre class="literal-block">UadlArch &amp;arch = *createArch("core", id, NULL, startTime);

arch.set_tracing(LOG_MEMORY | LOG_PIPELINE | LOG_STALL);
</pre>
<p>The <tt class="docutils literal"><span class="pre">LogControl</span></tt> interface allows for setting and clearing events via bit
flags or by string-name.</p>
</div>
<div class="section" id="breakpoints-and-watchpoints">
<h3><a class="toc-backref" href="#id79" name="breakpoints-and-watchpoints">4.9&nbsp;&nbsp;&nbsp;Breakpoints and Watchpoints</a></h3>
<p>Breakpoints and watchpoints use the underlying ADL ISS interface.  Refer to the
<a class="reference" href="http://cad.freescale.net/adl/chrome/site/adl-language-reference.html">ADL Language Reference Manual</a> for more information.</p>
</div>
<div class="section" id="systemc-interface">
<h3><a class="toc-backref" href="#id80" name="systemc-interface">4.10&nbsp;&nbsp;&nbsp;SystemC Interface</a></h3>
<p>A basic SystemC interface can be generated for the model by using the
<strong>--systemc[=&lt;method|thread&gt;]</strong> command-line option. Either an SC_THREAD or
SC_METHOD interface may be generated, based upon the option's value. If no value
is given for the option, then the default is to create an SC_METHOD.</p>
<p>To use the resulting model, the user should define UADL_SYSTEMC before including
the main header, in order to get the proper base-class type:</p>
<pre class="literal-block">#define UADL_SYSTEMC
#include "uadl/uadlArchIf.h"
</pre>
<p>Then, the model can be instantiated by calling <tt class="docutils literal"><span class="pre">createArch()</span></tt>:</p>
<pre class="literal-block">UadlArchSystemC &amp;arch = *createArch("core", id, 0, startTime);
</pre>
<p>Before starting simulation, a clock must be bound to the model:</p>
<pre class="literal-block">arch.bindClock(clock);
...
sc_start(5000,SC_NS);
</pre>
<p>After that, the simulation may be started. There is no need to call
UadlArch::pre_run(), as that is taken care of by the SystemC interface.</p>
</div>
<div class="section" id="custom-branch-predictors">
<h3><a class="toc-backref" href="#id81" name="custom-branch-predictors">4.11&nbsp;&nbsp;&nbsp;Custom Branch Predictors</a></h3>
<p>If the algorithm specifies for a branch predictor is not recognized, then it is
assumed to be a custom algorithm implemented by the user.  During model
generation, this causes an include directive to be inserted into the generated
model to include a header which implements the algorithm.  The custom algorithm
is also instantiated in the model's class.  For example, given a custom
algorithm declaration:</p>
<pre class="literal-block">define (branch_predictor BP) {
    algorithm = MyCustomBp;
    ...
}
</pre>
<p>The resulting model will generate an include directive, where the file is the
same as the name of the algorithm:</p>
<pre class="literal-block">#include "MyCustomBp.h"
</pre>
<p>The class name is the same as the algorithm, e.g. <tt class="docutils literal"><span class="pre">MyCustomBP</span></tt> in this
example.  The class must derive from <tt class="docutils literal"><span class="pre">BranchPredictor</span></tt>, declared in
<tt class="docutils literal"><span class="pre">uadl/BranchPredictor.h</span></tt> and it must be a template with the following
interface:</p>
<pre class="literal-block">//  BPData:       Data type for branch-predictor entries.
//  BPredEnable:  Functor for testing whether the predictor is enabled.
template &lt;class BPData,class BPredEnable&gt;
class BranchPredictorExample : public BranchPredictor {
public:
  // Expected constructor interface:
  //
  // timer:   Timer object; pass to base class.
  // name:    Name of the object; pass to base class.
  // enable:  Instance of enable predicate.
  // size:    Predictor size parameter declared in uadl file.  May be ignored
  //          if not relevant.
  // width:   Counter-width parameter declared in uadl file.  May be ignored
  //          if not relevant.
  BranchPredictorExample(const Timer &amp;timer, const string &amp;name,
                         const enable_type &amp;enable,unsigned size,
                         unsigned width);

  // Resets the predictor.
  void reset();

  // This should just invoke the BPredEnable functor, but different behavior
  // may be implemented, if desired.
  bool enabled();

  // Returns true if the last prediction was taken.  The second form also
  // updates 'target' with the target address if predicted taken.
  bool last_predict_taken(ModelType &amp;uarch,InstrType &amp;instr,Logger *logger = 0);
  bool last_predict_taken(ModelType &amp;uarch,InstrType &amp;instr,Logger *logger,addr_t &amp;target);

  // Transaction interface:  Make a prediction.
  //
  // x:       Query data structure.  This should match against an entry via operator==.
  // target:  Target address (output).
  // size:    If non-null and a prediction is made., should be set to the size of the prediction.
  Prediction predict(const BPData &amp;x, addr_t &amp;target, unsigned *size);

  // Transaction interface:  Update the predictor.
  //
  // x:       Update the predictor with this entry.  Only add if not already present.
  // target:  Target address for the update.
  // taken:   Taken data for the update.
  // size:    Size data for the update.
  void update(const BPData &amp;x, addr_t target, bool taken, unsigned size);
};
</pre>
<p>The built-in <tt class="docutils literal"><span class="pre">Counter</span></tt> algorithm is defined in <tt class="docutils literal"><span class="pre">BranchPredictor.h</span></tt> and may
be used as a reference for developing new custom algorithms.</p>
</div>
<div class="section" id="external-memory-interface">
<h3><a class="toc-backref" href="#id82" name="external-memory-interface">4.12&nbsp;&nbsp;&nbsp;External Memory Interface</a></h3>
<p>uADL has two main ways for a model's memory to interface with its external
environment:  The transactional interface and the functional interface.  In
either case, the model must be built with <strong>--extern-mem</strong> in order to enable
the use of external memory.</p>
<p>If a model is built with <strong>--extern-mem</strong>, then a transactional memory interface
must be provided via a call to <tt class="docutils literal"><span class="pre">UadlArch::setExtMemory</span></tt>.  A transactional
memory implements a non-blocking interface which divides memory transactions
into a request and action phase.  The interface is described below in
<a class="reference" href="#transaction-interface">Transaction Interface</a> and is declared in  <tt class="docutils literal"><span class="pre">uadl/uadlMemoryIf.h</span></tt>.</p>
<p>If the model is built with <strong>--safe-mode</strong> and <strong>--iss-mem-mode</strong>, then the
model interacts with its external environment solely through an ADL
functional-memory interface, as declared in <tt class="docutils literal"><span class="pre">iss/MemHandler.h</span></tt>, when the
instruction executes during fetch/issue.  Latency for the current operation may
be set by the environment via a call to <tt class="docutils literal"><span class="pre">MemHandler::set_latency(unsigned)</span></tt>.
This latency will be used by the pipeline model when the relevant memory
operation is processed by the pipeline.</p>
<div class="section" id="transaction-interface">
<h4><a class="toc-backref" href="#id83" name="transaction-interface">4.12.1&nbsp;&nbsp;&nbsp;Transaction Interface</a></h4>
<dl class="docutils">
<dt><em>sendRequestInquire()</em>:</dt>
<dd><p class="first">Returns true if the memory is able to accept a new request.
Returns false otherwise.</p>
<p>Parameters:</p>
<ul class="simple">
<li><em>machine</em>: when not NULL, is the instruction who makes the query.</li>
<li><em>type</em>: memory request type.</li>
<li><em>logFailure</em>: whether failures should be logged.</li>
<li><em>portId</em>: memory port id.</li>
</ul>
<p class="last">If the external memory model does not support failure logging, <em>logFailure</em>
can be ignored.  If the external memory model supports failure logging, when a
query failure occurs, the memory model can call
<tt class="docutils literal"><span class="pre">machine-&gt;logFailure(reason)</span></tt> with reason being a C++ string that describes
or explains the failure.</p>
</dd>
<dt><em>sendFetchRequest()</em>:</dt>
<dd><p class="first">Sends an instruction fetch request to the memory and returns a unique request id.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>ea</em>: effective address.</li>
<li><em>ra</em>: real address.</li>
<li><em>size</em>: data size (in bytes) of the request.</li>
<li><em>exception</em>: if the request causes a memory exception, the memory model
should update <em>exception</em> with exception type.</li>
<li><em>portId</em>: memory port id.</li>
</ul>
</dd>
<dt><em>sendReadRequest()</em>:</dt>
<dd><p class="first">Sends a data read request to the memory and returns a unique request id.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>ea</em>: effective address.</li>
<li><em>ra</em>: real address.</li>
<li><em>size</em>: data size (in bytes) of the request.</li>
<li><em>exception</em>: if the request causes a memory exception, the memory model
should update <em>exception</em> with exception type.</li>
<li><em>instId</em>: if the request is caused by an instruction, this is the
instruction commit id.  For example, if a load instruction causes a cache
miss and subsequent cache line eviction and linefill activities, besides the
load (read) request itself, all eviction (write) and linefill (read)
requests from the cache to its next-level memory also have the commit id of
that load instruction as <em>instId</em>.</li>
<li><em>portId</em>: memory port id.</li>
</ul>
</dd>
<dt><em>sendWriteRequest()</em>:</dt>
<dd><p class="first">Sends a data write request to the memory and returns a unique request id.</p>
<p>Parameters:</p>
<ul class="simple">
<li><em>ea</em>: effective address.</li>
<li><em>ra</em>: real address.</li>
<li><em>size</em>: data size (in bytes) of the request.</li>
<li><em>exception</em>: if the request causes a memory exception, the memory model
should update <em>exception</em> with exception type.</li>
<li><em>data</em>: When the <em>data</em> pointer is not NULL, it points to the write data.
This is usually not required unless the external memory model expects to
receive address and data at the same time.</li>
<li><em>writeThrough</em>: whether the write is write-through (true) or write-back
(false).  This parameter is ignored if the external memory is not a cache.</li>
<li><em>instId</em>: if the request is caused by an instruction, this is the
instruction commit id.  For example, if a store instruction causes a cache
miss and subsequent cache line eviction and linefill activities, besides the
store (write) request itself, all eviction (write) and linefill (read)
requests from the cache to its next-level memory also have the commit id of
that write instruction as <em>instId</em>.</li>
<li><em>portId</em>: memory port id.</li>
<li><em>isEvict</em>: whether the write is a cache eviction write (true) or not
(false).  This parameter is only required if the external memory model
behaves as a timing delegate, i.e., relying on another memory model to
provide read/write timing information.</li>
</ul>
<p class="last">There are forms of <em>sendReadRequest()</em> and <em>sendWriteRequest()</em> with an
additional <em>adl::CacheStatus</em> parameter.  These forms are for safe mode only.
The additional <em>adl::CacheStatus</em> parameter specifies whether the cache should
be regarded enabled or disabled when processing the request, if the external
memory is a cache.</p>
</dd>
<dt><em>readInquire()</em>:</dt>
<dd><p class="first">Returns true if the memory is ready to return data requested by the read
request denoted by <em>requestId</em>.  Returns false otherwise.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>machine</em>: when not NULL, is the instruction who makes the query.</li>
<li><em>requestId</em>: request id.</li>
<li><em>logFailure</em>: whether failures should be logged.</li>
</ul>
</dd>
<dt><em>read()</em>:</dt>
<dd><p class="first">Reads data of the read request denoted by <em>requestId</em>.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>requestId</em>: request id.</li>
<li><em>data</em>: data buffer to store read data.
If <em>data</em> is NULL, read data are not stored.</li>
</ul>
</dd>
<dt><em>writeInquire()</em>:</dt>
<dd><p class="first">Returns true if the memory is ready to receive data from the write request denoted by <em>requestId</em>.
Returns false otherwise.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>machine</em>: when not NULL, is the instruction who makes the query.</li>
<li><em>requestId</em>: request id.</li>
<li><em>logFailure</em>: whether failures should be logged.</li>
</ul>
</dd>
<dt><em>write()</em>:</dt>
<dd><p class="first">Writes data of the write request denoted by <em>requestId</em>.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>requestId</em>: request id.</li>
<li><em>data</em>: data buffer where write data are stored.
If <em>data</em> is NULL, the write only consumes time and bandwidth with no data copying.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="non-transaction-interface">
<h4><a class="toc-backref" href="#id84" name="non-transaction-interface">4.12.2&nbsp;&nbsp;&nbsp;Non-Transaction Interface</a></h4>
<dl class="docutils">
<dt><em>void cancel(u_int requestId, bool deep = true)</em>:</dt>
<dd><p class="first">Cancels a pending request.</p>
<p>Parameters:</p>
<ul class="simple">
<li><em>requestId</em>: request id.</li>
<li><em>deep</em>: whether the memory should do a deep cancellation (true) or a weak
cancellation (false).  A deep cancellation physically removes the request
and all its pending side effects, e.g., read/write from/to the next-level
memory.  A weak cancellation only marks the request as being cancelled but
does not remove it, so the request will still be processed and incur other
side effects, e.g., linefill on a cache.  A request that is weakly cancelled
will be removed once it is completed.  A write request that is weakly
cancelled cannot be really "completed", so it will only consume write cycles
but not update data.</li>
</ul>
<p class="last">This function provides a hint that some request has been abandoned by the
processor core, hence no subsequent read or write transaction will occur on
that request.  It does not have to be implemented if the external memory model
can properly handle abandoned requests by other means.</p>
</dd>
</dl>
</div>
<div class="section" id="other-functions">
<h4><a class="toc-backref" href="#id85" name="other-functions">4.12.3&nbsp;&nbsp;&nbsp;Other Functions</a></h4>
<dl class="docutils">
<dt><em>getMemoryData()</em>:</dt>
<dd><p class="first">Debugging version of <em>read()</em>.
Reads data from the memory in zero time and with no side effects.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>type</em>: type of read.  Specifically, adl::CacheIFetch for fetches and
adl::CacheRead for data reads.</li>
<li><em>addr</em>: real address.</li>
<li><em>size</em>: data size (in bytes).</li>
<li><em>data</em>: data buffer.</li>
</ul>
</dd>
<dt><em>setMemoryData()</em>:</dt>
<dd><p class="first">Debugging version of <em>write()</em>.
Writes data to the memory in zero time and with no side effects except data updates.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>addr</em>: real address.</li>
<li><em>size</em>: data size (in bytes).</li>
<li><em>data</em>: data buffer.</li>
</ul>
</dd>
<dt><em>fetchMemoryData()</em>:</dt>
<dd><p class="first">Un-timed version of <em>read()</em> for instruction fetches.
Reads data from the memory in zero time and with all necessary side effects.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>addr</em>: real address.</li>
<li><em>size</em>: data size (in bytes).</li>
<li><em>data</em>: data buffer.</li>
<li><em>exception</em>: if the read causes a memory exception, the memory model should
update <em>exception</em> with exception type.</li>
</ul>
</dd>
<dt><em>readMemoryData()</em>:</dt>
<dd><p class="first">Un-timed version of <em>read()</em> for data reads.
Reads data from the memory in zero time and with all necessary side effects.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>addr</em>: real address.</li>
<li><em>size</em>: data size (in bytes).</li>
<li><em>data</em>: data buffer.</li>
<li><em>exception</em>: if the read causes a memory exception, the memory model should
update <em>exception</em> with exception type.</li>
</ul>
</dd>
<dt><em>writeMemoryData()</em>:</dt>
<dd><p class="first">Un-timed version of <em>write()</em>.
Writes data to the memory in zero time and with all necessary side effects.</p>
<p>Parameters:</p>
<ul class="last simple">
<li><em>addr</em>: real address.</li>
<li><em>size</em>: data size (in bytes).</li>
<li><em>data</em>: data buffer.</li>
<li><em>exception</em>: if the read causes a memory exception, the memory model should
update <em>exception</em> with exception type.</li>
</ul>
</dd>
<dt><em>isActive()</em>:</dt>
<dd><p class="first">Returns true if the memory has outstanding activities.
Returns false otherwise.</p>
<p>This function is used by the uADL scheduler to determine when simulation
should be terminated.  In a system model, this decision is not made by the
uADL scheduler, hence <em>isActive()</em> does not have to be implemented.</p>
<p class="last">Not all interface functions need to be implemented by the external memory
model.  Those that do not have to be implemented have their default
implementations in UadlMemoryIf.h.  However, to what extent the interface is
implemented determines at what situations an external memory model can or
cannot be integrated with a uADL core model.  For example, an external memory
model that does not implement <em>getMemoryData()</em> and <em>setMemoryData()</em> cannot
be integrated with a safe-mode uADL core model but can be integrated with a
normal-mode uADL core model, while an external memory model that implements
the full interface can be integrated with both.</p>
</dd>
</dl>
<p>The following figures illustrate the interaction between the core and platform
models under safe mode.</p>
<div class="figure">
<img alt="safe-mode-fetch-hit.png" src="safe-mode-fetch-hit.png" /><p class="caption">uADL safe-mode fetch access sequence (cache hit).</p>
</div>
<div class="figure">
<img alt="safe-mode-fetch-miss.png" src="safe-mode-fetch-miss.png" /><p class="caption">uADL safe-mode fetch access sequence (cache miss).</p>
</div>
<div class="figure">
<img alt="safe-mode-load-miss.png" src="safe-mode-load-miss.png" /><p class="caption">uADL safe-mode load/read access sequence (cache miss).</p>
</div>
<div class="figure">
<img alt="safe-mode-load-hit.png" src="safe-mode-load-hit.png" /><p class="caption">uADL safe-mode load/read access sequence (cache hit).</p>
</div>
<div class="figure">
<img alt="safe-mode-store-miss.png" src="safe-mode-store-miss.png" /><p class="caption">uADL safe-mode store/write access sequence (cache miss).</p>
</div>
<div class="figure">
<img alt="safe-mode-store-hit.png" src="safe-mode-store-hit.png" /><p class="caption">uADL safe-mode store/write access sequence (cache hit).</p>
</div>
<div class="figure">
<img alt="safe-mode-overlapped-accesses.png" src="safe-mode-overlapped-accesses.png" /><p class="caption">uADL un-timed accesses can overlap with timed accesses.</p>
</div>
</div>
</div>
</div>
<div class="section" id="a-complete-example">
<h2><a class="toc-backref" href="#id86" name="a-complete-example">5&nbsp;&nbsp;&nbsp;A Complete Example</a></h2>
<p>The following is a simple example which illustrates a 5-stage pipeline:</p>
<pre class="literal-block">//
// A basic four-stage (DLX-like) model.  Uses power-like instructions and
// demonstrates basic register-register and load/store operands.
//

#ifndef MemWidth
# define MemWidth 32
#endif

define (core P) {

  allow_unimpl_instrs = true;

  define (resources) {
    // instruction buffer (fetch stage)
    define (fetchunit IF) {
      fetch_memory = mMEM;
      entries = 6;
      entry_size = 1;
      fetch_size = (4);
      min_fetch_entries = 4;
    }

    // pipeline stages
    define (pipestage mID) {
      issue = true;
      scheduler = lock_step;
    }

    define (pipestage=(mEX, mMM, mWB)) {
      scheduler = lock_step;
    };

    // memory system
    define (memory mMEM) {
      data_width = MemWidth;
    }

    define (semaphore MulFlag) {}
  }

  define (machine normal) {
    init_state = S_INIT;
    states = ( S_ID, S_EX, S_EXp, S_MM, S_MMp, S_WB, S_WBp );

    define (mapping) {
      mID = S_ID;
      mEX = (S_EX,S_EXp);
      mMM = (S_MM,S_MMp);
      mWB = (S_WB,S_WBp);
    };

  }

  define (instr_class sfx) {
    instructions = ( "addic.", addi, addis, ori, "andi.", 
                     add, or, 
                     cmpi, cmp, 
                     rlwinm, mfspr, srw, halt );

    machine = normal;
    
    define (operands) {
      Src1 = GPR(RA);
      Src2 = GPR(RB);
      Trg  = GPR(RT);
      Flags = CR;
      Flags = XER;
      Foo   = 1;
    };

    define (instr=(ori, xori, "andi.", "andis.", rlwimi, "rlwimi.", 
                   rlwinm, "rlwinm.", and, or, "or.", xor, slw, sraw, "sraw.", srawi, "srawi.",
                   srw )) {
      define (operands) {
        Src1 = GPR(RS);
        Src2 = GPR(RB);
        Trg  = GPR(RA);
        Foo  = 2;
      };
    }

    define (instr=(cmpli,cmpi,cmp,cmpl)) {
      define (operands) {
        Src1 = GPR(RA);
        Src2 = GPR(RB);
        Trg  = CR;
        Foo  = 3;
      }
    }

    define (instr=(mfspr)) {
      define (operands) {
        Src1 = SPR(SPRN);
        Trg  = GPR(RT);
      }
    }

    define (instr=(crxor,creqv)) {
      define (operands) {
        Src1 = CR;
        Trg  = CR;
        Foo = 2;
      }
    } 

    allow_missing_operands = true;

    action = {
		S_INIT: { 
			change_state(S_ID); 
		};
		S_ID: if (Src1.can_read() &amp;&amp; Src2.can_read() &amp;&amp; Flags.can_read() &amp;&amp;
							Trg.can_write() &amp;&amp; mEX.has_space() &amp;&amp; Foo.value()) {
				Src1.read();
				Src2.read();
        Flags.read();
        Flags.allocate();
				Trg.allocate();
				change_state(S_EX);
			}
		// No space-check, so one will be inserted.
		S_EX: {
			exec();
			change_state(S_MM);
		}
		S_MM: { 
			change_state(S_WB); 
		}
		// No need for a space-check, since S_WBp maps to the same stage.
		S_WB: {
      write_ops();
      change_state(S_WBp);
    }
		S_WBp:{
			change_state(S_INIT);
		}
    };
  }

  int mull_delay(int x)
  {
    return 0;
  }

  int div_delay(int y)
  {
    // Just to test signExtend's compilation, which requires a translation.
    bits&lt;16&gt; tmp = 0x8000;
    var foo = signExtend(tmp,32);
    return 5;
  }

  define (instr_class mul) {
    instructions = ( mulli,  mullw, divw );

    machine = normal;
    
    define (operands) {
      Src1 = GPR(RA);
      Src2 = GPR(RB);
      Trg  = GPR(RT);
    };

    define (functions) {
      delay = mull_delay;
    }

    define (instr=(divw)) {
      define (functions) {
        delay = div_delay;
      }
    }

    allow_missing_operands = true;

    action = {
		S_INIT: { 
			change_state(S_ID); 
		};
		S_ID: if (can_read_ops() &amp;&amp; can_write_ops() &amp;&amp; mEX.has_space() &amp;&amp; MulFlag.can_allocate()) {
        read_ops();
        allocate_ops();
        MulFlag.allocate();
				change_state(S_EX);
			}
		// No space-check, so one will be inserted.
		S_EX: {
			exec();
      set_latency(delay(2));
			change_state(S_MM);
		}
		S_MM: if (check_latency() &amp;&amp; mWB.has_space()) {
			change_state(S_WB); 
		} else {
      decr_latency();
    }
		// No need for a space-check, since S_WBp maps to the same stage.
		S_WB: {
      write_ops();
      change_state(S_WBp);
    }
		S_WBp:{
      MulFlag.deallocate();
			change_state(S_INIT);
		}
    };
  }

 define (instr_class load) {
    instructions = ( lbz, lhz, lwz, lwzu, lwzx );

    machine = normal;
    
    define (operands) {
      Src = sources;
      Trg = targets;
      Imm = field(D);
    };

    allow_missing_operands = true;

    action = {
		S_INIT: { 
			change_state(S_ID); 
		};
		S_ID: if (Src.can_read() &amp;&amp; Trg.can_write() &amp;&amp; mEX.has_space()) {
        Src.read();
				Trg.allocate();
				change_state(S_EX);
			}
    S_EX: if (mMM.has_space() &amp;&amp; mMEM.can_request_read()) {
        // Calc ea.
        exec();
        mMEM.send_read_request();
        change_state(S_MM);
      }
		S_MM: if (mMEM.can_read()) { 
        exec_and_read(mMEM);
        change_state(S_MMp);
      }
    // "edge" action:  If we're done executing, then move to writeback, else stay at MM.
    S_MMp: if (exec_done() &amp;&amp; mWB.has_space()) {
        change_state(S_WB);
      }
      else if (mMEM.can_request_read()) {
        mMEM.send_read_request();
        change_state(S_MM);
      }
		// No need for a space-check, since S_WBp maps to the same stage.
		S_WB: {
      write_ops();
      change_state(S_WBp);
    }
		S_WBp:{
			change_state(S_INIT);
		}
    };
  }

 define (instr_class lmv) {
    instructions = ( e_lmvsprw );

    machine = normal;

    define (operands) {
      Src = sources;
      Trg = targets;
      Imm = field(D);
    };

    allow_missing_operands = true;

    action = {
                S_INIT: {
                        change_state(S_ID);
                };
                S_ID: if (can_read_ops() &amp;&amp; can_write_ops() &amp;&amp; mEX.has_space()) {
        read_ops();
        allocate_ops();
                                change_state(S_EX);
                        }
    S_EX: if (mMM.has_space() &amp;&amp; mMEM.can_request_read()) {
        // Calc ea.
        exec();
        mMEM.send_read_request();
        if (is_misaligned(0x7)) { set_latency(1); }
        change_state(S_MM);
      }
                S_MM: if (mMEM.can_read()) {
        // If the transaction is double-word misaligned, we add latency.
        exec_and_read(mMEM);
        change_state(S_MMp);
      }
    S_MMp: if (exec_done() &amp;&amp; !check_latency()) {
        decr_latency();
      } else if (exec_done() &amp;&amp; mWB.has_space()) {
        change_state(S_WB);
      }
      else if (mMEM.can_request_read()) {
        mMEM.send_read_request();
        change_state(S_MM);
      }
                S_WB: {
      write_ops();
      change_state(S_WBp);
    }
                S_WBp:{
                        change_state(S_INIT);
                }
    };
  }

 define (instr_class store) {
    instructions = (stb, sth, sthx, stw, stwu, stwx);

    machine = normal;
    
    define (operands) {
      Src = sources;
      Trg = targets;
    };

    allow_missing_operands = true;

    action = {
		S_INIT: { 
			change_state(S_ID); 
		};
		S_ID: if (Src.can_read() &amp;&amp; Trg.can_write() &amp;&amp; mEX.has_space()) {
				Src.read();
        Trg.allocate();
				change_state(S_EX);
			}
    S_EX: if (mMM.has_space() &amp;&amp; mMEM.can_request_write()) {
        // Calc ea.
        exec();
        mMEM.send_write_request();
        change_state(S_MM);
      }
		S_MM: if (mMEM.can_write()) { 
        exec_and_write(mMEM);
        change_state(S_MMp);
      }
    // "edge" action:  If we're done executing, then move to writeback, else stay at MM.
    S_MMp: if (exec_done() &amp;&amp; mWB.has_space()) {
        change_state(S_WB);
      }
      else if (mMEM.can_request_write()) {
        mMEM.send_write_request();
        change_state(S_MM);
      }
		// No need for a space-check, since S_WBp maps to the same stage.
		S_WB: {
      write_ops();
      change_state(S_WBp);
    }
		S_WBp: {
      change_state(S_INIT);
    }
    };
  }

 define (instr_class branch) {
   instructions = ( bc, b, bl, bclr );
   
   machine = normal;

   allow_missing_operands = true;
   
   action = {
   S_INIT :{
     change_state(S_ID);
   };
   S_ID: if (can_read_ops() &amp;&amp; can_write_ops() &amp;&amp; mEX.has_space()) {
       read_ops();
       allocate_ops();
       change_state(S_EX);
     }
   S_EX: if (mMM.has_space()) {
       exec();
       write_ops();
#      ifndef BAD_BRANCH
       if (branch_taken()) {
         taken_flush();
       }
#      endif
       change_state(S_MM);
     }
   S_MM: if (mWB.has_space()) {
       change_state(S_WB);
     }
   S_WB: {
     change_state(S_INIT);
   }
   };
 }

  define (instr_class mtspr) {
    instructions = mtspr;
    machine = normal;

    define (operands) {
      Src = GPR(RS);
      Trg = SPR;
    };

#   define HID0_INDEX 50
#   define HID1_INDEX 51

    action = {
    S_INIT: {
      change_state(S_ID);
    }
    S_ID: {
      if (Src.can_read() &amp;&amp; mEX.has_space()) {
        Src.read();
        Trg.allocate();
        change_state(S_EX);
      }
    }
    S_EX: {
      exec();
      if (Trg.field_value() == HID0_INDEX || Trg.field_value() == HID1_INDEX) {
        set_latency(2);
      }
      change_state(S_EXp);
    }
    S_EXp: if (check_latency() &amp;&amp; mMM.has_space()) {
        change_state(S_MM);
      } else {
        decr_latency();
      }
    S_MM: {
      change_state(S_WB);
    }
    S_WB: {
      write_ops();
      change_state(S_WBp);
    }
    S_WBp: {
      change_state(S_INIT);
    }
    };
  }

}
</pre>
<p>This uses the following as its functional model:</p>
<pre class="literal-block">//
// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.
//
// You may distribute under the terms of the Artistic License, as specified in
// the COPYING file.
//

// Enums can be declared in the outer scope and used within the architecture's
// defines.
enum {
  RegWidth = 32,
};

define (arch = MiniPPC) {

  // Various helper routines.

  void setCrField(bits&lt;3&gt; field,bits&lt;32&gt; x,bits&lt;32&gt; y) {

    bits&lt;4&gt; r = 
      ( (x.signedLT(y)) ? 0x8 : 0) |
      ( (x.signedGT(y)) ? 0x4 : 0) |
      ( (x == y)        ? 0x2 : 0) |
      XER.SO;

    CR(4*field,4*field+3) = r;
  }

  void setXerField(bool ov, bool so, bool ca,const bits&lt;32&gt;&amp; carry)
  {
    if (ov) { XER.OV = carry(0) ^ carry(1);}
    if (so) { XER.SO = XER.SO | XER.OV ;}
    if (ca) { XER.CA = carry(0);}
  }


  attrs = (load,store,privileged,debug);

  //
  // Registers.
  //

  define (reg=CIA) {
    """
      Current instruction address.
      """;
    attrs = cia;
  }

  define (reg=NIA) {
    """
      Next instruction address.
      """;
    attrs = (nia,debug(4));
  }

  define (reg=CR) {
    """
      The condition register.
      """;
    attrs = debug(1);
  }

  define (reg=XER) {
    """
      The overflow and carry register.
      """;
    attrs = debug(5);
    width = RegWidth;
    define (field=SO) { bits = 0; }
    define (field=OV) { bits = 1; }
    define (field=CA) { bits = 2; }
  }

  define (reg=CTR) {
    """
      The counter register.
      """;
    attrs = debug(2);
  }

  define (reg=LR) {
    """
      The link register.
      """;
    attrs = debug(3);
  }

  define (reg=HID0) {
    attrs = privileged;
  }

  define (reg=HID1) {
    attrs = privileged;
  }

  define (regfile=GPR) {
    """
      General purpose registers.
      """;
    size = RegWidth;
    prefix = r;
    attrs = debug(0);
  }

  define (regfile=SPR) {
    """
      Special purpose registers.
      """;
    size=1024;
    define (entry=8)  { reg = LR; }
    define (entry=9)  { reg = CTR; }
    define (entry=1)  { reg = XER; }
    define (entry=50) { reg = HID0; }
    define (entry=51) { reg = HID1; }
  }

  //
  // Instruction fields.
  //

  define (instrfield=OPCD) {
    """
Primary opcode.
    """;
    bits = (0,5);
  }

  define (instrfield=XO) {
    """
Extended opcode.
    """;
    bits = (21,30);
  }

  define (instrfield=RC) {
    """
    Extended RC opcode.
    """;
    bits = (31,31);
  }

  define (instrfield=BO) {
    """
Field used to specify options for the Branch Conditional instructions.
    """;
    bits = (6,10);
    display = hex;
  }

  define (instrfield=BI) {
    """
Field used to specify a bit in the Condition Register to be used
as the condition of a Branch Conditional instruction.
    """;
    bits = (11,15);
    display = hex;
  }

  define (instrfield=CRn) {
    """
Assembler field used to specify a CR field for a conditional branch.
    """;
    pseudo = true;
    width = 3;
  }

  define (instrfield=BD) {
    """
Immediate field specifying a 14-bit signed two's complement branch displacement
which is concatenated on the right with 0b00 and sign-extended.
    """;
    bits = (16,29);
    addr = pc;
    shift = 2;
    is_signed = true;
  }

  define (instrfield=BF) {
    """
Field used to specify one of the Condition Register fields or one of the
Floating-Point Status and Control Register fields to be used as a target.
    """;
    bits = (6,8);
  }

  define (instrfield=AA) {
    """
Absolute address bit.
    """;
    bits = 30;
  }

  define (instrfield=LI) {
    """
    Immediate address field for branch instructions.
    """;
    bits = (6,29);
    
    is_signed = true;
    shift = 2;
    addr = pc;
  }

  define (instrfield=LK) {
    """
LINK bit.
    """;
    bits = 31;
  }

  define (instrfield=L) {
    """
Unused for 32-bit implementations.
    """;
    bits = 10;
  }

  define (instrfield=Y) {
    """
This is a hint bit for conditional branches.
    """;
    bits = 10;
    overlay = true;
  }

  define (instrfield=SPRN) {
    """
Field used to specify a Special Purpose Register for the *mtspr* and *mfspr* instructions.
    """;
    bits = ((16,20),(11,15));
    ref = SPR;
    type = regfile;
  }

  define (instrfield=RA) {
    """
Field used to specify a General Purpose Register to be used as a source.
    """;
    bits = (11,15);
    ref = GPR;
    type = regfile;
  }

  define (instrfield=RB) {
    """
Field used to specify a General Purpose Register to be used as a source.
    """;
    bits = (16,20);
    ref = GPR;
    type = regfile;
  }

  define (instrfield=RT) {
    """
Field used to specify a General Purpose Register to be used as a target.
    """;
    bits = (6,10);
    ref = GPR;
    type = regfile;
  }

  define (instrfield=RS) {
    """
Field used to specify a General Purpose Register as a target.
    """;
    bits = (6,10);
    ref = GPR;
    type = regfile;
  }

  define (instrfield=D) {
    """
Immediate field used to specify a 16-bit signed two's complement integer
which is sign-extended to 64-bits.
    """;
    bits = (16,31);
    display = dec;
    is_signed = true;
  }

  define (instrfield=SI) {
    """
Signed immediate field for arithmetic operations.
    """;
    bits = (16,31);
    display = dec;
    is_signed = true;
  }

  define (instrfield=UI) {
    """
Unsigned immediate field for arithmetic operations.
    """;
    bits = (16,31);
  }

  define (instrfield=SH) {
    bits = (16,20);
  }

  define (instrfield=MB) {
    bits = (21,25);
  }

  define (instrfield=ME) {
    bits = (26,30);
  }

  define (instrfield=MBE) {
    """
In order to support a 4-operand form of rlwinm, we use this field, which is
interpreted as a bitmask.
    """;
    pseudo = true;
    width = 32;
  }

  //
  // Instructions.
  //

  define (instr=add) {
    """
The sum GPR(RA) + GPR(RB) is placed into RD.

The add instruction is preferred for additions because it sets few status bits.
    """;
    fields=(OPCD(31),RT,RA,RB,XO(266));
    action = {
      GPR(RT) = GPR(RA) + GPR(RB);
    };
  }

  define (instr=addi) {
    fields=(OPCD(14),RT,RA,SI);
    action = {
       if (RA == 0) {
        GPR(RT) = SI;
      } else
         // Note: Braces have been left off specifically to test code generation
         // for this situation.
        GPR(RT) = GPR(RA) + SI;
    };
  }

  define (instr=addic) {
    fields=(OPCD(12),RT,RA,SI);
    action = {
      var carry = Carry(GPR(RA),SI,0);
      GPR(RT) = GPR(RA) + SI;
      setXerField(false/*ov*/,false/*so*/,true/*ca*/,carry);
    };
  }

  define (instr=addme) {
    fields=(OPCD(31),RT,RA,XO(234));
    action = {
      var carry = Carry(GPR(RA),0xffffffff,XER.CA); 
      GPR(RT) = GPR(RA) + 0xffffffff + XER.CA;
      setXerField(false/*ov*/,false/*so*/,true/*ca*/,carry);
    };
  } 

  define (instr="addme.") {
    fields=(OPCD(31),RT,RA,XO(234),RC(1));
    action = {
      var carry = Carry(GPR(RA),0xffffffff,XER.CA); 
      GPR(RT) = GPR(RA) + 0xffffffff + XER.CA;
      setXerField(false/*ov*/,false/*so*/,true/*ca*/,carry);
      setCrField(0,GPR(RT),0);
    };
  } 

  define (instr=addmeo) {
    fields=(OPCD(31),RT,RA,XO(746));
    action = {
      var carry = Carry(GPR(RA),0xffffffff,XER.CA); 
      GPR(RT) = GPR(RA) + 0xffffffff + XER.CA;
      setXerField(true/*ov*/,true/*so*/,true/*ca*/,carry);
    };
  }  

  define (instr=addo) {
    fields=(OPCD(31),RT,RA,RB,XO(778));
    action = {
      var carry = Carry(GPR(RA),GPR(RB),0);  
      setXerField(true/*ov*/,true/*so*/,false/*ca*/,carry);
      GPR(RT) = GPR(RA) + GPR(RB);
    };
  }

  define (instr="andi.") {
    fields=(OPCD(28),RS,RA,UI);
    action = {
      GPR(RA) = GPR(RS) &amp; UI;
      setCrField(0,GPR(RA),0);
    };
  }

  define (instr="addic.") {
    fields=(OPCD(13),RT,RA,SI);
    action = {
      var carry = Carry(GPR(RA),SI,0);
      GPR(RT) = GPR(RA) + SI;
      setCrField(0,GPR(RT),0);
      setXerField(false/*ov*/,false/*so*/,true/*ca*/,carry);
    };
  }

  define (instr=addis) {
    fields=(OPCD(15),RT,RA,SI);
    action = {
      if (RA == 0) {
        GPR(RT) = SI &lt;&lt; 16;
      } else {
        GPR(RT) = GPR(RA) + (SI &lt;&lt; 16);
      }
    };
  }

  define (instr=b) {
    fields=(OPCD(18),LI,AA(0),LK(0));
    syntax = ("%i %f",LI);
    action =  {
      NIA = LI;
    };
  }

  define (instr=bl) {
    fields=(OPCD(18),LI,AA(0),LK(1));
    action =  {
      NIA = LI;
      LR = CIA + 4;
    };
  }

  define (instr=bc) {
    fields=(OPCD(16),BO,Y,BI,BD,AA(0),LK(0));
    syntax = ("%i %f,%f,%f",BO,BI,BD);
    action = func() {
      if ( (BO(2) ) == 0) {
        CTR = CTR - 1;
      }
      var ctr_ok = (BO(2)!=0)  || (( (CTR!=0) ^ BO(3))!=0);
      var cond_ok = (BO(0)!=0) || ( CR(BI) == BO(1));
      if ( ctr_ok &amp;&amp; cond_ok ) {
        NIA = BD;
      }
    };
  }

  define (instr=bcl) {
    fields=(OPCD(16),BO,Y,BI,BD,AA(0),LK(1));
    syntax = ("%i %f,%f,%f",BO,BI,BD);
    action = func() {
      if ( (BO(2) ) == 0) {
        CTR = CTR - 1;
      }
      var ctr_ok = (BO(2)!=0)  || (( (CTR!=0) ^ BO(3))!=0);
      var cond_ok = (BO(0)!=0) || ( CR(BI) == BO(1));
      LR = CIA + 4;
      if ( ctr_ok &amp;&amp; cond_ok ) {
        NIA = BD;        
      }
    };
  }

    // We accept this form of the instruction, but we want the disassemble to use
    // the +/- version for clarity.
    define (instr=beq) {
      alias = bc(BO(12),BI(2),BD(BD));
      syntax = ("%i %f",BD);
      disassemble=false;
    }

    // Note: These will not disassemble b/c CRn is pseudo, and thus cannot be
    // reconstructed.
    define (instr="beq+") {
      alias = bc(BO(12),Y((BD&lt;0) ? 0 : 1),BI(CRn*4+2),BD(BD));
      syntax = ("%i %f,%f",CRn,BD);
    }

    define (instr="beq-") {
      alias = bc(BO(12),Y((BD&lt;0) ? 1 : 0),BI(CRn*4+2),BD(BD));
      syntax = ("%i %f,%f",CRn,BD);
    }

    define (instr="beq+_") {
      alias = bc(BO(12),Y((BD&lt;0) ? 0 : 1),BI(2),BD(BD));
      syntax = ("beq+ %f",BD);
    }

    define (instr="beq-_") {
      alias = bc(BO(12),Y((BD&lt;0) ? 1 : 0),BI(2),BD(BD));
      syntax = ("beq- %f",BD);
    }

    define (instr=bne) {
      alias = bc(BO(4),BI(2),BD(BD));
      syntax = ("%i %f",BD);
    }

    define (instr="bne+") {
      alias = bc(BO(4),Y((BD&lt;0) ? 0 : 1),BI(CRn*4+2),BD(BD));
      syntax = ("%i %f,%f",CRn,BD);
    }

    define (instr="bne-") {
      alias = bc(BO(4),Y((BD&lt;0) ? 1 : 0),BI(CRn*4+2),BD(BD));
      syntax = ("%i %f,%f",CRn,BD);
    }

    define (instr="bne+_") {
      alias = bc(BO(4),Y((BD&lt;0) ? 0 : 1),BI(2),BD(BD));
      syntax = ("bne+ %f",BD);
    }

    define (instr="bne-_") {
      alias = bc(BO(4),Y((BD&lt;0) ? 1 : 0),BI(2),BD(BD));
      syntax = ("bne- %f",BD);
    }

    // We accept this form of the instruction, but we want the disassemble to use
    // the +/- version for clarity.
    define (instr=bgt) {
      alias = bc(BO(12),BI(1),BD(BD));
      syntax = ("%i %f",BD);
      disassemble = false;
    }

    define (instr="bgt+") {
      alias = bc(BO(12),Y((BD&lt;0) ? 0 : 1),BI(CRn*4+1),BD(BD));
      syntax = ("%i %f,%f",CRn,BD);
    }

    define (instr="bgt-") {
      alias = bc(BO(12),Y((BD&lt;0) ? 1 : 0),BI(CRn*4+1),BD(BD));
      syntax = ("%i %f,%f",CRn,BD);
    }

    define (instr="bgt+_") {
      alias = bc(BO(12),Y((BD&lt;0) ? 0 : 1),BI(1),BD(BD));
      syntax = ("bgt+ %f",BD);
    }

    define (instr="bgt-_") {
      alias = bc(BO(12),Y((BD&lt;0) ? 1 : 0),BI(1),BD(BD));
      syntax = ("bgt- %f",BD);
    }

    // We accept this form of the instruction, but we want the disassemble to use
    // the +/- version for clarity.
    define (instr=blt) {
      alias = bc(BO(12),BI(0),BD(BD));
      syntax = ("%i %f",BD);
      disassemble = false;
    }

    define (instr="blt+") {
      alias = bc(BO(12),Y((BD&lt;0) ? 0 : 1),BI(CRn*4),BD(BD));
      syntax = ("%i %f,%f",CRn,BD);
    }

    define (instr="blt-") {
      alias = bc(BO(12),Y((BD&lt;0) ? 1 : 0),BI(CRn*4),BD(BD));
      syntax = ("%i %f,%f",CRn,BD);
    }

    define (instr="blt+_") {
      alias = bc(BO(12),Y((BD&lt;0) ? 0 : 1),BI(0),BD(BD));
      syntax = ("blt+ %f",BD);
    }

    define (instr="blt-_") {
      alias = bc(BO(12),Y((BD&lt;0) ? 1 : 0),BI(0),BD(BD));
      syntax = ("blt- %f",BD);
    }

    // We accept this form of the instruction, but we want the disassemble to use
    // the +/- version for clarity.
    define (instr=ble) {
      alias = bc(BO(4),BI(1),BD(BD));
      syntax = ("%i %f",BD);
      disassemble = false;
    }

    define (instr="ble+") {
      alias = bc(BO(4),Y((BD&lt;0) ? 0 : 1),BI(CRn*4+1),BD(BD));
      syntax = ("%i %f,%f",CRn,BD);
    }

    define (instr="ble-") {
      alias = bc(BO(4),Y((BD&lt;0) ? 1 : 0),BI(CRn*4+1),BD(BD));
      syntax = ("%i %f,%f",CRn,BD);
    }

    define (instr="ble+_") {
      alias = bc(BO(4),Y((BD&lt;0) ? 0 : 1),BI(1),BD(BD));
      syntax = ("ble+ %f",BD);
    }

    define (instr="ble-_") {
      alias = bc(BO(4),Y((BD&lt;0) ? 1 : 0),BI(1),BD(BD));
      syntax = ("ble- %f",BD);
    }

    // We accept this form of the instruction, but we want the disassemble to use
    // the +/- version for clarity.
    define (instr=bge) {
      alias = bc(BO(4),BI(0),BD(BD));
      syntax = ("%i %f",BD);
      disassemble = false;
    }

    define (instr="bge+") {
      alias = bc(BO(4),Y((BD&lt;0) ? 0 : 1),BI(CRn*4),BD(BD));
      syntax = ("%i %f,%f",CRn,BD);
    }

    define (instr="bge-") {
      alias = bc(BO(4),Y((BD&lt;0) ? 1 : 0),BI(CRn*4),BD(BD));
      syntax = ("%i %f,%f",CRn,BD);
    }

    define (instr="bge+_") {
      alias = bc(BO(4),Y((BD&lt;0) ? 0 : 1),BI(0),BD(BD));
      syntax = ("bge+ %f",BD);
    }

    define (instr="bge-_") {
      alias = bc(BO(4),Y((BD&lt;0) ? 1 : 0),BI(0),BD(BD));
      syntax = ("bge- %f",BD);
    }

  define (instr=bdnz) {
    alias = bc(BO(16),BI(0),BD(BD));
    syntax = ("%i %f",BD);
    disassemble=false;
  }

  define (instr="bdnz+") {
    alias = bc(BO(16),Y((BD&lt;0) ? 0 : 1),BI(0),BD(BD));
    syntax = ("%i %f",BD);
  }

  define (instr="bdnz-") {
    alias = bc(BO(16),Y((BD&lt;0) ? 1 : 0),BI(0),BD(BD));
    syntax = ("%i %f",BD);
  }

  define (instr=bclr) {
    fields=(OPCD(19),BO,Y,BI,LK(0),XO(16));
    syntax = ("%i %f,%f",BO,BI);
    action =  {
      if (BO(2) == 0) {
        CTR = CTR - 1;
      }
      var ctr_ok = (BO(2)!=0) || (( (CTR!=0) ^ BO(3)) != 0);
      var cond_ok = (BO(0)!=0) || (CR(BI) == BO(1));
      if (ctr_ok &amp;&amp; cond_ok) {
        NIA = LR &amp; ~0x3ULL;
      }
    };
  }

  define (instr=bclrl) {
    fields=(OPCD(19),BO,Y,BI,LK(1),XO(16));
    syntax = ("%i %f,%f",BO,BI);
    action =  {
      if (BO(2) == 0) {
        CTR = CTR - 1;
      }
      var ctr_ok = (BO(2)!=0) || (( (CTR!=0) ^ BO(3)) != 0);
      var cond_ok = (BO(0)!=0) || (CR(BI) == BO(1));
      if (ctr_ok &amp;&amp; cond_ok) {
        NIA = LR &amp; ~0x3ULL;
        LR = CIA + 4;
      }
    };
  }

  define (instr=blr) {
    alias = bclr(BO(20),BI(0));
  }
  
  define (instr=cmpi) {
    fields=(OPCD(11),BF,L,RA,SI);
    action = func () {
      setCrField(BF,GPR(RA),SI);
    };
  }

  define (instr=cmpwi) {
    alias = cmpi(BF(BF),L(0),RA(RA),SI(SI));
  }

  // Two-operand form.
  define (instr=cmpwi_) {
    alias = cmpi(BF(0),L(0),RA(RA),SI(SI));
    syntax = ("cmpwi %f,%f",RA,SI);
  }

  define (instr=cmp) {
    fields=(OPCD(31),BF,RA,RB,XO(0));
    action = {
      setCrField(BF,GPR(RA),GPR(RB));
    };
  }

  define (instr=la) {
    syntax = ("%i %f,%f(%f)",RT,SI,RA);
    alias = addi(RT(RT),RA(RA),SI(SI));
  }

  define (instr=lbz) {
    fields=(OPCD(34),RT,RA,D);
    syntax = ("%i %f,%f(%f)",RT,D,RA);
    attrs = load;
    action = {
      var b = (RA == 0) ? 0 : GPR(RA);
      var addr = b + D;
      GPR(RT) = Mem(addr,1);
    };
  }

  define (instr=lbzu) {
    fields=(OPCD(35),RT,RA,D);
    syntax = ("%i %f,%f(%f)",RT,D,RA);
    attrs = load;
    action = {
      var a = (RA == 0) ? 0 : GPR(RA);
      var EA = a + D;
      GPR(RT) = Mem(EA,1);
      GPR(RA) = EA; 
    };
  }

  define (instr=lhz) {
    fields=(OPCD(40),RT,RA,D);
    syntax = ("%i %f,%f(%f)",RT,D,RA);
    attrs = load;
    action = {
      var b = (RA == 0) ? 0 : GPR(RA);
      var addr = b + D;
      GPR(RT) = Mem(addr,2);
    };
  }

  define (instr=li) {
    alias = addi(RT(RT),RA(0),SI(SI));
  }

  define (instr=lis) {
    alias = addis(RT(RT),RA(0),SI(SI));
  }

  define (instr=lmw) {
    fields=(OPCD(46),RT,RA,D);
    syntax = ("%i %f,%f(%f)",RT,D,RA);
    attrs = load;
    action = {
      var b = (RA == 0) ? 0 : GPR(RA);
      var addr = b + D;
      int r = RT.uint32();
      do {
        GPR(r) = Mem(addr,4);
        r = r + 1;
        addr = addr + 4;
      } while (r &lt;= 31);
    };
  }

  define (instr=lwz) {
    fields=(OPCD(32),RT,RA,D);
    syntax = ("%i %f,%f(%f)",RT,D,RA);
    attrs = load;
    action = {
      var b = (RA == 0) ? 0 : GPR(RA);
      var addr = b + D;
      GPR(RT) = Mem(addr,4);
    };
  }

  define (instr=lwzu) {
    fields=(OPCD(33),RT,RA,D);
    syntax = ("%i %f,%f(%f)",RT,D,RA);
    attrs = load;
    action = {
      var addr = GPR(RA.uint32()) + D;
      // Extra complexity here: For uADL, we want the address update to occur
      // first, so that the result can be forwarded.  Eventually, we want to
      // eliminate this need by being able to do an update to load registers
      // after execution.
#     ifdef UADL      
      GPR(RA.uint32()) = addr;
#     endif
      GPR(RT) = Mem(addr,4);
#     ifndef UADL  
      GPR(RA.uint32()) = addr;
#     endif
    };
  }

  define (instr=lwzx) {
    fields=(OPCD(31),RT,RA,RB,XO(23));
    attrs = load;
    action = {
      var b = (RA == 0) ? 0 : GPR(RA);
      var addr = b + GPR(RB);
      GPR(RT) = Mem(addr,4);
    };
  }

  define (instr=mr) {
    alias=or(RS(RS),RA(RA),RB(RS));
    syntax = ("%i %f,%f",RA,RS);
  }

  define (instr=mfspr) {
    fields=(OPCD(31),RT,SPRN,XO(339));
    syntax = ("%i %f,%f",RT,SPRN);
    action = {
      GPR(RT) = SPR(SPRN);
    };
  }

  define (instr=mtspr) {
    fields=(OPCD(31),RS,SPRN,XO(467));
    syntax = ("%i %f,%f",SPRN,RS);
    action = {
      SPR(SPRN) = GPR(RS);
    };
  }

  define (instr=mtctr) {
    alias=mtspr(RS(RS),SPRN(9));
  }

  define (instr=mflr) {
    alias=mfspr(RT(RT),SPRN(8));
  }

  define (instr=mtlr) {
    alias=mtspr(RS(RS),SPRN(8));
  }

  define (instr=mullw) {
    fields=(OPCD(31),RT,RA,RB,XO(235));
    action = {
      GPR(RT) = GPR(RA) * GPR(RB);
    };
  }

  define (instr=mulli) {
    fields=(OPCD(7),RT,RA,SI);
    action = {
      GPR(RT) = GPR(RA) * SI;
    };
  }

  define (instr=or) {
    fields=(OPCD(31),RS,RA,RB,XO(444));
    syntax = ("%i %f,%f,%f",RA,RS,RB);
    action = {
      GPR(RA) = GPR(RS) | GPR(RB);
    };
  }

  define (instr=ori) {
    fields=(OPCD(24),RS,RA,UI);
    syntax = ("%i %f,%f,%f",RA,RS,UI);
    action = {
      GPR(RA) = GPR(RS) | UI;
    };
  }

  define (instr=oris) {
    fields=(OPCD(25),RS,RA,UI);
    syntax = ("%i %f,%f,%f",RA,RS,UI);
    action = {
      GPR(RA) = GPR(RS) | concat(UI,zero(16));
    };
  }

  define(instr=rlwinm) {
    fields=(OPCD(21),RS,RA,SH,MB,ME);
    syntax= ("%i %f,%f,%f,%f,%f",RA,RS,SH,MB,ME);
    action = {
      var r = GPR(RS).left_rotate(SH);
      bits&lt;32&gt; m;
      m.mask(MB,ME);
      GPR(RA) = r &amp; m;
    };
  }

  // A four-operand version of the instruction, where the final argumnt is a bit
  // mask defining the starting and ending indices.
  define (instr=rlwinm_) {
    alias = rlwinm(RS(RS),RA(RA),SH(SH),MB(count_leading_zeros(MBE,32)),ME(31-count_trailing_zeros(MBE)));
    syntax= ("rlwinm %f,%f,%f,%f",RA,RS,SH,MBE);
    disassemble=false;
  }

  define(instr="clrlwi") {
    alias = rlwinm(RA(RA),RS(RS),SH(0),MB(MB),ME(31));
    syntax = ("%i %f,%f,%f",RA,RS,MB);
  }

  define (instr=slwi) {
    alias=rlwinm(RS(RS),RA(RA),SH(SH),MB(0),ME(31-SH));
    syntax= ("%i %f,%f,%f",RA,RS,SH);
    disassemble=false;
  }

  // For this implementation, we just nop the system call if system calls are
  // not enabled.
  define (instr=sc) {
    fields=(OPCD(17),XO(1));
    action = {
      if (syscall_enabled()) {
        syscall_add_arg(GPR(1));        // stack pointer (brk needs it)
        syscall_add_arg(GPR(3));        // arg0
        syscall_add_arg(GPR(4));        // arg1
        syscall_add_arg(GPR(5));        // arg2
        syscall_add_arg(GPR(6));        // arg3
        syscall_add_arg(GPR(7));        // arg4
        syscall_trigger(GPR(0));        // syscode - 32 bit mode
        GPR(3) = syscall_return_code(); // the return value
      }
    };
  }

  // This tests to make sure that we correctly translate arguments to the memory
  // object.
  define (instr=stb) {
    fields=(OPCD(38),RS,RA,D);
    syntax = ("%i %f,%f(%f)",RS,D,RA);
    attrs = store;
    action = {
      Mem( (((RA == 0) ? 0 : GPR(RA)) + D),1) = GPR(RS);
    };
  }

  define (instr=sth) {
    fields=(OPCD(44),RS,RA,D);
    syntax = ("%i %f,%f(%f)",RS,D,RA);
    attrs = store;
    action = {
      var b = (RA == 0) ? 0 : GPR(RA);
      var addr = b + D;
      Mem(addr,2) = GPR(RS);
    };
  }

  define (instr=sthx) {
    fields=(OPCD(31),RS,RA,RB,XO(407));
    attrs = store;
    action = {
      var b = (RA == 0) ? 0 : GPR(RA);
      var addr = b + GPR(RB);
      Mem(addr,2) = GPR(RS);
    };
  }

  define (instr="stmw") {
    fields=(OPCD(47),RS,RA,D);
    syntax = ("%i %f,%f(%f)",RS,D,RA);
    attrs = store;
    action = {
      var b = (RA == 0) ? 0 : GPR(RA);
      var addr = b + D;
      int r = RS.uint32();
      do {
        Mem(addr,4) = GPR(r);
        r = r + 1;
        addr = addr + 4;
      } while (r &lt;= 31);
    };
  }

  define (instr=stw) {
    fields=(OPCD(36),RS,RA,D);
    syntax = ("%i %f,%f(%f)",RS,D,RA);
    attrs = store;
    action = {
      var b = (RA == 0) ? 0 : GPR(RA);
      var addr = b + D;
      Mem(addr,4) = GPR(RS);
    };
  }

  define (instr=stwu) {
    fields=(OPCD(37),RS,RA,D);
    syntax = ("%i %f,%f(%f)",RS,D,RA);
    attrs = store;
    action = {
      var addr = GPR(RA) + D;
      Mem(addr,4) = GPR(RS);
      GPR(RA) = addr;
    };
  }

  define (instr=stwx) {
    fields=(OPCD(31),RS,RA,RB,XO(151));
    attrs = store;
    action = {
      var b = (RA == 0) ? 0 : GPR(RA);
      var addr = b + GPR(RB);
      Mem(addr,4) = GPR(RS);
    };
  }

  define (instr=srw) {
    fields=(OPCD(31),RS,RA,RB,XO(536));
    syntax = ("%i %f,%f,%f",RA,RS,RB);
    action = {
      var n = GPR(RB)(27,31);
      GPR(RA) = GPR(RS) &gt;&gt; n;
    };
  }

  // Special instruction:  This is used for simulation purposes and is
  // not a PPC instruction.
  define (instr=halt) {
    width = 32;
    fields=(OPCD(0));
    action = {
      halt();
    };
  }

}

define (core = P) {
  archs = MiniPPC;
}
</pre>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="uadl-manual.rst">View document source</a>.
Generated on: 2018/02/28 15:14:29 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
