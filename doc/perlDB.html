<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="standard header">
  <link type="text/css" rel="stylesheet" href="/swo/css/fsl.css" />
  <script type="text/javascript" language="javascript" src="/swo/jscripts/FSLHeader.js"></script>
  <script language="JavaScript"> 
        WriteFSHeader(); 
  </script> 
</div></div>
<div class="footer">
<hr class="footer" />
<a class="first last reference" href="./fsl-header.rst">View document source</a>.
Generated on: 2018/02/28 15:14:25 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<title>ADL Perl database interface</title>
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="title section" id="adl-perl-database-interface">
<h1><a>ADL Perl database interface</a></h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first"><a name="table-of-contents">Table of Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#adl-perl-database-interface" id="id1" name="id1">ADL Perl database interface</a><ul class="simple">
<li><a class="reference" href="#command-line" id="id2" name="id2">Command line</a></li>
<li><a class="reference" href="#instruction-database" id="id3" name="id3">Instruction database</a><ul class="simple">
<li><a class="reference" href="#instruction-fields" id="id4" name="id4">Instruction fields</a></li>
<li><a class="reference" href="#syntax" id="id5" name="id5">Syntax</a></li>
<li><a class="reference" href="#alias" id="id6" name="id6">Alias</a></li>
<li><a class="reference" href="#description-string" id="id7" name="id7">Description string</a></li>
<li><a class="reference" href="#name" id="id8" name="id8">Name</a></li>
<li><a class="reference" href="#attributes" id="id9" name="id9">Attributes</a></li>
<li><a class="reference" href="#sourcetargets" id="id10" name="id10">Source/Targets</a></li>
<li><a class="reference" href="#new-fields-not-present-at-qiset" id="id11" name="id11">New fields (not present at QISET)</a></li>
<li><a class="reference" href="#nested-instructions" id="id12" name="id12">Nested instructions</a></li>
<li><a class="reference" href="#nested-database-objects" id="id13" name="id13">Nested database objects</a></li>
</ul>
</li>
<li><a class="reference" href="#summary-of-queries-and-output" id="id14" name="id14">Summary of queries and output</a></li>
<li><a class="reference" href="#query-about-other-objects-not-instructions" id="id15" name="id15">Query about other objects (not instructions)</a></li>
<li><a class="reference" href="#additional-features-to-be-implemented" id="id16" name="id16">Additional features to be implemented </a></li>
<li><a class="reference" href="#future-features-not-implemented-at-the-moment" id="id17" name="id17">Future features (not implemented at the moment)</a></li>
<li><a class="reference" href="#query-syntax" id="id18" name="id18">Query syntax</a></li>
<li><a class="reference" href="#nice-to-have" id="id19" name="id19">Nice to have</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="command-line">
<h2><a class="toc-backref" href="#id2" name="command-line">Command line</a></h2>
<p>Syntax:</p>
<pre class="literal-block">adl-db --core=&lt;core_name&gt; --object=&lt;object_name&gt; --cond=&lt;perl_cond&gt; 
             --format=&lt;format_string&gt; --sort=&lt;fields_list&gt; --expand=&lt;obj&gt; 
              --output=out.txt database_file.pl
</pre>
<p>Describe options briefly, will be clarified below:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--output=<var>&lt;filename&gt;</var></span>, <span class="option">-o=<var>&lt;filename&gt;</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Output file name.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--core=<var>&lt;core name&gt;</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Optional, specifies the core of interest. In general, ADL database may consist of several cores and systems, systems may also consist of systems and cores. Core consists of registers, regfiles etc. In such a case core can be defined like this: <tt class="docutils literal"><span class="pre">--core='PSystem::PChip::Core'</span></tt>. If only one core is present in the database then it is not necessary to specify this option.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--object=<var>&lt;object name&gt;</var></span>, <span class="option">-obj=<var>&lt;object name&gt;</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Optional, specifies object to be queried, Possible options are: <tt class="docutils literal"><span class="pre">instrs,</span> <span class="pre">instrfields</span> <span class="pre">(or</span> <span class="pre">ifields)</span> <span class="pre">,</span> <span class="pre">regs,</span> <span class="pre">exceptions,</span> <span class="pre">contexts</span> <span class="pre">(or</span> <span class="pre">ctxs),</span> <span class="pre">caches,eventbuses</span> <span class="pre">,memories</span> <span class="pre">(or</span> <span class="pre">mems),</span> <span class="pre">core-level-hooks</span> <span class="pre">(or</span> <span class="pre">hooks)</span></tt>. Default is <tt class="docutils literal"><span class="pre">instrs</span></tt>. Note that <tt class="docutils literal"><span class="pre">regs</span></tt> refers to registers and register files.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--cond=<var>&lt;expr&gt;</var></span>, <span class="option">-c=<var>&lt;expr&gt;</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Optional, specifies query that is interpreted as a filter, the program outputs entries that satisfy the condition specified, syntax resembles perl. Default is to '1', which means that all objects pass this test and will be printed out.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--format=<var>&lt;string&gt;</var></span>, <span class="option">-f=<var>&lt;string&gt;</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Optional, specify the format of output. Default is <tt class="docutils literal"><span class="pre">'name:40,syntax:40'</span></tt>, where <tt class="docutils literal"><span class="pre">name</span></tt> is the ADL name of, say, instruction.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--sort=<var>&lt;string list&gt;</var></span>, <span class="option">-s=<var>&lt;string list&gt;</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Optional, specifies fields by which to sort output, default is object's name.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--multi-line</span>, <span class="option">-M</span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Optional, specifies that output should be wrapped on multiple lines if not fitted to a single line.</td></tr>
<tr><td class="option-group" colspan="2">
<kbd><span class="option">--expand=<var>&lt;obj list&gt;</var></span>, <span class="option">-e=<var>&lt;obj list&gt;</var></span></kbd></td>
</tr>
<tr><td>&nbsp;</td><td>Optional, specifies object to be expanded. Only applicable to instructions and instruction fields. If object list is empty then in case of instructions every instructions every field to be expanded. When applied to instruction fields only empty list is allowed.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">--help <var>-h</var></span></kbd></td>
<td>Will print help, In conjunction with <tt class="docutils literal"><span class="pre">--cond</span></tt>,``--format``,``--object`` or <tt class="docutils literal"><span class="pre">--expand</span></tt> will provide some addtional information about this options.</td></tr>
</tbody>
</table>
<p>Instruction example:</p>
<pre class="literal-block">adl-db --cond='name =~ /do/' --format='name:5,syntax:10,action:10, fields:5'
  --sort='block,type'  --expand='FFF,BBB,CCC' --output='aaa' file.pl
</pre>
<ul>
<li><p class="first"><em>--core</em> is not specified, so only one core is present.</p>
</li>
<li><p class="first"><em>--object</em> is not specified, so instructions are assumed.</p>
</li>
<li><p class="first"><em>--cond='name =~ /do/'</em> : Take instructions which name matches <em>'do'</em>.</p>
</li>
<li><p class="first"><em>--format='name:5,syntax:10,action:10, fields:5'</em>: Means: print name in a 5 character's wide column, syntax in 10, action also in 10 and a list of fields in 5 character's wide column.</p>
</li>
<li><p class="first"><em>'--sort='block,type''</em>  : Sort according to a <em>block</em> and then according to a <em>type</em>, <em>name</em> is implicitly the last element of the sort priority.</p>
</li>
<li><p class="first"><em>'--expand='FFF,BBB,CCC'</em>: Let us assume that</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">AAA</span></tt> is a nested field referencing to the register file <tt class="docutils literal"><span class="pre">D</span></tt>, so it will be expanded according to its syntax (if present): <tt class="docutils literal"><span class="pre">"d0,d1","d0,d2"</span></tt>, etc.</li>
<li>For <tt class="docutils literal"><span class="pre">BBB</span></tt> let's assume that it is an enumerated field with the following possible values:   <tt class="docutils literal"><span class="pre">("r0)","r0)+","r0-)","r0)-",</span> <span class="pre">...</span> <span class="pre">,"r15)-")</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">CCC</span></tt> will be expanded accordingly to the syntax of entries of the regfile it is referenced.</li>
<li><tt class="docutils literal"><span class="pre">IMM</span></tt> cannot be not expanded.</li>
</ul>
</blockquote>
</li>
</ul>
<p>Output:</p>
<pre class="literal-block">Name     Syntax           Action   Fields
sdo     do AAA,d0,d1       {...}    AAA,FFF
sdo     do AAA,d0,d2       {...}    AAA,FFF
        ...
sdo     do AAA,d15,d0      {...}    AAA,FFF

do1     do AAA,(r0)        {...}    AAA,BBB
do1     do AAA,(r0+)       {...}    AAA,BBB
        ...
do1     do AAA,(r15)-      {...}    AAA,BBB

do2     do AAA,r1.l        {...}    AAA,CCC
do2     do AAA,r2.h        {...}    AAA,CCC
            ...
do2     do AAA,d5.e        {...}    AAA,CCC

do5     do AAA,-IMM        {...}    AAA,IMM
</pre>
<p>One more example of expand, now for an instruction fields (instruction fields
are from the previous example). Note, that when instruction field is expanded it
does not require <em>--format</em>:</p>
<pre class="literal-block">Options:
--object=instrfields --cond='(name eq BBB) || (name eq FFF))' --expand 

Output:   
        Field: BBB
      Entry        Value
      "r0)"          0
      "r0)+"         1
            ...         
      "r15)-"        35

        Field: FFF
      "d0,d1"        0
           ...
      "d1,r56"       3
</pre>
</div>
<div class="section" id="instruction-database">
<h2><a class="toc-backref" href="#id3" name="instruction-database">Instruction database</a></h2>
<p>Users are currently interested in instructions database, so we will go through
all fields that instruction entry has and describe how to query and how to
specify it in the output.</p>
<div class="section" id="instruction-fields">
<h3><a class="toc-backref" href="#id4" name="instruction-fields">Instruction fields</a></h3>
<p>Pseudo instruction field have two representation: abstract definition and inst
implementations.</p>
<p>For example: 'DaDb' as an abstract field and a specific implementation is
defined in a specific instruction. This will not lead to confusion:</p>
<pre class="literal-block">--cond='fields =~/DaDb/' : all instructions with DaDb - clearly refers to abstract.
--cond='fields-&gt;ref eq "D"' also  abstract (about sub-objects see below).
</pre>
<p>Format specificator <em>'bits'</em> will output bits and values of all instruction
field (shows implementation of DaDb):</p>
<pre class="literal-block">Name       Action   Prefix     Fields     Bits
sdo        {...}      0        AAA,DaDb   DaDb:[0,1],[5,5],[2,3],
                                          BBB:[10,11],[15,15],[12,13]
                                          OPCD1(30):[10,11],[15,15],[12,13]
</pre>
<p>Instruction fields are also can be also shown using the <em>'enc'</em> specificator in
<em>'--format'</em>, in this case encoding is shown as a bit vector - 'R' for
<em>reserved</em>, <em>0</em> and <em>1</em> for opcode and any other characters specify fields:</p>
<pre class="literal-block"> --output='name:enc'
Name          Encoding
mac           FSS1001FFGG10033333
</pre>
<p>There should be special field in ADL description that defines which character
represents the field.</p>
<p>Opcodes are not considered as fields in <em>--cond</em> and in <em>--output</em>,</p>
<p>Database representation of fields is an array of strings, so using 'fields'
keyword in the condition means to test each field individually.</p>
<p>Examples of queries:</p>
<pre class="literal-block">--cond='fields =~/FFF/' -- return instructions that have non opcode field which name matches 'FFF'.
--format='fields:5'     -- print non-opcode field names (abstract)
--format='enc:30'       -- print encoding
</pre>
</div>
<div class="section" id="syntax">
<h3><a class="toc-backref" href="#id5" name="syntax">Syntax</a></h3>
<p>Database representation:</p>
<pre class="literal-block">"syntax" =&gt; "IMACLHUU jjj,JJJ,FFF",
</pre>
<p>Query: will handle it like a string, for example:</p>
<pre class="literal-block">--cond='syntax =~/FFF/' 
</pre>
<p>Output specified by <em>syntax</em>.</p>
</div>
<div class="section" id="alias">
<h3><a class="toc-backref" href="#id6" name="alias">Alias</a></h3>
<p>Query:</p>
<ul>
<li><p class="first">test if it is an  alias</p>
<pre class="literal-block">--cond='is_alias'
</pre>
</li>
<li><p class="first">test if is an alias to some specific instruction:</p>
<pre class="literal-block">--cond='is_alias eq 'bmclr4''
</pre>
</li>
</ul>
<p>Output:</p>
<ul>
<li><p class="first">If <em>action</em> specificator is used then alias shown output:</p>
<pre class="literal-block">Name    Syntax            Action
do1     do a,b      alias="do11 a(a),b(b),c(0)"
</pre>
</li>
<li><p class="first">The <em>alias</em> specificator can be also used, it is empty for usual instructions:</p>
<pre class="literal-block">--cond='is_alias &amp;&amp; name =~ /do1/' --output='name:4,syntax:4,action:4'
   Name    Syntax            Action
   do1     do a,b      alias="do11 a(a),b(b),c(0)"
--cond='name =~ /do1/' --output='name:4,syntax:4,alias:4"
   Name    Syntax            Alias
   do1     do a,b      alias="do11 a(a),b(b),c(0)"
   do11    do a,b,c      
</pre>
</li>
</ul>
</div>
<div class="section" id="description-string">
<h3><a class="toc-backref" href="#id7" name="description-string">Description string</a></h3>
<p>Description string is accessed using <em>desc</em> key-word:</p>
<pre class="literal-block">--cond="desc =~ /halt/"
--output="name:43:desc"
</pre>
</div>
<div class="section" id="name">
<h3><a class="toc-backref" href="#id8" name="name">Name</a></h3>
<p>In ADL resources have names, allow to ask about it.
Queries:</p>
<pre class="literal-block">--cond="name eq FFF" --object=field
--cond="name != /add/"
</pre>
<p>Instructions will have additional field called <em>iname</em> which is the name deduced from syntax, i.e.:</p>
<pre class="literal-block">define (instr=add3) {
  syntax = ("add %f,%f",...);
}
</pre>
<p>Here the <em>name</em> is <em>add3</em>, while the <em>iname</em> is <em>add</em>. Note, that the name is
unique among objects of the same type but the <em>iname</em> is not. Also, it only can
be used with instructions.</p>
</div>
<div class="section" id="attributes">
<h3><a class="toc-backref" href="#id9" name="attributes">Attributes</a></h3>
<p>Will handle like user-defined field in the database.</p>
<p>Unparameterized attributes will be handled like strings.</p>
<p>Query:</p>
<pre class="literal-block">--cond='attrs =~ /agu_/' 
</pre>
<p>will match instructions with attributes agu_l,agu_r etc.</p>
<p>Attributes are added as keys to the object's hash.  If the attribute has no
value, then it is still added with an empty value.  This allows the user to
query for an attribute using <tt class="docutils literal"><span class="pre">exists</span></tt> or to check the value using a normal
expression:</p>
<pre class="literal-block">--cond='exists first or second &gt; 7'
</pre>
<p>This will match any items which have an attribute named <strong>first</strong> or an
attribute named <strong>second</strong> with a value greater than 7.</p>
<p>Attributes parametrized by integers will allow two types of questions:</p>
<ul>
<li><p class="first">Whether the object has some attribute, in this case "attrs" is used:</p>
<pre class="literal-block">--cond='attrs =~/cycles/'
</pre>
</li>
<li><p class="first">Whether the object has some attribute with some specific constraint on value,
in this case name of attribute is used like a database field specificator:</p>
<pre class="literal-block">--cond='cycles &gt; 3'
</pre>
</li>
</ul>
<p>assuming that a resource has integer attribute 'cycles'.</p>
<p>Attributes parametrized by string will be handled in the similar way, only
parameter now is a string.  Suppose some instruction has attributes:</p>
<pre class="literal-block">attrs=(meminfo("read_d0"),cycles(3));
</pre>
<p>So queries:</p>
<pre class="literal-block">"attrs =~/mem_info/"    ask for instructions attributed with some mem_info
"mem_info  =~ /^read/" - mem_info with read at the beginning (like in our example).
</pre>
<p>Parametrized by a list of integers or a list of strings will not be supported.</p>
</div>
<div class="section" id="sourcetargets">
<h3><a class="toc-backref" href="#id10" name="sourcetargets">Source/Targets</a></h3>
<p>In database represented as an array of strings:</p>
<pre class="literal-block">"inputs" =&gt; ["DRTable(HHHH)?",]
"outputs" =&gt; ["DRTable(HHHH)?","L?",]
</pre>
<p>Query will apply to every string individually:</p>
<pre class="literal-block"> --cond='inputs =~ /FFF/' means that one of inputs has FFF.

Query:
--cond='outputs =~ HHHH' --output='name:14,syntax:14,inputs:14,outputs:14'
Output:
 Name   Syntax       Inputs   Outputs
 add  add FFF,HHHH   D(HHHH)  D(HHHH)
</pre>
</div>
<div class="section" id="new-fields-not-present-at-qiset">
<h3><a class="toc-backref" href="#id11" name="new-fields-not-present-at-qiset">New fields (not present at QISET)</a></h3>
<ul class="simple">
<li>block: handle like attribute (i.e. parametrized by a string)</li>
<li>prefix: boolean (true/false)  ( --cond='prefix=true and ...')</li>
<li>pseudo: boolean (true/false)  ( the same)</li>
<li>type: like attribute         ( --cond='type =~ /OneWord/')</li>
<li>width/fetch_width: numeric   ( --cond='width &gt; 32')</li>
<li>helpers: array of strings     ( --helpers='helpers =~ /saturation32/)</li>
</ul>
</div>
<div class="section" id="nested-instructions">
<h3><a class="toc-backref" href="#id12" name="nested-instructions">Nested instructions</a></h3>
<p>Nested instructions will be interpreted as usual instructions, i.e not aliases:</p>
<pre class="literal-block">define (instr = add) {
 define (instr = add1) {
   alias = add ...
 }
 define (instr = add2) {
   alias = add ..
 }
 action = {
   ...
 };
}
</pre>
<p>Instructions <em>add1</em> and <em>add2</em> should be queried like usual instructions.</p>
</div>
<div class="section" id="nested-database-objects">
<h3><a class="toc-backref" href="#id13" name="nested-database-objects">Nested database objects</a></h3>
<p>By nested objects we understand nested database structures. For example instruction field has an optional reference:</p>
<pre class="literal-block">define(instrfield=DaDb) {
  ref=D;
}
</pre>
<p>We will support the following syntax for some of objects:</p>
<pre class="literal-block">object-&gt;subobject
</pre>
<p>We know that field of any instructions should be described in "instrfields" database, so this can be used:</p>
<pre class="literal-block">--object=instr --cond='width==32 &amp;&amp; "fields-&gt;ref eq D"
</pre>
<p>This means the following: choose instructions which have width equal to 32, and have at least one field referenced to "D".</p>
<p>It is also possible to omit "fields" from the query, in this case every subobject will be queried:</p>
<pre class="literal-block">--object=instr --cond='width==32 &amp;&amp; "valid_ranges"
</pre>
</div>
</div>
<div class="section" id="summary-of-queries-and-output">
<h2><a class="toc-backref" href="#id14" name="summary-of-queries-and-output">Summary of queries and output</a></h2>
<p>Every format specificator can be used in condition.
All above-mentioned fields can appear in format.</p>
<ul class="simple">
<li><em>name</em>:       unique ADL name</li>
<li><em>iname</em>:        only for instructions: mnemonic name as written in syntax.</li>
<li><em>enc</em>:          encoding in binary format</li>
<li><em>fields</em>:      non-opcode abstract fields</li>
<li><em>bits</em>:        all fields with bits</li>
<li><em>syntax</em>:      syntax</li>
<li><em>action</em>:      action or alias definition</li>
<li><em>is_alias</em>:    non-empty in the case of alias, keeps name of the target instruction.</li>
<li><em>alias</em>:       if alias then alias definition, otherwise empty.</li>
<li><em>desc</em>:        description string</li>
<li><em>inputs</em>:      source fields</li>
<li><em>outputs</em>:     destinations fields</li>
<li><em>block</em>:       handle like attribute (i.e. parametrized by a string)</li>
<li><em>prefix</em>:      if it is a prefix instruction</li>
<li><em>pseudo:</em>      if it is a pseudo instruction</li>
<li><em>type</em>:        which type</li>
<li><em>width</em>:       virtual width (including prefix bits)</li>
<li><em>fetch_width</em>: real width</li>
<li><em>helpers</em>:     name of helpers instruction uses</li>
<li><em>attrs</em>:       list names of all attributes of this instructions</li>
<li><em>&lt;attrname&gt;</em>: For usual attribute print true or false, for functional attribute print its values.</li>
</ul>
</div>
<div class="section" id="query-about-other-objects-not-instructions">
<h2><a class="toc-backref" href="#id15" name="query-about-other-objects-not-instructions">Query about other objects (not instructions)</a></h2>
<p>Specified by the option <em>--object</em>.  Fields of objects can be used in the
condition and in the output specification.  Every query should be correct
perl-like condition, i.e:</p>
<pre class="literal-block">--object=regfiles --cond='name ~/AA/'
--object=regfiles --cond='size &gt;= 32'
--object=regfiles --cond='alias-&gt;name eq "D"'
</pre>
<p>Output:
Default output will show perl structure, i.e:</p>
<pre class="literal-block">--object=regfiles --cond='name eq C1Tablee' --format='size:7,width:10,sparse:20'

 Size     Width     Sparse
  8        32      "0" =&gt; { "name =&gt; "EMR"}
                   "1" =&gt; { "name =&gt; "D"}
                   "5" =&gt; { "read" =&gt; { "action" =&gt; " "}} 
</pre>
<p>We can define special output for some cases, if needed.</p>
</div>
<div class="section" id="additional-features-to-be-implemented">
<h2><a class="toc-backref" href="#id16" name="additional-features-to-be-implemented">Additional features to be implemented </a></h2>
<ul class="simple">
<li>Possibility to output a perl database filtered by some condition.</li>
<li>Print header describing database used and query used.</li>
<li>Multi-page printing, with header on each page.</li>
<li>Possibility to explore DB and dynamically understand what can be asked and
how, for example new integer key was added to ADL -&gt; report that it can be
queried as integer).</li>
</ul>
</div>
<div class="section" id="future-features-not-implemented-at-the-moment">
<h2><a class="toc-backref" href="#id17" name="future-features-not-implemented-at-the-moment">Future features (not implemented at the moment)</a></h2>
<ul>
<li><p class="first">Allow formating of the description string:</p>
<pre class="literal-block">"""
General::
  Adds two data registers .
Remarks::
  Affects SPR
""";
</pre>
<p>If this formatting is used user can print out specific part of the description string in the output:</p>
<pre class="literal-block">--output="name:43:desc-&gt;General"
</pre>
<p>The program will search description for the tag "General::" and print everything until the next tag (in this case "Remarks").</p>
</li>
<li><p class="first">Support for register fields in sources or destinations. So if, for example,
only true bit of the status register is written then targe looks like:</p>
<pre class="literal-block">"outputs" =&gt; [ "SR.T ],
</pre>
</li>
<li><p class="first">Support for attributes parametrized by lists.</p>
</li>
</ul>
</div>
<div class="section" id="query-syntax">
<h2><a class="toc-backref" href="#id18" name="query-syntax">Query syntax</a></h2>
<p>Perl database must reflect structure of ADL file.  Named define block is key of
anonymous hash referecing another hash, in which erever key (including unnamed
blocks) is a property.  Key implicitly accesseble as a property called "name":</p>
<pre class="literal-block">ADL :

define (obj=B) {
  prop1  = 8;
  prop2 = 32;
  define (prop3) {
    define (prop4=1) { reg  = ((8,15));
  }
  prefix = b;
}

PERL:

"B" =&gt; {
  "width" =&gt; 32,
  "pseudo" =&gt; 1,
  "size" =&gt; 8,
  "prefix" =&gt; "b",
  "shared" =&gt; 0,
  "read" =&gt; {
     "alias" =&gt; {
        "name" =&gt; "R",
        "map" =&gt; {
          "0" =&gt; 8,
          "1" =&gt; 9,
          "2" =&gt; 10,
          "3" =&gt; 11,
          "4" =&gt; 12,
          "5" =&gt; 13,
          "6" =&gt; 14,
          "7" =&gt; 15,
        },
      },
    },
</pre>
</div>
<div class="section" id="nice-to-have">
<h2><a class="toc-backref" href="#id19" name="nice-to-have">Nice to have</a></h2>
<ul class="simple">
<li>Automatic formatting: User will not specify width of some columns, program
should adjust it automatically.</li>
</ul>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="perlDB.rst">View document source</a>.
Generated on: 2018/02/28 15:14:26 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
