<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="standard header">
  <link type="text/css" rel="stylesheet" href="/swo/css/fsl.css" />
  <script type="text/javascript" language="javascript" src="/swo/jscripts/FSLHeader.js"></script>
  <script language="JavaScript"> 
        WriteFSHeader(); 
  </script> 
</div></div>
<div class="footer">
<hr class="footer" />
<a class="first last reference" href="./fsl-header.rst">View document source</a>.
Generated on: 2018/02/28 15:14:25 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<title>GDB Configuration Guide</title>
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="title section" id="gdb-configuration-guide">
<h1><a>GDB Configuration Guide</a></h1>
<p>This document will describe the steps necessay to use gdb to debug an
ADL model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Brian Kahne, Lu Hao</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body"><a class="reference" href="mailto:bkahne&#64;freescale.com">bkahne&#64;freescale.com</a>, <a class="reference" href="mailto:lu.hao&#64;freescale.com">lu.hao&#64;freescale.com</a></td>
</tr>
</tbody>
</table>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first"><a name="table-of-contents">Table of Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#gdb-configuration-guide" id="id1" name="id1">GDB Configuration Guide</a><ul class="auto-toc simple">
<li><a class="reference" href="#overview" id="id2" name="id2">1&nbsp;&nbsp;&nbsp;Overview</a><ul class="auto-toc simple">
<li><a class="reference" href="#basic-operation" id="id3" name="id3">1.1&nbsp;&nbsp;&nbsp;Basic Operation</a></li>
<li><a class="reference" href="#multi-processor-support" id="id4" name="id4">1.2&nbsp;&nbsp;&nbsp;Multi-Processor Support</a></li>
<li><a class="reference" href="#hardwaresoftware-debug-support" id="id5" name="id5">1.3&nbsp;&nbsp;&nbsp;Hardware/Software Debug Support</a></li>
</ul>
</li>
<li><a class="reference" href="#installing-gdb" id="id6" name="id6">2&nbsp;&nbsp;&nbsp;Installing GDB</a></li>
<li><a class="reference" href="#setup-gdb-configuration-file" id="id7" name="id7">3&nbsp;&nbsp;&nbsp;Setup GDB configuration File</a></li>
<li><a class="reference" href="#connecting-gdb-to-adl" id="id8" name="id8">4&nbsp;&nbsp;&nbsp;Connecting GDB To ADL</a><ul class="auto-toc simple">
<li><a class="reference" href="#socket-based-approach" id="id9" name="id9">4.1&nbsp;&nbsp;&nbsp;Socket-based Approach</a></li>
<li><a class="reference" href="#standard-io-approach-currently-disabled" id="id10" name="id10">4.2&nbsp;&nbsp;&nbsp;Standard I/O Approach (currently disabled)</a></li>
<li><a class="reference" href="#hardwaresoftware-debug-mode" id="id11" name="id11">4.3&nbsp;&nbsp;&nbsp;Hardware/Software debug mode</a></li>
</ul>
</li>
<li><a class="reference" href="#helper-macros" id="id12" name="id12">5&nbsp;&nbsp;&nbsp;Helper Macros</a></li>
<li><a class="reference" href="#remote-serial-protocol-notes" id="id13" name="id13">6&nbsp;&nbsp;&nbsp;Remote Serial Protocol Notes</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id2" name="overview">1&nbsp;&nbsp;&nbsp;Overview</a></h2>
<div class="section" id="basic-operation">
<h3><a class="toc-backref" href="#id3" name="basic-operation">1.1&nbsp;&nbsp;&nbsp;Basic Operation</a></h3>
<p>The primary option needed to run the ADL model so that it can be connected to
GDB is the <tt class="docutils literal"><span class="pre">-g</span></tt> option.  This places the ADL model into the debug mode; the
model will attempt to attach to a port and wait for GDB commands.  The default
port is 0, which means that an unused port will be selected.  The model will
then print the port that was selected.  If the model is started with the
<tt class="docutils literal"><span class="pre">--jit</span></tt> option, and the model was built with dynamic-binary-translation
support, then during the debugging session, the high-speed translation mechanism
will be used whenever the <em>continue</em> command is issued.</p>
<p>If the <tt class="docutils literal"><span class="pre">--port-file=&lt;path&gt;</span></tt> or <tt class="docutils literal"><span class="pre">--pf=&lt;path&gt;</span></tt> option is used, the model will
create a file of the specified name and write a GDB target command to that file,
containing the port number it is using.  This file can then be sourced by GDB
using the <tt class="docutils literal"><span class="pre">source</span></tt> command.  Alternatively, an explicit port may be specified
by using the <tt class="docutils literal"><span class="pre">--port=&lt;num&gt;</span></tt> or <tt class="docutils literal"><span class="pre">--p=&lt;num&gt;</span></tt> option.</p>
<p>GDB may also communicate with an ADL model using standard input/output.  This is
often the preferred choice, since it results in higher performance.  However, it
is not usable if the workload running on the ADL model is using system calls and
displaying to standard out.  To use this feature, use the <tt class="docutils literal"><span class="pre">--gdb-stdio</span></tt> option.</p>
<p>UDP packets may also be used by specifying <tt class="docutils literal"><span class="pre">-gdb-udp</span></tt>.  Use of UDP packets is
technically unreliable over a network but works fine if the host and simulator
are running on the same machine.  Performance is also quite a bit better than
for TCP packets.</p>
</div>
<div class="section" id="multi-processor-support">
<h3><a class="toc-backref" href="#id4" name="multi-processor-support">1.2&nbsp;&nbsp;&nbsp;Multi-Processor Support</a></h3>
<p>The preferred method for handling multi-core simulations is to connect a single
instance of GDB to the simulator.  Each core will appear as a thread to GDB.
Using a GUI interface, such as Emac's Gud mode, you can then easily switch
between threads, set thread-specific breakpoints, etc.  This method works for
decode-cache models and the multi-threaded simulation kernel.</p>
<p>Is is also possible to connect multiple debuggers, each to their own core.  This
is only supported using TCP or UDP protocols for non-MT interpreted models.  For
an MP situation, the <tt class="docutils literal"><span class="pre">port</span></tt> and <tt class="docutils literal"><span class="pre">port-file</span></tt> options take a comma-separated
list, where each element in the list is of the form <tt class="docutils literal"><span class="pre">&lt;path&gt;=&lt;value&gt;</span></tt>.  For
<tt class="docutils literal"><span class="pre">port</span></tt>, the value is a port number, or 0 to select an available port.  For
<tt class="docutils literal"><span class="pre">port-file</span></tt>, the value is the name of a file to which to write connection
data.  Each path is a colon-delimited path identifying a core in the simulation.
Cores and systems are valid targets; context-based threads may not be directly
targeted.  In the case of a system, all constituent cores and context-based
threads will be registered as threads to the debugger.  In the case of cores,
any context-based threads will be registered as threads.</p>
<p>For example, given an ADL simulator with a top-level system named <tt class="docutils literal"><span class="pre">MP</span></tt> which
contains two cores <tt class="docutils literal"><span class="pre">p0</span></tt> and <tt class="docutils literal"><span class="pre">p1</span></tt>, the command-line options to use the UDP
protocol would be:</p>
<pre class="literal-block">... --gdb-udp --port-file=MP:p0=port0,MP:p1=port1
</pre>
<p>Since no <tt class="docutils literal"><span class="pre">port</span></tt> option was specified, two available ports would be allocated.
The connection data would be written to the files <tt class="docutils literal"><span class="pre">port0</span></tt> and <tt class="docutils literal"><span class="pre">port1</span></tt>.</p>
</div>
<div class="section" id="hardwaresoftware-debug-support">
<h3><a class="toc-backref" href="#id5" name="hardwaresoftware-debug-support">1.3&nbsp;&nbsp;&nbsp;Hardware/Software Debug Support</a></h3>
<p>Hardware/Software debug is a feature under development.  It allows user to do
post-processing Hardware/Software debug using a trace file. Currently it
supports TARMAC trace for Cortex-M0+. In the future it will support for more
architectures including PowerPC.</p>
</div>
</div>
<div class="section" id="installing-gdb">
<h2><a class="toc-backref" href="#id6" name="installing-gdb">2&nbsp;&nbsp;&nbsp;Installing GDB</a></h2>
<p>The standard installation procedures for GDB works with the ADL
interface.  To generate a version of GDB to work with a 32 or 64-bit PowerPC,
configure GDB with <tt class="docutils literal"><span class="pre">--target=ppc-elf</span></tt>.  For example:</p>
<pre class="literal-block">./configure --target=ppc-elf --prefix=&lt;install_path&gt;
</pre>
<p>You can also configure GDB for other supported targets.  All you need is changing
the <tt class="docutils literal"><span class="pre">--target=&lt;target&gt;</span></tt> argument.  All supported targets can be found in:</p>
<pre class="literal-block">gdb-x.x/bfd/config.bfd
</pre>
<p>(file location may vary for different gdb versions).</p>
<p>A more convenient way is to find the already compiled binary file for your target, and
just download and use it.</p>
</div>
<div class="section" id="setup-gdb-configuration-file">
<h2><a class="toc-backref" href="#id7" name="setup-gdb-configuration-file">3&nbsp;&nbsp;&nbsp;Setup GDB configuration File</a></h2>
<p>An ISS's configuration file (specified using the <tt class="docutils literal"><span class="pre">--confg=&lt;file&gt;</span></tt> option) specifies a register
ordering that maps the model's registers to the register model used by GDB.  It is written in 
TCL.  For example, the following code fragment creates a 32-bit Power register mapping:</p>
<pre class="literal-block">set regs ""
for {set i 0} {$i &lt; 32} {incr i} {
      lappend regs "GPR$i:32";
}
for {set i 0} {$i &lt; 32} {incr i} {
      lappend regs 64;
}
lappend regs NIA:32 MSR:32 CR:32 LR:32 CTR:32 XER:32 32

eval setregmap powerpc $regs
</pre>
<p>The register names such as <tt class="docutils literal"><span class="pre">NIA</span></tt>, <tt class="docutils literal"><span class="pre">MSR</span></tt> are register names specified in ADL model. 
the number <tt class="docutils literal"><span class="pre">32</span></tt> or <tt class="docutils literal"><span class="pre">64</span></tt> following the register names (and sometimes the colon) are
the register width accepted in GDB.  Following the same format, users can create register
mappings for other architectures.</p>
<p>You must ensure that the register model in the configuration script matches GDB's
register model exactly.  One way to figure out GDB's register model is to go to:</p>
<pre class="literal-block">gdb-x.x/gdb/features/
</pre>
<p>first open <tt class="docutils literal"><span class="pre">Makefile</span></tt>, find in <tt class="docutils literal"><span class="pre">WHICH</span></tt> field the one best describes the target
you have, then find the corresponding xml files and see its register list with name
and size.</p>
<p>Another way is to start GDB with the machine interpreter, launch a simulation, then
query for the register names and values:</p>
<pre class="literal-block">./gdb --interpreter=mi
(gdb) source iss-macros.gdb
(gdb) startsimarch  &lt;model_path&gt; &lt;elf_file_name&gt; &lt;architecture&gt;
(gdb) -data-list-register-names
(gdb) -data-list-register-values r
</pre>
<p>The register values are printed in raw hex format, with one hex digit per
nibble.</p>
<p>GDB may recognize different register size from the one in ADL model, this may require 
size adjustments to the registers.  For example, if register <tt class="docutils literal"><span class="pre">FOO</span></tt> is a 64-bit register 
in ADL model, but GDB thinks that it is a 32-bit register, then the corresponding entry 
in the register map should be:</p>
<pre class="literal-block">FOO:32
</pre>
<p>This will cause the ADL model to only send the least-significant 32 bits of
<tt class="docutils literal"><span class="pre">FOO</span></tt> to GDB.</p>
<p>Please refer to the ADL CLI reference manual for details on the <em>.ttc</em> file format.</p>
</div>
<div class="section" id="connecting-gdb-to-adl">
<h2><a class="toc-backref" href="#id8" name="connecting-gdb-to-adl">4&nbsp;&nbsp;&nbsp;Connecting GDB To ADL</a></h2>
<div class="section" id="socket-based-approach">
<h3><a class="toc-backref" href="#id9" name="socket-based-approach">4.1&nbsp;&nbsp;&nbsp;Socket-based Approach</a></h3>
<p>Launch the simulator from the command-line:</p>
<pre class="literal-block">&lt;model&gt; &lt;elf_file&gt; --config=&lt;mapping script&gt; --port-file=.gdbport
</pre>
<p>Start GDB from the command-line in another window:</p>
<pre class="literal-block">gdb &lt;elf_file&gt;
</pre>
<p>Set the architecture:</p>
<pre class="literal-block">(gdb) set archi &lt;architecture&gt;
</pre>
<p>The above command is required for 64-bit PowerPC because GDB contains a bug
which erroneously sets the architecture to <tt class="docutils literal"><span class="pre">e500</span></tt> for any BookE ELF file.  In
such a case, you would issue the following command:</p>
<pre class="literal-block">(gdb) set archi powerpc:common64
</pre>
<p>Source the port file in order to connect to the simulator:</p>
<pre class="literal-block">(gdb) so .gdbport
</pre>
<p>Run your program:</p>
<pre class="literal-block">(gdb) break main
(gdb) continue
</pre>
<p>The use of <tt class="docutils literal"><span class="pre">extended-remote</span></tt> means that the simulation can be reset.  In other
words, issuing the <tt class="docutils literal"><span class="pre">run</span></tt> command will reset the model and re-run the program
from the beginning.</p>
</div>
<div class="section" id="standard-io-approach-currently-disabled">
<h3><a class="toc-backref" href="#id10" name="standard-io-approach-currently-disabled">4.2&nbsp;&nbsp;&nbsp;Standard I/O Approach (currently disabled)</a></h3>
<p>Start GDB from the command-line:</p>
<pre class="literal-block">gdb &lt;elf_file&gt;
</pre>
<p>Set the architecture:</p>
<pre class="literal-block">(gdb) set archi &lt;architecture&gt;
</pre>
<p>The above command is required for 64-bit PowerPC because GDB contains a bug
which erroneously sets the architecture to <tt class="docutils literal"><span class="pre">e500</span></tt> for any BookE ELF file.  In
such a case, you would issue the following command:</p>
<pre class="literal-block">(gdb) set archi powerpc:common64
</pre>
<p>Launch the simulator:</p>
<pre class="literal-block">(gdb) target extended-remote | &lt;model&gt; &lt;elf_file&gt; -g -gdb-stdio --config=&lt;mapping file&gt;
</pre>
<p>Run your program:</p>
<pre class="literal-block">(gdb) break main
(gdb) continue
</pre>
</div>
<div class="section" id="hardwaresoftware-debug-mode">
<h3><a class="toc-backref" href="#id11" name="hardwaresoftware-debug-mode">4.3&nbsp;&nbsp;&nbsp;Hardware/Software debug mode</a></h3>
<p>Launch the simulator from the command-line:</p>
<pre class="literal-block">&lt;model&gt; -trace-run -if=tarmac &lt;tarmac_file&gt; -o=&lt;output_dat_file&gt; -g --fep --sce --config=&lt;mapping script&gt; --port-file=.gdbport
</pre>
<p>Start GDB from the command-line in another window (currently only support arm-none-eabi-gdb):</p>
<pre class="literal-block">arm-none-eabi-gdb &lt;elf_file&gt;
</pre>
<p>Source the port file in order to connect to the simulator:</p>
<pre class="literal-block">(gdb) so .gdbport
</pre>
</div>
</div>
<div class="section" id="helper-macros">
<h2><a class="toc-backref" href="#id12" name="helper-macros">5&nbsp;&nbsp;&nbsp;Helper Macros</a></h2>
<p>The ADL distribution contains a few helper macros for automating the process of
launching a simulator within GDB.  The macros are contained in the file
<tt class="docutils literal"><span class="pre">share/iss-macros.gdb</span></tt>:</p>
<ul>
<li><p class="first"><em>startsim model elf_file</em>: Launch a simulator.  For example, assuming that the
user has the line <tt class="docutils literal"><span class="pre">so</span> <span class="pre">&lt;path-to-adl&gt;/share/iss-macros.gdb</span></tt> in a <tt class="docutils literal"><span class="pre">.gdbinit</span></tt>
file in the current directory:</p>
<pre class="literal-block">gdb
(gdb) startsim ./altair_r1_ut sieve.elf
(gdb) break main
(gdb) continue 
</pre>
<p>This will launch the ADL model named <tt class="docutils literal"><span class="pre">altair_r1_ut</span></tt> with the ELF file
<tt class="docutils literal"><span class="pre">sieve.elf</span></tt>.</p>
</li>
<li><p class="first"><em>startsimarch model elf_file architecture</em>:  Launch a simulator and specify
the target architecture.  For example:</p>
<pre class="literal-block">gdb
(gdb) startsimarch ./altair_r1_ut sieve.elf powerpc:common64
(gdb) break main
(gdb) continue 
</pre>
</li>
</ul>
</div>
<div class="section" id="remote-serial-protocol-notes">
<h2><a class="toc-backref" href="#id13" name="remote-serial-protocol-notes">6&nbsp;&nbsp;&nbsp;Remote Serial Protocol Notes</a></h2>
<p>The current implementation supports the extended run-time control extensions, so
the model may be reset so that a program can be restarted.</p>
<p>By default, the addresses of memory accesses (the <tt class="docutils literal"><span class="pre">m</span></tt> and <tt class="docutils literal"><span class="pre">M</span></tt> RSP commands)
are considered to be effective addresses.  The address is translated using the
MMU and memory is accessed from the top of the memory hierarchy so that any
dirty data in a cache will be seen.</p>
<p>Two additional RSP query commands are implemented so that a client application
may access memory directly without involving the MMU or any caches.  The query
for reading memory is <tt class="docutils literal"><span class="pre">adl.m</span></tt> and has the following form:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">qadl.m</span></tt> <strong>addr</strong>, <strong>length</strong></p>
</blockquote>
<p>To write memory:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">qadl.M</span></tt> <strong>addr</strong>, <strong>length</strong></p>
</blockquote>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="adl-gdb-howto.rst">View document source</a>.
Generated on: 2018/02/28 15:14:26 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
