<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="standard header">
  <link type="text/css" rel="stylesheet" href="/swo/css/fsl.css" />
  <script type="text/javascript" language="javascript" src="/swo/jscripts/FSLHeader.js"></script>
  <script language="JavaScript"> 
        WriteFSHeader(); 
  </script> 
</div></div>
<div class="footer">
<hr class="footer" />
<a class="first last reference" href="./fsl-header.rst">View document source</a>.
Generated on: 2018/02/28 15:14:25 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="prest release 0.3.40" />
<title>The ADL Plugin Interface</title>
<link rel="stylesheet" href="default-rst.css" type="text/css" />
</head>
<body>
<div class="document">
<div class="title section" id="the-adl-plugin-interface">
<h1><a>The ADL Plugin Interface</a></h1>
<div class="section" id="plugins">
<h2><a href="#id2" name="plugins">Plugins</a></h2>
<p>This document describes the ADL plugin interface, which allows users to add
support for additional types of input and output files and system calls.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Brian Kahne</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body"><a class="reference" href="mailto:brian.kahne&#64;freescale.com">brian.kahne&#64;freescale.com</a></td>
</tr>
</tbody>
</table>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first"><a name="table-of-contents">Table of Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#the-adl-plugin-interface" id="id1" name="id1">The ADL Plugin Interface</a><ul class="simple">
<li><a class="reference" href="#plugins" id="id2" name="id2">Plugins</a><ul class="auto-toc simple">
<li><a class="reference" href="#overview" id="id3" name="id3">1&nbsp;&nbsp;&nbsp;Overview</a></li>
<li><a class="reference" href="#the-interface" id="id4" name="id4">2&nbsp;&nbsp;&nbsp;The Interface</a></li>
<li><a class="reference" href="#an-example" id="id5" name="id5">3&nbsp;&nbsp;&nbsp;An Example</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h3><a class="toc-backref" href="#id3" name="overview">1&nbsp;&nbsp;&nbsp;Overview</a></h3>
<p>By itself, ADL can handle several different types of input and output files.  It
can also handle a simple set of system calls using a memory-mapped interface
known as a porthole.  If a user wants to be able to process additional types of
input files, create a new type of output file, or extend the system-call
interface, he or she can create a <em>plugin</em> and have it installed at run-time.
This is simply a shared object which contains the additional functionality and
conforms to the ADL plugin interface.</p>
</div>
<div class="section" id="the-interface">
<h3><a class="toc-backref" href="#id4" name="the-interface">2&nbsp;&nbsp;&nbsp;The Interface</a></h3>
<p>An ADL plugin must implement an entry point function which returns a pointer to
a service-provider class.  The entry point is declared as:</p>
<pre class="literal-block">extern "C" Plugin *adl_plugin_entry()
</pre>
<p>The <tt class="docutils literal"><span class="pre">Plugin</span></tt> class is declared as:</p>
<pre class="literal-block">struct Plugin {

  virtual ~Plugin() {};

  // Generalized initialization routine.  This is called when the plugin is
  // loaded and allows the plugin to perform custom actions, such as
  // registering custom loggers, etc.  The method has access to the options
  // database and may install new command-line options at this point.
  virtual void init(AnyOption &amp;options) {};

  // Called after final option processing.  If the plugin should access the
  // command-line database at this point to read any needed option values.
  virtual void setup(AnyOption &amp;options) {};

  // If 'type' is recognized (this will be the extension of an output file), then construct
  // the relevant writer type.  If not recognized, return a 0.
  virtual Writer *createWriter(IssNode &amp;root,const std::string &amp;type,const std::string &amp;fn,const MemoryLog &amp;memlog) { return 0; };

  // Same as above, except this is for constructing a stream writer, which
  // writes data to an output stream.
  virtual Writer *createStreamWriter(IssNode &amp;root,const std::string &amp;type,std::ostream &amp;os,const MemoryLog &amp;memlog) { return 0; };

  // If 'type' is recognized (this will be the extension of an input file), then construct
  // the relevant reader type.  If not recognized, return a 0.
  virtual Reader *createReader(IssNode &amp;root,const std::string &amp;type,const std::string &amp;filename) { return 0; };

  // If this plugin has a system-call handler, then create such an object.  If not, return 0.
  virtual SysCallHandler *createSysCallHandler() { return 0; };

  // If this plugin defines an external memory handler, then create such an
  // object.  This method should call setMemHandler on the root argument (or
  // its children if it's a system).
  virtual void createMemHandler(IssNode &amp;root) {};
};
</pre>
<p>A user should publicly derive a class from <tt class="docutils literal"><span class="pre">Plugin</span></tt> and then implement the
appropriate functions.  The entry point function should then return a pointer to
an instance of this class.  Only a single instance is required, so the object
may be defined as a static global within the shared object.</p>
<p>When an input or output file is being processed by the ADL framework, a file's
type is derived from its name by looking at its file extension.  This will be
overridden if the user has specified a specific output format using the
<tt class="docutils literal"><span class="pre">--output-format</span></tt> or <tt class="docutils literal"><span class="pre">--of</span></tt> option.  The framework then calls the
appropriate creation function for all installed plugins.  If a plugin can
process a file, then it should instantiate an appropriate object (a <tt class="docutils literal"><span class="pre">Reader</span></tt>
or <tt class="docutils literal"><span class="pre">Writer</span></tt> derived object) and return a pointer to this object.  Note that
the base class for readers and writers is garbage collected, so a plugin does
not need to worry about deleting these objects.  The interface for a reader
object is declared in <tt class="docutils literal"><span class="pre">Reader.h</span></tt> and for a writer in <tt class="docutils literal"><span class="pre">Writer.h</span></tt>.</p>
<p>The framework also queries each plugin to see whether it implements any system
calls.  If so, then the plugin should instantiate and return a
<tt class="docutils literal"><span class="pre">SysCallHandler</span></tt> object when <tt class="docutils literal"><span class="pre">createSysCallHandler</span></tt> is called.  The
interface for system call handlers is declared in <tt class="docutils literal"><span class="pre">SysCallHandler.h</span></tt>.</p>
<p>If any setup operations need to be performed, these should be placed within the
<tt class="docutils literal"><span class="pre">init</span></tt> function, which is called immediately after the plugin library has been
loaded.  The function receives a reference to an <tt class="docutils literal"><span class="pre">AnyOption</span></tt> object, which is
the class that performs command-line option processing.  The <tt class="docutils literal"><span class="pre">init</span></tt> function
may add new options to the <tt class="docutils literal"><span class="pre">AnyOption</span></tt> class at this point.  After all
libraries have been loaded, the command-line is processed and then the <tt class="docutils literal"><span class="pre">setup</span></tt>
function is called for each plugin library.  At this point, the command-line
option database may be queried.</p>
<p>For example, within the <tt class="docutils literal"><span class="pre">init</span></tt> function, a flag may be added:</p>
<pre class="literal-block">void MyPlugin::init(AnyOption &amp;options) {
  ...
  options.setFlag("foo","An example option");
  ...
}
</pre>
<p>The <tt class="docutils literal"><span class="pre">setup</span></tt> function may then query its value:</p>
<pre class="literal-block">void MyPlugin::setup(AnyOption &amp;optoins) {
  ...
  if (options.getFlag("foo",false)) {
    ...
  }
  ...
}
</pre>
</div>
<div class="section" id="an-example">
<h3><a class="toc-backref" href="#id5" name="an-example">3&nbsp;&nbsp;&nbsp;An Example</a></h3>
<p>The following is a simple example of a plugin.  The writer handles files of type
<tt class="docutils literal"><span class="pre">icnt</span></tt>.  Such a file contains a histogram of all instructions processed during
a simulation.</p>
<p>The implementation file is:</p>
<pre class="literal-block">//
// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.
//
// You may distribute under the terms of the Artistic License, as specified in
// the COPYING file.
//

//
// This demonstrates a very simple, example plugin.  All it does it create a
// hash of what instructions were generated, then prints out this hash to a
// file.  The writer file extension type is 'icnt'.
//

#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;stdexcept&gt;

#include "helpers/Macros.h"
#include "helpers/BasicTypes.h"
#include "helpers/AnyOption.h"
#include "helpers/stringhash.h"

#include "iss/Writer.h"
#include "iss/Plugin.h"

using namespace std;
using namespace adl;

typedef map&lt;string,unsigned&gt; InstrHash;

// This maintains a histogram of instructions encountered and prints out the
// results at the end of a test to the specified file.
struct InstrCount : public Writer, public LoggingIface {

  // This just opens the file and makes sure that the operation succeeded.
  InstrCount(const std::string &amp;filename,IssNode &amp;root,const MemoryLog &amp;memlog) :
    Writer(filename,root,memlog),
    _fwidth(0),
    _out(filename.c_str())
  {
    if (!_out) {
      RError("Unable to open file " &lt;&lt; filename);
    }
  }

  virtual LoggingIface *register_core(IssCore &amp;core)
  {
    return this;
  }  

  // Required by the Writer class: Returns a string identifying the writer's
  // type.
  virtual const char *format_str() const { return "ICNT"; };

  // Add to the histogram and track instruction width so that we can nicely
  // format the output.
  virtual void logInstr(const uint32_t *opc,int num_bytes,const char* name, Disassembler,uint32_t)
  {
    _counts[name]++;
    _fwidth = max(_fwidth,strlen(name));
  }

  struct VComp {
    bool operator()(const InstrHash::value_type *x,const InstrHash::value_type *y)
    {
      return x-&gt;second &gt; y-&gt;second;
    };
  };

  // This dumps the histogram to the output file.
  virtual void writeResults()
  {
    vector&lt;const InstrHash::value_type *&gt; values;
    ForEach(_counts,iter) {
      values.push_back(&amp;(*iter));
    }
    sort(values.begin(),values.end(),VComp());

    _out &lt;&lt; "\n\nInstruction Frequency (Ordered By Frequency):\n"
         &lt;&lt; "=============================================\n\n";
    ForEach(values,iter) {
      _out &lt;&lt; setw(_fwidth) &lt;&lt; right &lt;&lt; (*iter)-&gt;first &lt;&lt; ":  " &lt;&lt; (*iter)-&gt;second &lt;&lt; '\n';
    }    

    _counts.clear();
    _fwidth = 0;
  }

  size_t    _fwidth;
  InstrHash _counts;
  ofstream  _out;

};

// This class is the service provider.  For a request for a writer of type
// 'icnt', it returns an instruction-count object.  It also displays a small
// banner at load-timee so that we know that the plugin was installed.
struct CountPlugin : public Plugin {

  // Respond to a request for a writer.
  virtual Writer *createWriter(IssNode &amp;root,const std::string &amp;type,const std::string &amp;fn,const MemoryLog &amp;memlog) 
  { 
    if (type == "icnt") {
      return new InstrCount(fn,root,memlog);
    }
    return 0;
  };

  // Called when the plugin is installed.
  virtual void init(AnyOption &amp;options) 
  {
    cout &lt;&lt; "Loaded the instruction-count plugin.\n";
    options.setFlag("foo","Example plugin flag.");
  };  

  // Called after final optiona processing.
  virtual void setup(AnyOption &amp;options,IssNode &amp;root)
  {
    if (options.getFlag("foo",false)) {
      cout &lt;&lt; "Option foo was set with core " &lt;&lt; root.name() &lt;&lt; "\n";
    }
  }

};

static CountPlugin count_plugin;

// Main entry point- returns a pointer to our service-provider object.
extern "C" Plugin *adl_plugin_entry()
{
  return &amp;count_plugin;
}
</pre>
<p>The file is compiled using the command:</p>
<pre class="literal-block">g++ `$adl/scripts/adl-config --cflags` CountInstrs.C -shared -o count-instrs.so
</pre>
<p>Given a model named <tt class="docutils literal"><span class="pre">model</span></tt>, the following command will read in a DAT file
called <tt class="docutils literal"><span class="pre">in4.dat</span></tt> which contains the simulator initial state, simulate this
model, then generate an output file named <tt class="docutils literal"><span class="pre">in4.out.dat</span></tt> containing a
simulation trace and final state and also create an instruction histogram file
named <tt class="docutils literal"><span class="pre">in4.icnt</span></tt>:</p>
<pre class="literal-block">./mod1 in4.dat -o=in4.out.dat -o=in4.icnt --plugin=./count-instrs.so  -trace
</pre>
<p>An example output file is:</p>
<pre class="literal-block">Instruction Frequency:
=======================

    bc:  427
  lwzx:  8
 addis:  5
 mullw:  8
  stwx:  200
  halt:  1
    or:  13
 mtspr:  2
   stw:  136
   add:  230
  cmpi:  229
rlwinm:  12
   lwz:  98
  addi:  347
</pre>
</div>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="adl-iss-plugins.rst">View document source</a>.
Generated on: 2018/02/28 15:14:25 MST.
Generated by prest release 0.3.40 from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
