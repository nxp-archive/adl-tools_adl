=====================
ADL Developer's Guide
=====================

This document describes how to create ADL models.

:Author:
  Michele Reese
:Contact:
  michele.reese@freescale.com

:Author:
  Brian Kahne
:Contact:
  bkahne@freescale.com

.. contents:: Table of Contents
   :backlinks: entry

.. sectnum::

The steps for developing an ADL model are:

* Check out and build adl:

  * CVSROOT=/proj/ppctools/CVS_ROOT cvs co adl (you need to be a member of the tools group.  If you're not, open a help ticket to request it.)

  * Please refer to the README file for required tools and their associated
    GAIN/CDE packages.

  * cvs co adl

  * cd adl

  * ./autogen.sh --disable-shared

  * make check 

* If you want to add code:

  * Under the doc directory is a file called booke_to_do.txt, add your name to
    the beginning of any lines that you are going to implement. Now commit the
    file.

  * Add your code to adl/designs/booke.adl. You should be using the latest
    design spec as your reference.

  * Type 'make' to compile it.

* Create a regression test (if you added code):

  * Write an rmf (you can copy /adl/tests/designs/in1.rmf from as a starting
    point).

  * Run raptor/powersim: 

      raptor -cl altair.so -rmf < rmfname > -o < uvpname > 

    Verify that your uvp exercises the behavior you expect.

  * Add your uvp to the adl/tests/designs/ directory.

  * Add your test to the ``@Tests`` list in the adl/tests/designs regress script. To
    do this you need to call the model_test function with the model you want to
    run and the testfile. model_test will build the run command and set the
    checker routine. If you specify an uvp as input, it will call the uvp2dat
    script to create the dat file and then intermediate results checking will be
    done on the uvp. Otherwise, if you specify a dat then only final results
    checking will be done. The regress utility routines are in
    scripts/regress_utils.pm. 

* Run the regression:

  make check in adl/tests/designs. The regression should pass.

* Update the ChangeLog:

  Use the "add-change-log-entry" command in xemacs for creating an entry in the
  adl/ChangeLog to communicate your changes to the other developers.

* Check in your changes:

  * Add any new files to cvs.

  * Do a cvs update and a make distcheck at the root adl level.  The full
    regression should pass.

  * Commit your changes.

* Run testbuild.  You don't always have to do this step, but it's a good idea to
  occasionally do it.  It checks out adl from scratch and builds it optimized
  and runs the full adl regression. This is good for catching files that you
  forgot to check in as well as optimization bugs (uninitialized variables,
  etc.).

  * Create a new directory.  You only have to do this once: future runs of
    testbuild will delete everything each time that it is run.

  * Copy over adl/scripts/test-build

  * chmod -w test-build

  * Run test-build

* If you want to run gdb on your source file on the model, there are two ways to
  do it: socket based and stdio.  The performance is better with stdio but if
  you want to see the stdio traffic generated by the model using the model's
  system call interface then you may need to use the socket based approach.

  * First compile source into an elf format w/ gdb flags:
    ppc-elf-gcc -ggdb <sources> -o <sourcefile.elf> -msim

  * Using stdio:

    The startsim macro launches the simulator in the background and uses stdio to
    communicate with it. 

    Assuming that I have a .gdbinit file that contains the line "so
    <path>/iss-macros.gdb", where path, obviously, points to the relevant
    location where the GDB macro file is. 

    * ./ppc-elf-gdb
      GNU gdb 6.3
      Copyright 2004 Free Software Foundation, Inc.
      GDB is free software, covered by the GNU General Public License, and you are
      welcome to change it and/or distribute copies of it under certain conditions.
      Type "show copying" to see the conditions.
      There is absolutely no warranty for GDB.  Type "show warranty" for details.
      This GDB was configured as "--host=i686-pc-linux-gnu --target=ppc-elf".
  
    * (gdb) startsim ./altair_r1_ut sieve.elf
      Opening output filename:  sieve.out.elf
      Warning:  ELF output file format not supported.  Using DAT instead.
      Opening input filename:  sieve.elf
      ElfReader: setting program counter for powerpc to the entry addr: 10000098
      Finished initialization.
      Using stdio for GDB communication.
      0x00000000 in ?? ()
      warning: no shared library support for this OS / ABI
    
    * (gdb) set archi powerpc:common64
      The target architecture is assumed to be powerpc:common64
    
    * (gdb) b main
      Breakpoint 1 at 0x10000210: file sieve.c, line 12.
    
    * (gdb) c
      Continuing.
      Breakpoint 1, main () at sieve.c:12
      12         for (i = 0; i != N; ++i) {
    
    * (gdb)


  * using the socket interface:

    * run sourcefile on the model w/ gdb enabled :

      * altair_r1_mt <sourcefile.elf> -g

    * in another shell, startup the powerpc gdb:

      * ./ppc-elf-gdb --args <sourcefile.elf>

      * target remote :<socket>
 
