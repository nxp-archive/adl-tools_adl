================================
ADL Requirements
================================

This document is intended as a general repository for ADL tool requirements.  It
is meant to be an informal document which will be frequently edited.

:Author:
  Brian Kahne
:Contact:
  bkahne@freescale.com

.. contents:: Table of Contents
   :backlinks: entry

.. sectnum::

Front-End
=========

* Define a subset of C++ (possibly with some language extensions) for specifying
  the semantics of various actions.  Right now, we accept any C++.  The problem
  is that the front-end only does a little bit of checking, meaning that a
  generated ISS can have compilation errors.  Ideally, the front-end should
  catch all errors so that an ISS, if generated, will always compile correctly.

  * The subset only needs to handle ``bits`` types (the arbitrary-sized integer
    class).

  * Template syntax should be removed:  Some functions will simply require
    literal arguments.  Already implemented for Mem, signExtend(), and zero().

  * Add support for constant attributes that may be used in the code.  For
    example, the size of a GPR should be usable as a constant to signExtend().

ISSs
====

Misc
----

Untimed ISS
-----------

Time-tagged ISS
---------------

The initial time-tagged ISS will be very similar to the untimed ISS in overall
structure and will probably be generated by the same program, using a flag to
specify that time-tagging should be added.

The initial version will support the following features:

* All registers (including registers in register files) will have a time value
  and all instructions will have an associated latency.  The target of an
  instruction will be the max of the time values of the instruction's operands
  plus the latency of that instruction.  For example, ``add r3,r2,r1`` with a
  time value of 2 for ``r2`` and 3 for ``r1`` and a latency of 1 for the
  instruction will set the time value of ``r3`` to 4.

  In other words, a time-tagged ISS acts like a discrete-event simulator for a
  very limited scope of problem: modeling a microprocessor.

* Instruction latency information will be specified using a file with the same
  format as ADL, i.e. define blocks and key/value pairs.  Latencies may be
  assigned to individual instructions, groups of instructions defined within the
  configuration file, or groups of instructions defined by instruction classes
  within the ADL file.

* Support for specifying the number of instructions that may be issued
  simultaneously.

* Support for limiting simultaneous issuing by instruction grouping.  For
  example, a configuration might specify that a processor may issue three
  instructions, but only one load/store.

  [Done] Initial version.

The second version of the time-tagged ISS generator will add:

* Support for register renaming.  The configuration file will allow the user to
  specify the number of rename registers available for a register file or
  register.  This rename register set will act as an extra level of indirection
  when accessing time values in order to reduce delays associated with WAW
  hazards.  For example::

    add r3,r2,r1
    mul r3,r4,r3
    sub r7,r6,r3

  Without renaming, the ``sub`` instruction would have to wait until the ``mul``
  instruction is complete.  With renaming, the ``mul`` and ``sub`` will execute
  in parallel.

* Support for speculative execution.  The user will be able to link the model
  with a branch predictor model.  If the predictor mis-predicts, then a
  miss-penalty will be assigned to the next instruction.  With a correct
  prediction, a hit-penalty will be assigned (which could be 0 in order to model
  a BTIC).

* Support for course-grained multithreading.  This will require the ability to
  specify that leaf-nodes in a defined system share a common set of resources.

I/O
---

[Done] ISS models will have an API for setting initial state, logging state
changes, and reporting final state.  In order to maximize performance, the
generator may omit or include this infrastructure based upon a command-line or
configuration parameter.

[Done] Multiple types of readers and writers will exist so that the ADL ISSs can easily
fit into existing methodologies.

Readers
+++++++

* [Done] UVP

* [Done] ELF 

* [Done] DAT (internal format used for regressions).

Writers
+++++++

* [Done] UVP.


* [Done] DAT (internal format used for regressions).

Additional I/O requirements
+++++++++++++++++++++++++++

Debugger support is required.  This will allow gdb to attach to a process
running on the ISS, allowing the user to step through their code, examine
registers, etc.

System-call support is also required.  This will allow users to write a program
which makes system calls, e.g. calling ``printf``, and then run this on an ISS.

Simulation Halting
++++++++++++++++++

The simulation currently requires that the ``halt`` instruction be executed in
order for the simulation to stop.  However, there is no ``halt`` instruction in
the PowerPC architecture.  Thus, we need a better solution.

A few possibilities are:

* We have a system call for halting the simulation, using the same mechanism as
  we will use for printing and file-IO, as described above.

* We have a method for specifying an ending address.

* We have a method for specifying an instruction count.

Assembler/Disassembler
======================

The basic assembler/disassembler generator has been finished.  It has the
following properties:

* Creates C files for assembling and disassembling, which can be compiled with a
  special version of binutils, which is distributed with ADL.

* A wrapper script will generate these files and then copy them to a binutils
  distribution location so that the user can simply type ``make`` in order to
  build the tools.

* Currently, ABI features, such as relocations, are handled through a series of
  hooks.  The current assembler uses the existing PowerPC assembler functions
  for handling this.

* Currently, the syntax string within ADL is used for a number of critical
  aspects when generating the assembler and disassembler, such as handling how
  addresses are treated (relative or absolute), how operands are organized,
  etc.

Future requirements are:

* Decide whether some of the information found within the syntax string might be
  moved to other aspects of ADL in order to reduce the chance for error.

* Decide how ABI features, such as relocations, should be modeled.  Should
  there be explicit support for this within ADL or can most of the information
  be extracted from what already exists?

Documentation Generation
========================

Basic documentation generation for a single core is finished.  Additional
requirements are:

* Support for multi-core/multi-threaded systems.

* Support for any additional language features, such as MMUs and caches.
