//
// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.
//
// You may distribute under the terms of the Artistic License, as specified in
// the COPYING file.
//

int access_spr(int i, unsigned int j) ;



define (arch = qe_risc_3_11)
{

       parallel_execution = 2;
// Functions

// dispatch bus access
bits<65> dispatch_bus_access()
{
	bits<1>  ack    = 0;
	bits<8>  snum   = zero(8);
	bits<24> iaddr  = zero(24);
	bits<8>  status = zero(8);
	bits<24> page   = zero(24);

	bits<65> disp = concat(ack, snum, iaddr, status, page);

	return disp;
}

	define (regfile=EXT_SPR)
{
		"""
		External Special purpose registers.
		""";
//		size = 0x800;
		size = 0x80;
        width = 32;
	}



//SPR access
bits<64> spr_bus_access(bits<1> RDWR, bits<15> ADDR, bits<8> BE, bits<64> WDATA, bits<32> RBA, bits<32> SST, bits<16> SNUMR)
{	

	bits<16> addr_even = concat(ADDR,  zero(1));
	bits<16> addr_odd  = concat(ADDR, ~zero(1));

	bits<32> rdata_even = EXT_SPR(addr_even);
	bits<32> rdata_odd  = EXT_SPR(addr_odd );
	
	bits<32> wdata_even;
	bits<32> wdata_odd ;
	
	bits<64> rdata = concat(rdata_even, rdata_odd);

	bits<64> mask  = 0;

	bits<8>  byte_mask;

	int i;

	if(RDWR == 0)
	{
		for(i = 0; i < 8; i++)
		{
			byte_mask = (BE(0) == 1) ? 0xff : 0;

			mask = concat(mask, byte_mask);
			
			BE = concat(BE, zero(1));
		}
		
//		wdata_even = merge(WDATA(0,31 ), rdata_even, mask(0,31 ));
//		wdata_odd  = merge(WDATA(32,63), rdata_odd , mask(32,63));
		wdata_even = ((WDATA(0,31 ) & mask(0,31 )) | (rdata_even & ~mask(0,31 )));
		wdata_odd  = ((WDATA(32,63) & mask(32,63)) | (rdata_odd  & ~mask(32,63)));

		EXT_SPR(addr_even) = wdata_even;
		EXT_SPR(addr_odd ) = wdata_odd ;
		
	}	

	return rdata;
}

//	define (regfile=DMEM)
//	{
//		"""
//		DATA MEMORY.
//		""";
//		size = 0x800;
//      width = 8;
//	}
	
    define(mem=DMEM)
    {
            size = 0x8000;
            addr_unit = 1;
    }

    define(mem=IMEM)
    {
            size = 0x8000;
            instr_mem = true;
            addr_unit = 4;
    }
 
	define (regfile=DSEM)
	{
		"""
		DATA MEMORY semaphore.
		""";
		size = 32;
        width = 1;

	}


// muram access
bits<65> muram_bus_access(bits<1> RDWR, bits<24> EA, bits<8> BE, bits<64> WDATA, bits<1> SM)
{
//	static bits<32> sem = 0;
//	static unsigned char DMEM[0xffff];
	bits<8> byte;
	
	bits<5> sem_ptr = EA(16,20);

	bits<24> addr = EA & 0x00fff8;

	bits<64> rdata = 0;
//	bits<1>  sm_rdata = sem(sem_ptr,sem_ptr);
	bits<1>  sm_rdata = DSEM(sem_ptr);
	
	bits<25> i = addr;
	bits<25> e = i + 8;
//	int size = 0;
	
//	while(BE != 0)
//	{
//		size = size + BE(0);
//		BE = concat(BE(1,7), zero(0));
//	}
	
	// load
	if(RDWR == 1)
	{
		rdata = DMEM(addr, 8);

		if(SM == 1) DSEM(sem_ptr) = 1;

	}
	else // store
	{
		while(BE != 0)
		{
			if(BE(0) == 1)
			{
				DMEM(addr, 1) = WDATA(0,7);
			}
			
			WDATA = concat(WDATA, zero(8));
			BE    = concat(BE,    zero(1));
			addr  = addr + 1;
			
		}

		if(SM == 1) DSEM(sem_ptr) = 0;
			
	}

	return concat(sm_rdata, rdata);
}




// merge mask generator
bits<32> mmask(bits<6> ML,bits<6> MR)
{
	bits<32> mask;

	bits<32> oxffffffff = 0xffffffff;
	bits<6>  sum = ML + MR;
			
//	mask = (sum    < 32) ? ((oxffffffff >> ML) & (oxffffffff << MR)) :
	mask = (sum(0) == 0) ? ((oxffffffff >> ML) & (oxffffffff << MR)) :
						   ((oxffffffff >> ML) | (oxffffffff << MR))	;

    return mask;
}


// merge function
bits<32> merge(bits<32> A, bits<32> B, bits<32> M)
{

    return ( (A & M) | (B & ~M) );
}

// expand imm16
bits<32> imm16e( bits<16> IMM16, bits<1> HWS)
{
	bits<32> imm = 0;

	if(HWS == 1) 
       imm = concat(zero(16), IMM16);
	else   
       imm = concat(IMM16, zero(16));

	return imm;   
}

// expand imm8
bits<32> imm8e( bits<16> IMM8, bits<2> BS)
{
	bits<32> imm = 0;
	
	if(BS == 0) 
       imm = concat(IMM8, zero(24));
	   
	else if(BS == 1)   
       imm = concat(zero(8), IMM8, zero(16));

	else if(BS == 2)   
       imm = concat(zero(16), IMM8, zero(8));

	else    
       imm = concat(zero(24), IMM8);

	return imm;   
}

// General status function
bits<32> CR_status(bits<32> RES_S, bits<32> RES)
{
// RES_S  - swapped result
// RES    - result


    bits<1> z    = (RES_S == 0) ? 1 : 0 ;
	
    bits<1> neg  = ((RES_S & 0x80000000) == 0) ? 0 : 1 ;
	
    bits<1> leq  = (neg | z) ;
	
    bits<1> awz  = (((RES_S & 0xffff0000) == 0) ||
	               ((RES_S & 0x0000ffff) == 0)   ) ? 1 : 0 ;
				   
    bits<1> lwz  = ((RES_S & 0x0000ffff) == 0) ? 1 : 0 ;
	
    bits<1> lwn  = ((RES_S & 0x00008000) == 0) ? 0 : 1 ;
	
    bits<1> lbz  = ((RES_S & 0x000000ff) == 0) ? 1 : 0 ;
	
    bits<1> abz  = (((RES_S & 0xff000000) == 0) ||
	                ((RES_S & 0x00ff0000) == 0) ||
	                ((RES_S & 0x0000ff00) == 0) ||
	                ((RES_S & 0x000000ff) == 0)    ) ? 1 : 0 ;
					
    bits<1> odd  = ((RES_S & 0x00000001) == 0) ? 0 : 1 ;

    bits<1> min  = (RES == 0x80000000) ? 1 : 0 ;
	
    bits<32> CR_new = 0;//concat(zero(1), z, neg, leq, awz, lwz, lbz, zero(4), abz, odd, zero(1), min, zero(16));

	CR_new.set(1,1,z);
	CR_new.set(2,2,neg);
	CR_new.set(3,3,leq);
	CR_new.set(4,4,awz);
	CR_new.set(5,5,lwz);
	CR_new.set(6,6,lwn);
	CR_new.set(7,7,lbz);
	CR_new.set(12,12,abz);
	CR_new.set(13,13,odd);
	CR_new.set(15,15,min);

 //   return merge(CR_new, CR, 0xffbf0000); // merge new with old CR[0:15] exclude sov 
    return ((CR_new & 0xffbf0000) | (CR & ~0xffbf0000)); // merge new with old CR[0:15] exclude sov 

} // ebd of CR_status


// ADD status function
bits<32> CR_add_status(bits<33> A, bits<33> B, bits<1> Cin)
{
// A      - opperand A
// B      - opperand B
// Cin    - carry in


    bits<33> R  = A + B + Cin ;
//    bits<32> C  = A(2,32) + B(2,32) + Cin ;
    bits<32> C  = concat(zero(1), A(2,32)) + concat(zero(1), B(2,32)) + Cin ;

    bits<1> ov  = R(0) ^ C(0);

    bits<1> sov = ov | CR(9);
	
    bits<32> CR_new = 0; 

	CR_new.set(0,0,R(0));
	CR_new.set(8,8,ov);
	CR_new.set(9,9,sov);

//    return merge(CR_new, CR, 0x80c00000); // insert of cary, ov, sov in to old CR 
    return ((CR_new & 0x80c00000) | (CR & ~0x80c00000)); // insert of cary, ov, sov in to old CR 

} // end of CR_add_status


// SUB status function
bits<32> CR_sub_status(bits<32> A, bits<32> B, bits<1> Cin)
{
// A      - opperand A
// B      - opperand B
// Cin    - carry in

	bits<33> AL = A;
	bits<33> AS = signExtend(A, 33);
	
	bits<33> BL = B;
	bits<33> BS = signExtend(B, 33);
	
    bits<33> R  = AL + BL + Cin ;
    bits<32> C  = concat(zero(1), A(1,31)) + concat(zero(1), B(1,31)) + Cin ;

    bits<1> ov  = R(0) ^ C(0);
	
    bits<1> sov = ov | CR(9);

	bits<33> RS = AS + BS + Cin ;
	bits<1>  sl = RS(0);

	bits<1> sle = sl | (R(1,32) == 0);
	
    bits<32> CR_new = CR; 

	CR_new.set(0,0,~R(0));
	CR_new.set(8,8,ov);
	CR_new.set(9,9,sov);
	CR_new.set(10,10,sle);
	CR_new.set(11,11,sl);


//	CR_new = concat(RS(0,7), AS(0,7), BS(0,7), zero(6), sl, Cin); 
    return CR_new;  
//    return merge(CR_new, CR, 0x80f00000); // insert of cary, ov, sov, sle, sl in to old CR 

} // end of CR_sub_status


// alu swap function
bits<32> swap(bits<32> D, bits<32> type)
{
     bits<32> sw = D;
	 
    if (type == 0) // bit swap
	{

		sw.set(0,0,D(7));
		sw.set(1,1,D(6));
		sw.set(2,2,D(5));
		sw.set(3,3,D(4));
		sw.set(4,4,D(3));
		sw.set(5,5,D(2));
		sw.set(6,6,D(1));
		sw.set(7,7,D(0));
		sw.set(8,8,D(15));
		sw.set(9,9,D(14));
		sw.set(10,10,D(13));
		sw.set(11,11,D(12));
		sw.set(12,12,D(11));
		sw.set(13,13,D(10));
		sw.set(14,14,D(9));
		sw.set(15,15,D(8));
		sw.set(16,16,D(23));
		sw.set(17,17,D(22));
		sw.set(18,18,D(21));
		sw.set(19,19,D(20));
		sw.set(20,20,D(19));
		sw.set(21,21,D(18));
		sw.set(22,22,D(17));
		sw.set(23,23,D(16));
		sw.set(24,24,D(31));
		sw.set(25,25,D(30));
		sw.set(26,26,D(29));
		sw.set(27,27,D(28));
		sw.set(28,28,D(27));
		sw.set(29,29,D(26));
		sw.set(30,30,D(25));
		sw.set(31,31,D(24));
	}

	else if(type == 1) // byte swap
	{
		sw = concat(D(8,15),D(0,7),D(24,31),D(16,23));
	}

	else if(type == 2) // word swap
	{
		sw = concat(D(16,31),D(0,15));
	}

	else if(type == 3) // byte sift right
	{
		sw = concat(zero(8),D(0,23));
	}

	else if(type == 4) // bit sift right
	{
		sw = concat(zero(1),D(0,30));
	}

	else if(type == 5) // exclude upper word
	{
		sw = concat(zero(16),D(16,31));
	}

	else if(type == 6) // little endian swap
	{
		sw = concat(D(24,31),D(16,23),D(8,15),D(0,7));
	}

    return sw;
}

// shift function
bits<33> shift(bits<32> D, bits<1> Cin, bits<5> size, bits<3> type, bits<1> dir)
{
// Inputs:
// D    - data for shift
// Cin  - carry in
// size - size of shift
// type - shift type
// dir  - direction; 1/0 - left/rigth

// Output 
// bits<1>  Cout - carry out
// bits<32> Dout - data 

	bits<1>  Cout  = 0;
	bits<1>  Carry = Cin; 
	bits<32> Dout  = D;
	
	bits<33> k=0;

	bits<6> i=0;

	for(i=0; i < size; i=i+1)
	{
		if(dir == 1) // shift left
		{
			Cout = Dout(0);
			
			if (type == 2) // rotate with carry
			{
			  Dout  = concat(Dout(1,31), Carry);
			  Carry = Cout;
			}
			
			else if (type == 3) // rotate
			{
			  Dout  = concat(Dout(1,31), Cout);
			}
			
			else if (type == 4) // shift algebrical with carry
			{
			  Dout  = concat(Dout(1,31), Carry);
			  Carry = 0;
			}
			
			else if (type == 5) // shift algebrical
			{
			  Dout  = concat(Dout(1,31), zero(1));
			}
			
			else if (type == 6) // shift logical with carry
			{
			  Dout  = concat(Dout(1,31), Carry);
			  Carry = 0;
			}
			
			else if (type == 7) // shift logical
			{
			  Dout  = concat(Dout(1,31), zero(1));
			}
		} // end of if(dir == 1) // shift left
		
		else // shift right
		{
			Cout = Dout(31);
			
			if (type == 2) // rotate with carry
			{
			  Dout  = concat(Carry, Dout(0,30));
			  Carry = Cout;
			}
			
			else if (type == 3) // rotate
			{
			  Dout  = concat(Cout, Dout(0,30));
			}
			
			else if (type == 4) // shift algebrical with carry
			{
			  Dout  = concat(Carry, Dout(0,30));
			}
			
			else if (type == 5) // shift algebrical
			{
			  Dout  = concat(Dout(0), Dout(0,30));
			}
			
			else if (type == 6) // shift logical with carry
			{
			  Dout  = concat(Carry, Dout(0,30));
			  Carry = 0;
			}
			
			else if (type == 7) // shift logical
			{
			  Dout  = concat(zero(1), Dout(0,30));
			}

		} // end of else // shift right

	} // end of for
	
	bits<33> res = concat(Cout, Dout);

    return res; 

} // end of shift function 

	define (reg=PR)
	{
		"""
		Temporal regester for debug prints .
		""";
		width = 65;
    }
	define (reg=dummy) {
		width = 65;
	alias = PR;
        }

	//
	// Registers.
	//

//	define (reg=CIA)
//	{
//		"""
//		Current instruction address for fetch.
//		""";
//	    classes = cia;
//	    attrs = cia;
//		reset = 0;
//		define(write)
//		{
//			action = func(bits<32> value)
//			{
//	      	    CIA.set(6,29,PC);
//			};
//		}
//    }

	define (reg=NIA) 
	{
		"""
		Next instruction address for fetch.
	    """;
//		classes = nia;
		attrs = nia;
//		reset = 4;
		reset = 0;
		define(write)
		{
			action = func(bits<32> value)
			{
//	      	    NIA.set(6,29,NPC);
//	      	    NIA.set(0,31,NPC);
	      	    NIA.set(0,31,PC);
			};
		}
	  serial = true;
	}
	
	define (reg=PC)
	{
		"""
		Current instruction address.
		""";

		width = 24;
		reset = 0;
	    attrs = cia;
	 serial = true;
    }

	define (reg=NPC) 
	{
		"""
		Next instruction address.
	    """;
		width = 24;
		reset = 1;
		serial = true;
	}
	
	define (reg=NNPC) 
	{
		"""
		NPC+.
	    """;
		width = 24;
		reset = 2;
		serial = true;
	}
	
        define (reg=R1)    {}
        define (reg=R2)    {}
        define (reg=R3)    {}
        define (reg=R4)    {}
        define (reg=R5)    {}
        define (reg=R6)    {}
        define (reg=R7)    {}
        define (reg=R8)    {}
        define (reg=R9)    {}
        define (reg=R10)   {}
        define (reg=R11)   {}
        define (reg=R12)   {}
        define (reg=R13)   {}
        define (reg=R14)   {}
        define (reg=R15)   {}
        define (reg=R16)   {}
        define (reg=R17)   {}
        define (reg=R18)   {}
        define (reg=R19)   {}
        define (reg=R20)   {}
        define (reg=R21)   {}
        define (reg=R22)   {}
        define (reg=R23)   {}
        define (reg=R24)   {}
        define (reg=R25)   {}
        define (reg=R26)   {}
        define (reg=RPAGE) {}
        define (reg=RBA)   {}
        define (reg=SER)   {}
        define (reg=SST)   {}
        define (reg=SP)    {}
        define (reg=R0)
        {
            reset   = 0;
			
			define (read)  
			{
				action = { return 0; };
			}
			
			define (write)  
			{
				ignore = true;
			}
        }

	define (regfile=GPR0)
	{
		"""
		General purpose registers.
		""";
		size = 32;
	
		define (entry=0 ) { reg = R1    ;}  
		define (entry=1 ) { reg = R2    ;}  
		define (entry=2 ) { reg = R3    ;}  
		define (entry=3 ) { reg = R4    ;}  
		define (entry=4 ) { reg = R5    ;}  
		define (entry=5 ) { reg = R6    ;}  
		define (entry=6 ) { reg = R7    ;}  
		define (entry=7 ) { reg = R8    ;}  
		define (entry=8 ) { reg = R9    ;}  
		define (entry=9 ) { reg = R10   ;}  
		define (entry=10) { reg = R11   ;}  
		define (entry=11) { reg = R12   ;}  
		define (entry=12) { reg = R13   ;}  
		define (entry=13) { reg = R14   ;}  
		define (entry=14) { reg = R15   ;}  
		define (entry=15) { reg = R16   ;}  
		define (entry=16) { reg = R17   ;}  
		define (entry=17) { reg = R18   ;}  
		define (entry=18) { reg = R19   ;}  
		define (entry=19) { reg = R20   ;}  
		define (entry=20) { reg = R21   ;}  
		define (entry=21) { reg = R22   ;}  
		define (entry=22) { reg = R23   ;}  
		define (entry=23) { reg = R24   ;}  
		define (entry=24) { reg = R25   ;}  
		define (entry=25) { reg = R26   ;}  
		define (entry=26) { reg = RPAGE ;}  
		define (entry=27) { reg = RBA   ;}  
		define (entry=28) { reg = SER   ;}  
		define (entry=29) { reg = SST   ;}  
		define (entry=30) { reg = SP    ;}  
		define (entry=31) { reg = R0    ;}
	}

	define(regfile=GPR) 
        {
	  alias=GPR0;
        }

	define (reg=CR) 
	{
		"""
		Conditional Regester .
	    """;

//		regfile = (SPR, 1);
		reset   = 0x8001;

		define (field=carry)
		{
			bits = 0;
		}
		
		define (field=zero)
		{
			bits = 1;
		}
		
		define (field=neg)
		{
			bits = 2;
		}
		
		define (field=leq)
		{
			bits = 3;
		}
		
		define (field=awz)
		{
			bits = 4;
		}
		
		define (field=lwz)
		{
			bits = 5;
		}
		
		define (field=lwn)
		{
			bits = 6;
		}
		
		define (field=lbz)
		{
			bits = 7;
		}
		
		define (field=ov)
		{
			bits = 8;
		}
		
		define (field=sov)
		{
			bits = 9;
		}
		
		define (field=sle)
		{
			bits = 10;
		}
		
		define (field=sl)
		{
			bits = 11;
		}
		
		define (field=abz)
		{
			bits = 12;
		}
		
		define (field=odd)
		{
			bits = 13;
		}
		
		define (field=mod)
		{
			bits = 14;
		}
		
		define (field=min)
		{
			bits = 15;
		}
		
		define (field=rcnf0)
		{
			bits = 16;
		}
		
		define (field=rcnf1)
		{
			bits = 17;
		}
		
		define (field=rcnf2)
		{
			bits = 18;
		}
		
		define (field=rcnf3)
		{
			bits = 19;
		}
		
		define (field=rcnf4)
		{
			bits = 20;
		}
		
		define (field=rcnf5)
		{
			bits = 21;
		}
		
		define (field=leac)
		{
			bits = 22;
		}
		
		define (field=rcnf7)
		{
			bits = 23;
		}
		
		define (field=cr24)
		{
			bits = 24;
		}
		
		define (field=cr25)
		{
			bits = 25;
		}
		
		define (field=cr26)
		{
			bits = 26;
		}
		
		define (field=cr27)
		{
			bits = 27;
		}
		
		define (field=emrd)
		{
			bits = 28;
		}
		
		define (field=emr)
		{
			bits = 29;
		}
		
		define (field=sm)
		{
			bits = 30;
		}
		
		define (field=alw)
		{
			bits = 31;
			readonly=true;
		}
	}
	
	define (reg=SNUMR) 
	{
		"""
		Serial Number Register .
	    """;

		reset   = 0x80000000;

		define (field=org_bg)
		{
			bits = 0;
		}
		
		define (field=org_snum)
		{
			bits = (8,15);
		}
		
		define (field=bg)
		{
			bits = 16;
		}
		
		define (field=snum)
		{
			bits = (24,31);
		}
	}
	
	define (reg=ILR) 
	{
		"""
		Interrupt Link Register .
	    """;

		reset   = 0;

		define (field=en)
		{
			bits = 0;
		}
		
		define (field=addr)
		{
			bits = (8,31);
		}
	}
	
	define (reg=ITR) 
	{
		"""
		Interrupt Temporal Register .
	    """;

		reset   = 0;

	}
	
	define (reg=BTR) 
	{
		"""
		Breakpoint Temporal Register .
	    """;

		reset   = 0;

	}
	
	define (reg=DVR) 
	{
		"""
		Debug Virtual Register .
	    """;
 		define (read)  
		{ 
			action = { return 0; }; 
		}
		
		define (write) 
		{
			ignore = true; 
		} 
	}
	
	define (reg=BGTLR) 
	{
		"""
		BackGround Task Link Register .
	    """;

		reset   = 0;

		define (field=en)
		{
			bits = 0;
		}
		
		define (field=addr)
		{
			bits = (8,31);
		}
	}
	
	define (reg=RESERVED0) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVED2) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVED4) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVED6) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVED8) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVEDa) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVEDc) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVEDe) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	
	define (regfile=SPR)
	{
		"""
		Special purpose registers.
		""";
		size = 0x80;
		
		define (entry=0x1) {reg=CR;}
		define (entry=0x3) {reg=SNUMR;}
		define (entry=0x5) {reg=ILR;}
		define (entry=0x7) {reg=ITR;}
		define (entry=0x9) {reg=BTR;}
		define (entry=0xb) {reg=DVR;}
		define (entry=0xd) {reg=BGTLR;}
		
		define (entry=0x0) {reg=RESERVED0;}
		define (entry=0x2) {reg=RESERVED2;}
		define (entry=0x4) {reg=RESERVED4;}
		define (entry=0x6) {reg=RESERVED6;}
		define (entry=0x8) {reg=RESERVED8;}
		define (entry=0xa) {reg=RESERVEDa;}
		define (entry=0xc) {reg=RESERVEDc;}
		define (entry=0xe) {reg=RESERVEDe;}
	}

	//
	// Instruction fields.
	//

	define (instrfield=OPCD) 
	{
		"""
		Primary opcode.
		""";
		bits = (0,4);
	}

	define (instrfield=OPCD_SHRT) 
	{
		"""
		Primary short opcode.
		""";
		bits = (0,3);
	}

	define (instrfield=SW) 
	{
		"""
		Swap option for LD instruction
		""";
		bits = 4;
	}

	define (instrfield=SM) 
	{
		"""
		Semaphor option for DMA instructions
		""";
		bits = 4;
	}

	define (instrfield=OPCD_BTM) 
	{
		"""
		Secondary opcode for BTM instructions
		""";
		bits = (5,7);
	}

	define (instrfield=CRC) 
	{
		"""
		CRC type for BCRC/BCOPY instructions
		""";
		bits = (8,9);
	}

	define (instrfield=DSIZE) 
	{
		"""
		DSIZE field for BCAM/BMIN/BMAX instructions
		""";
		bits = (8,9);
	}

	define (instrfield=RV) 
	{
		"""
		RV option for BCRC/BCOPY instructions
		""";
		bits = 10;
	}

	define (instrfield=RVS) 
	{
		"""
		RVS option for BCRCI/BCOPYI instructions
		""";
		bits = (10,11);
	}

	define (instrfield=M) 
	{
		"""
		M option for BCAM instructions
		""";
		bits = 10;
	}

	define (instrfield=DMA_SIZE) 
	{
		"""
		Size option for DMA instructions
		""";
		bits = (5,8);
	}

	define (instrfield=DATA) 
	{
		"""
		Size option for DMA instructions
		""";
		bits = 9;
	}

	define (instrfield=OPCD_B10) 
	{
		"""
		DMAR/DMAW selector for DMA instructions
		""";
		bits = 10;
	}

	define (instrfield=OPCD_B11) 
	{
		"""
		Reserved field for BCAMI/BMINI/BMAXI instructions
		""";
		bits = 11;
	}

	define (instrfield=OPCD_B12) 
	{
		"""
		Reserved field for BCAMI/BMINI/BMAXI instructions
		""";
		bits = 12;
	}

	define (instrfield=DES) 
	{
		"""
		DES option for BCOPYI instruction
		""";
		bits = 12;
	}

	define (instrfield=BUFFER_SIZE) 
	{
		"""
		BUFFER_SIZE field for BTM Imm instructions
		""";
		bits = (13,15);
	}

	define (instrfield=SML) 
	{
		"""
		Semaphor option for LD instruction
		""";
		bits = 8;
	}

	define (instrfield=HWS) 
	{
		"""
		High Word Select for ALU immideate instructions
		""";
		bits = 4;
	}

	define (instrfield=NOT_J) 
	{
		"""
		Condition NOT for JMP instructions
		""";
		bits = 4;
	}

	define (instrfield=OPCD_B5) 
	{
		"""
		Secondary opcode.
		""";
		bits = 5;
	}

	define (instrfield=HU) 
	{
		"""
		Flag to update half of target register for push instruction.
		""";
		bits = 5;
	}

	define (instrfield=RS) 
	{
		"""
		RS field for mfspr instruction.
		""";
		bits = 5;
	}

	define (instrfield=AU) 
	{
		"""
		Address Update option for pushsch/ldsch instructions.
		""";
		bits = 5;
	}

	define (instrfield=SBS) 
	{
		"""
		BS field for mtspri instruction.
		""";
		bits = (6,7);
	}

	define (instrfield=OPCD_B6) 
	{
		"""
		Secondary opcode for push/pushl instructions.
		""";
		bits = 6;
	}

	define (instrfield=OPCD_B7) 
	{
		"""
		Secondary opcode.
		""";
		bits = 7;
	}

	define (instrfield=CMPRS) 
	{
		"""
		CMPRS option for push/pushl instructions.
		""";
		bits = 7;
	}

    define (instrfield=B8) 
	{
		"""
		mfspr.b8 instructions.
		""";
		bits = 7;
	}

	define (instrfield=CMPRS_J) 
	{
		"""
		CMPRS option for jmp instructions.
		""";
		bits = 23;
	}


    define (instrfield=OPCD_B8) 
	{
		"""
		LD/ST selector for LDM/STM instructions.
		""";
		bits = 8;
	}

    define (instrfield=IMM8S) 
	{
		"""
		IMM8 for mtspri instructions.
		""";
		bits = (8,15);
	}

    define (instrfield=CASE_SIZE) 
	{
		"""
		size of case instruction.
		""";
		bits = (8,10);
	}

	define (instrfield=NOP_J) 
	{
		"""
		NOP option in JMP instruction.
		""";
		bits = 5;
	}

	define (instrfield=INVA) 
	{
		"""
		INV operand B in ALU instruction.
		""";
		bits = 5;
	}

	define (instrfield=SIZEB) 
	{
		"""
		SIZEB field for mtspr instruction.
		""";
		bits = (5,7);
	}

	define (instrfield=SIZEA) 
	{
		"""
		SIZEA field for mtspr instruction.
		""";
		bits = (8,10);
	}

	define (instrfield=OPCD_ALU) 
	{
		"""
		Secondary opcode for ALU instructions.
		""";
		bits = (6,8);
	}

	define (instrfield=SIZE_LDST) 
	{
		"""
		size field for ld/st instructions.
		""";
		bits = (5,7);
	}

    define (instrfield=RT1) 
	{
		"""
		Reserved tag for pushsch/ldsch instructions.
		""";
		bits = 7;
	}

    define (instrfield=RT2) 
	{
		"""
		Reserved tag for pushsch/ldsch instructions.
		""";
		bits = 8;
	}

    define (instrfield=UPDATE) 
	{
		"""
		Update option of ALU instruction.
		""";
		bits = 9;
	}

    define (instrfield=RT3) 
	{
		"""
		Reserved tag for pushsch/ldsch instructions.
		""";
		bits = 9;
	}

	define (instrfield=FLAGS) 
	{
		"""
		CR update for ALU instruction.
		""";
		bits = 10;
	}

	define (instrfield=UR) 
	{
		"""
		Micro code requesr option for pushsch/ldsch instructions.
		""";
		bits = 10;
	}

	define (instrfield=IMM16) 
	{
		"""
		immideate 16.
		""";
		bits = (16,31);
	}

	define (instrfield=IMM8) 
	{
		"""
		immideate 8.
		""";
		bits = (24,31);
	}

    define (instrfield=RSV_B21) 
	{
		"""
		Reserved bit.
		""";
		bits = 21;
	}

    define (instrfield=OPCD_B21) 
	{
		"""
		CALL/POP/RETURN bit.
		""";
		bits = 21;
	}

    define (instrfield=OPCD_B22) 
	{
		"""
		CALL/POP/RETURN bit.
		""";
		bits = 22;
	}

    define (instrfield=BS) 
	{
		"""
		Bite select bit for ALUIS instructions.
		""";
		bits = (22,23);
	}

    define (instrfield=SWAP_TYPE) 
	{
		"""
		ALU swap type.
		""";
		bits = (26,28);
	}

    define (instrfield=DS_ALU) 
	{
		"""
		data size for cnt and ffs instructions.
		""";
		bits = (26,29);
	}

    define (instrfield=DIRECTION) 
	{
		"""
		Shift instructions direction.
		""";
		bits = 26;
	}

    define (instrfield=SHIFT_OPTION) 
	{
		"""
		shift type for shift* instructions.
		""";
		bits = (27,29);
	}

    define (instrfield=RSV_B29) 
	{
		"""
		Reserved bit.
		""";
		bits = 29;
	}

    define (instrfield=RSV_B30) 
	{
		"""
		Reserved bit.
		""";
		bits = 30;
	}

    define (instrfield=RSV_B31) 
	{
		"""
		Reserved bit.
		""";
		bits = 31;
	}

    define (instrfield=OPCD_B31) 
	{
		"""
		Secondary opcode.
		""";
		bits = 31;
	}

    define (instrfield=ONE) 
	{
		"""
		ONE option for add/sub instructions.
		""";
		bits = 31;
	}


	define (instrfield=ML)
	{
		"""
		Mask Left.
		""";
		bits = (6,10);
	}
	
	define (instrfield=BIT)
	{
		"""
		Conditional BIT select for JMP instruction.
		""";
		bits = (6,10);
	}
	
	define (instrfield=MR)
	{
		"""
		Mask Rigth.
		""";
		bits = (26,30);
	}
	
	define (instrfield=RA)
	{
		"""
		RA.
		""";
		bits = (11,15);
		ref = GPR;
	}
	
	define (instrfield=RA_2)
	{
		"""
		RA_2.
		""";
		table = ((0,1), reserved,(2,3),reserved,(4,5),reserved,(6,7),reserved,
			 (8,9), reserved,(10,11),reserved,(12,13),reserved,(14,15),reserved,	
			 (16,17), reserved,(18,19),reserved,(20,21),reserved,(22,23),reserved,
			 (24,25), reserved,(26,27),reserved,(28,29),reserved,(30,31),reserved);

		bits = (11,15);
		ref = GPR;
	}

	define (instrfield=RA_4)
	{
		"""
		RA_4.
		""";
		table = ((0,1,2,3),reserved,reserved,reserved,(4,5,6,7),reserved,reserved,reserved,
			 (8,9,10,11),reserved,reserved,reserved,(12,13,14,15),reserved,reserved,reserved,
			 (16,17,18,19),reserved,reserved,reserved,(20,21,22,23),reserved,reserved,reserved,	
			 (24,25,26,27),reserved,reserved,reserved,(28,29,30,31),reserved,reserved,reserved);	
		bits = (11,15);
		ref = GPR;
	}
	

	define (instrfield=RB)
	{
		"""
		RB.
		""";
		bits = (16,20);
		ref  = GPR;
	}
	
	define (instrfield=RC)
	{
		"""
		RC.
		""";
		bits = (21,25);
		ref = GPR;
	}
	
	define (instrfield=DATA5)
	{
		"""
		DATA5 field for mergei instruction.
		""";
		bits = (11,15);
	}
	
	define (instrfield=IMM5M)
	{
		"""
		IMM5 field for rlmerge and mergei instructions.
		""";
		bits = (21,25);
	}
	
	define (instrfield=IMM5)
	{
		"""
		shift size for shifti instruction.
		""";
		bits = (16,20);
	}
	
	define (instrfield=CFA)
	{
		"""
		pointer to CR bit for alu conditional instructions.
		""";
		bits = (26,30);
	}
	
	define (instrfield=NOTAC)
	{
		"""
		NOT of CR flag for alu conditional instructions.
		""";
		bits = 31;
	}
	
	define (instrfield=INSTR_OFFSET)
	{
		"""
		instruction offset for imm. jmp instructions
		""";
		bits = (16,31);
	}
	
	define (instrfield=LONG_OFFSET)
	{
		"""
		instruction offset for pushl instruction
		""";
		bits = (8,31);
	}
	
	define (instrfield=DRAM_OFFSET)
	{
		"""
		MURAM offset for ld/st/spr instructions
		""";
		bits = (21,31);
	}
	
	define (instrfield=SPRF)
	{
		"""
		SPR address field for mtspr/mfspr instructions
		""";
		bits = (21,31);
	}

	define (instrfield=SPRF_I)
	{
		"""
		SPR address field for mtspr/mfspr instructions
		""";
		bits = (29,31);
	        table = ((1),(3),(5),(7));
	}
	
	define (parm=Fetch) 
	{
    	options = (Normal,JmpN);
    	value = Normal;
	}

//	post_fetch = func(unsigned size) 
//	{
//
//		NPC = NPC + 1; 
//	};

	post_exec =
	{
//PR=PC;		
//PR=NPC;		
//PR=NNPC;		
		bits<24> s = 1;

		PC.set(0,23,(Fetch == JmpN) ? NNPC : NPC);

		NIA.set(0,31,PC);
		
		NPC.set(0,23,(Fetch == JmpN) ? NNPC + s : NNPC);

		NNPC.set(0,23,NPC + 1);
		
//PR=PC;		
//PR=NPC;		
//PR=NNPC;		
    	Fetch = Normal;
		
	};



    define(instr=andi)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA, OPCD_ALU(2), UPDATE, FLAGS, RA, IMM16);
//		syntax = ("%f, %f", RA, IMM); 
		action =
		{

			bits<32> op1  = (RA == 0x1f) ? CR : GPR(RA);

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> op2 = (INVA == 1) ? ~imm : imm;   
			
			bits<32> tmp  = op1 & op2;

			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=ori)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA, OPCD_ALU(3), UPDATE, FLAGS, RA, IMM16);
//		syntax = ("%f, %f", RA, IMM); 
		action =
		{

			bits<32> op1 = (RA == 0x1f) ? CR : GPR(RA);
			
			bits<32> imm = imm16e(IMM16, HWS);
			
			bits<32> op2 = (INVA == 1) ? ~imm : imm;   

			bits<32> tmp = op1 | op2;
			
			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=xori)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA, OPCD_ALU(4), UPDATE, FLAGS, RA, IMM16);
//		syntax = ("%f, %f", RA, IMM); 
		action =
		{

			bits<32> op1  = (RA == 0x1f) ? CR : GPR(RA);

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> op2 = (INVA == 1) ? ~imm : imm;   
			
			bits<32> tmp  = op1 ^ op2;

			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=movei)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA, OPCD_ALU(7), UPDATE, FLAGS, RA, IMM16);
//		syntax = ("%f, %f", RA, IMM); 
		action =
		{

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> tmp = (INVA == 1) ? ~imm : imm;   
			
			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=addi)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA(0), OPCD_ALU(0), UPDATE, FLAGS, RA, IMM16);
//		syntax = ("%f, %f", RA, IMM); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> op2 = imm;   
			
			bits<32> tmp  = op1 + op2;

			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			  CR = CR_add_status(op1, op2, 0);
			}
		};
	}

    define(instr=subi)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA(1), OPCD_ALU(0), UPDATE, FLAGS, RA, IMM16);
//		syntax = ("%f, %f", RA, IMM); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> op2 = ~imm;   
			
			bits<32> tmp  = op1 + op2 + 1;

			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			  CR = CR_sub_status(op1, op2, 1);
			}
		};
	}

    define(instr=addci)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA(0), OPCD_ALU(1), UPDATE, FLAGS, RA, IMM16);
//		syntax = ("%f, %f", RA, IMM); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> op2 = imm;   
			
			bits<32> tmp  = op1 + op2 + CR.carry;

			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = CR.carry;
			  CR = CR_status(tmp, tmp);
			  CR = CR_add_status(op1, op2, Cin);
			}
		};
	}

    define(instr=subci)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA(1), OPCD_ALU(1), UPDATE, FLAGS, RA, IMM16);
//		syntax = ("%f, %f", RA, IMM); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> op2 = ~imm;   
			
			bits<32> tmp  = op1 + op2 + ~CR.carry;

			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = ~CR.carry;
			  CR = CR_status(tmp, tmp);
			  CR = CR_sub_status(op1, op2, Cin);
			}
		};
	}

    define(instr=andis)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA, OPCD_ALU(2), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
//		syntax = ("%f, %f, %f", RB, RA, IMM); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = (INVA == 1) ? ~imm : imm;   
			
			bits<32> tmp  = op1 & op2;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=oris)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA, OPCD_ALU(3), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
//		syntax = ("%f, %f, %f", RB, RA, IMM); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = (INVA == 1) ? ~imm : imm;   
			
			bits<32> tmp  = op1 | op2;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=xoris)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA, OPCD_ALU(4), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
//		syntax = ("%f, %f, %f", RB, RA, IMM); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = (INVA == 1) ? ~imm : imm;   

			bits<32> tmp  = op1 ^ op2;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=addis)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA(0), OPCD_ALU(0), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
//		syntax = ("%f, %f, %f", RB, RA, IMM); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = imm;   

			bits<32> tmp  = op1 + op2;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			  CR = CR_add_status(op1, op2, 0);
			}
		};
	}

    define(instr=subis)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA(1), OPCD_ALU(0), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
//		syntax = ("%f, %f, %f", RB, RA, IMM); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = ~imm;   

			bits<32> tmp  = op1 + op2 + 1;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			  CR = CR_sub_status(op1, op2, 1);
			}
		};
	}

    define(instr=addcis)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA(0), OPCD_ALU(1), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
//		syntax = ("%f, %f, %f", RB, RA, IMM); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = imm;   

			bits<32> tmp  = op1 + op2 + CR.carry;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = CR.carry;
			  CR = CR_status(tmp, tmp);
			  CR = CR_add_status(op1, op2, Cin);
			}
		};
	}

    define(instr=subcis)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA(1), OPCD_ALU(1), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
//		syntax = ("%f, %f, %f", RB, RA, IMM); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = ~imm;   

			bits<32> tmp  = op1 + op2 + ~CR.carry;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = ~CR.carry;
			  CR = CR_status(tmp, tmp);
			  CR = CR_sub_status(op1, op2, Cin);
			}
		};
	}

    define(instr=add)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA(0), OPCD_ALU(0), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), ONE);
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2 = GPR(RB);   

			bits<32> tmp  = op1 + op2 + ONE;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 
			
			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp_s, tmp);
			  CR = CR_add_status(op1, op2, ONE);
			}
		};
	}

    define(instr=sub)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA(1), OPCD_ALU(0), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), ONE);
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2 = ~GPR(RB);   

			bits<32> tmp  = op1 + op2 + ~ONE;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp_s, tmp);
			  CR = CR_sub_status(op1, op2, ~ONE);
			}
		};
	}

    define(instr=addc)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA(0), OPCD_ALU(1), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), RSV_B31(0));
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2 = GPR(RB);   

			bits<32> tmp  = op1 + op2 + CR.carry;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = CR.carry;
			  CR = CR_status(tmp_s, tmp);
			  CR = CR_add_status(op1, op2, Cin);
			}
		};
	}

    define(instr=subc)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA(1), OPCD_ALU(1), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), RSV_B31(0));
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2 = ~GPR(RB);   

			bits<32> tmp  = op1 + op2 + ~CR.carry;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			bits<32> Cin;
			if(FLAGS == 1)
			{
		      bits<32> Cin = ~CR.carry;
			  
			  CR = CR_status(tmp_s, tmp);
			  CR = CR_sub_status(op1, op2, Cin);
			}
		};
	}

    define(instr=and)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA, OPCD_ALU(2), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), RSV_B31(0));
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? CR : GPR(RA);

			bits<32> op2 = (INVA == 1) ? ~GPR(RB) : GPR(RB);   

			bits<32> tmp  = op1 & op2;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp_s, tmp);
			}
		};
	}

    define(instr=or)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA, OPCD_ALU(3), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), RSV_B31(0));
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? CR : GPR(RA);

			bits<32> op2 = (INVA == 1) ? ~GPR(RB) : GPR(RB);   

			bits<32> tmp  = op1 | op2;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp_s, tmp);
			}
		};
	}

    define(instr=xor)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA, OPCD_ALU(4), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), RSV_B31(0));
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? CR : GPR(RA);

			bits<32> op2 = (INVA == 1) ? ~GPR(RB) : GPR(RB);   

			bits<32> tmp  = op1 ^ op2;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp_s, tmp);
			}
		};
	}


    define(instr=cadd)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA(0), OPCD_ALU(0), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2  = GPR(RB);  

			bits<1> cond  = NOTAC ^ CR(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 + op2 : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			  
			  if(cond == 1)
			     CR = CR_add_status(op1, op2, 0);
			}
		};
	}
	
    define(instr=csub)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA(1), OPCD_ALU(0), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2  = ~GPR(RB);  

			bits<1> cond  = NOTAC ^ CR(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 + op2 + 1 : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			  
			  if(cond == 1)
			     CR = CR_sub_status(op1, op2, 1);
			}
		};
	}
	
    define(instr=caddc)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA(0), OPCD_ALU(1), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2  = GPR(RB);  

			bits<1> cond  = NOTAC ^ CR(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? (op1 + op2 + CR.carry) : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = CR.carry;
			  CR = CR_status(tmp, tmp);
			  
			  if(cond == 1)
			     CR = CR_add_status(op1, op2, Cin);
			}
		};
	}
	
    define(instr=csubc)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA(1), OPCD_ALU(1), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2  = ~GPR(RB);  

			bits<1> cond  = NOTAC ^ CR(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 + op2 + ~CR.carry : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = ~CR.carry;
			  CR = CR_status(tmp, tmp);
			  
			  if(cond == 1)
			     CR = CR_sub_status(op1, op2, Cin);
			}
		};
	}
	
    define(instr=cand)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA, OPCD_ALU(2), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? CR : GPR(RA);

			bits<32> op2  = (INVA == 1) ? ~GPR(RB) : GPR(RB);  

			bits<1> cond  = NOTAC ^ CR(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 & op2 : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			}
		};
	}
	
    define(instr=cor)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA, OPCD_ALU(3), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? CR : GPR(RA);

			bits<32> op2  = (INVA == 1) ? ~GPR(RB) : GPR(RB);  

			bits<1> cond  = NOTAC ^ CR(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 | op2 : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			}
		};
	}
	
    define(instr=cxor)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA, OPCD_ALU(4), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? CR : GPR(RA);

			bits<32> op2  = (INVA == 1) ? ~GPR(RB) : GPR(RB);  

			bits<1> cond  = NOTAC ^ CR(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 ^ op2 : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			}
		};
	}
	
    define(instr=cbset)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA(0), OPCD_ALU(5), UPDATE, FLAGS, RA, IMM5, RC, CFA, NOTAC);
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? CR : GPR(RA);

			bits<32> op2  = 1;  
                     op2 = op2 << IMM5;

			bits<1> cond  = NOTAC ^ CR(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 | op2 : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			}
		};
	}
	
    define(instr=cbclr)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA(0), OPCD_ALU(6), UPDATE, FLAGS, RA, IMM5, RC, CFA, NOTAC);
//		syntax = ("%f, %f, %F", RC, RA, RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? CR : GPR(RA);

			bits<32> mask = 1;
					 mask = mask << IMM5;

			bits<1> cond  = NOTAC ^ CR(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 & ~mask : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  CR = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  CR = CR_status(tmp, tmp);
			}
		};
	}
	

// Special instruction:  This is used for simulation purposes and is
    // not a PPC instruction.
    define (instr=halt)
    {
	  width=32;
      fields=(OPCD(0x09));
      action = 
	  {
		 halt();
      };
    }

}



//define (core = qe_risc) 
//{
//	archs = qe_risc_3_11;
//}

define (sys=QE_2risc) 
{
	
	define (core = qe_risc) 
	{
		archs = qe_risc_3_11;
		
	}

	define(shared)
	{
//      regfiles = DMEM;
//      mems      = DMEM;
      regfiles = DSEM;
	}

	qe_risc core0;
//	qe_risc core1;

}


