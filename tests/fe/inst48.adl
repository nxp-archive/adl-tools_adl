//
// Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.
//
// You may distribute under the terms of the Artistic License, as specified in
// the COPYING file.
// 
// mod33 without dsyntax

int access_spr(int i, unsigned int j) ;



define (arch = qe_risc_3_11)
{

// Functions

// dispatch bus access
bits<65> dispatch_bus_access()
{
	bits<1>  ack    = 0;
	bits<8>  snum   = zero(8);
	bits<24> iaddr  = zero(24);
	bits<8>  status = zero(8);
	bits<24> page   = zero(24);

	bits<65> disp = concat(ack, snum, iaddr, status, page);

	return disp;
}

	define (regfile=EXT_SPR)
{
		"""
		External Special purpose registers.
		""";
//		size = 0x800;
		size = 0x80;
        width = 32;
	}



//SPR access
bits<64> spr_bus_access(bits<1> RDWR, bits<15> ADDR, bits<8> BE, bits<64> WDATA, bits<32> rba, bits<32> sst)
{	

	bits<16> addr_even = concat(ADDR,  zero(1));
	bits<16> addr_odd  = concat(ADDR, ~zero(1));

	bits<32> rdata_even = EXT_SPR(addr_even);
	bits<32> rdata_odd  = EXT_SPR(addr_odd );
	
	bits<32> wdata_even;
	bits<32> wdata_odd ;
	
	bits<64> rdata = concat(rdata_even, rdata_odd);

	bits<64> mask  = 0;

	bits<8>  byte_mask;

	int i;

	if(RDWR == 0)
	{
		for(i = 0; i < 8; i++)
		{
			byte_mask = (BE(0) == 1) ? 0xff : 0;

			mask = concat(mask, byte_mask);
			
			BE = concat(BE, zero(1));
		}
		
//		wdata_even = merge(WDATA(0,31 ), rdata_even, mask(0,31 ));
//		wdata_odd  = merge(WDATA(32,63), rdata_odd , mask(32,63));
		wdata_even = ((WDATA(0,31 ) & mask(0,31 )) | (rdata_even & ~mask(0,31 )));
		wdata_odd  = ((WDATA(32,63) & mask(32,63)) | (rdata_odd  & ~mask(32,63)));

		EXT_SPR(addr_even) = wdata_even;
		EXT_SPR(addr_odd ) = wdata_odd ;
		
	}	

	return rdata;
}

//	define (regfile=DMEM)
//	{
//		"""
//		DATA MEMORY.
//		""";
//		size = 0x800;
//      width = 8;
//	}
	
    define(mem=DMEM)
    {
            size = 0x8000;
            addr_unit = 1;
    }

    define(mem=IMEM)
    {
            size = 0x8000;
            instr_mem = true;
            addr_unit = 4;
    }
 
	define (regfile=DSEM)
	{
		"""
		DATA MEMORY semaphore.
		""";
		size = 32;
        width = 1;

	}


// muram access
bits<65> muram_bus_access(bits<1> RDWR, bits<24> EA, bits<8> BE, bits<64> WDATA, bits<1> SM)
{
//	static bits<32> sem = 0;
//	static unsigned char DMEM[0xffff];
	bits<8> byte;
	
	bits<5> sem_ptr = EA(16,20);

	bits<24> addr = EA & 0x00fff8;

	bits<64> rdata = 0;
//	bits<1>  sm_rdata = sem(sem_ptr,sem_ptr);
	bits<1>  sm_rdata = DSEM(sem_ptr);
	
	bits<25> i = addr;
	bits<25> e = i + 8;
//	int size_ = 0;
	
//	while(BE != 0)
//	{
//		size_ = size_ + BE(0);
//		BE = concat(BE(1,7), zero(0));
//	}
	
	// load
	if(RDWR == 1)
	{
		rdata = DMEM(addr, 8);

		if(SM == 1) DSEM(sem_ptr) = 1;

	}
	else // store
	{
		while(BE != 0)
		{
			if(BE(0) == 1)
			{
				DMEM(addr, 1) = WDATA(0,7);
			}
			
			WDATA = concat(WDATA, zero(8));
			BE    = concat(BE,    zero(1));
			addr  = addr + 1;
			
		}

		if(SM == 1) DSEM(sem_ptr) = 0;
			
	}

	return concat(sm_rdata, rdata);
}




// merge mask generator
bits<32> mmask(bits<6> ML,bits<6> MR)
{
	bits<32> mask;

	bits<32> oxffffffff = 0xffffffff;
	bits<6>  sum = ML + MR;
			
//	mask = (sum    < 32) ? ((oxffffffff >> ML) & (oxffffffff << MR)) :
	mask = (sum(0) == 0) ? ((oxffffffff >> ML) & (oxffffffff << MR)) :
						   ((oxffffffff >> ML) | (oxffffffff << MR))	;

    return mask;
}


// merge function
bits<32> merge(bits<32> A, bits<32> B, bits<32> M)
{

    return ( (A & M) | (B & ~M) );
}

// expand imm16
bits<32> imm16e( bits<16> IMM16, bits<1> HWS)
{
	bits<32> imm = 0;

	if(HWS == 1) 
       imm = concat(zero(16), IMM16);
	else   
       imm = concat(IMM16, zero(16));

	return imm;   
}

// expand imm8
bits<32> imm8e( bits<16> IMM8, bits<2> BS)
{
	bits<32> imm = 0;
	
	if(BS == 0) 
       imm = concat(IMM8, zero(24));
	   
	else if(BS == 1)   
       imm = concat(zero(8), IMM8, zero(16));

	else if(BS == 2)   
       imm = concat(zero(16), IMM8, zero(8));

	else    
       imm = concat(zero(24), IMM8);

	return imm;   
}

// General status function
bits<32> CR_status(bits<32> RES_S, bits<32> RES)
{
// RES_S  - swapped result
// RES    - result


    bits<1> z    = (RES_S == 0) ? 1 : 0 ;
	
    bits<1> neg  = ((RES_S & 0x80000000) == 0) ? 0 : 1 ;
	
    bits<1> leq  = (neg | z) ;
	
    bits<1> awz  = (((RES_S & 0xffff0000) == 0) ||
	               ((RES_S & 0x0000ffff) == 0)   ) ? 1 : 0 ;
				   
    bits<1> lwz  = ((RES_S & 0x0000ffff) == 0) ? 1 : 0 ;
	
    bits<1> lwn  = ((RES_S & 0x00008000) == 0) ? 0 : 1 ;
	
    bits<1> lbz  = ((RES_S & 0x000000ff) == 0) ? 1 : 0 ;
	
    bits<1> abz  = (((RES_S & 0xff000000) == 0) ||
	                ((RES_S & 0x00ff0000) == 0) ||
	                ((RES_S & 0x0000ff00) == 0) ||
	                ((RES_S & 0x000000ff) == 0)    ) ? 1 : 0 ;
					
    bits<1> odd  = ((RES_S & 0x00000001) == 0) ? 0 : 1 ;

    bits<1> min  = (RES == 0x80000000) ? 1 : 0 ;
	
    bits<32> CR_new = 0;//concat(zero(1), z, neg, leq, awz, lwz, lbz, zero(4), abz, odd, zero(1), min, zero(16));

	CR_new.set(1,1,z);
	CR_new.set(2,2,neg);
	CR_new.set(3,3,leq);
	CR_new.set(4,4,awz);
	CR_new.set(5,5,lwz);
	CR_new.set(6,6,lwn);
	CR_new.set(7,7,lbz);
	CR_new.set(12,12,abz);
	CR_new.set(13,13,odd);
	CR_new.set(15,15,min);

 //   return merge(CR_new, CR, 0xffbf0000); // merge new with old CR[0:15] exclude sov 
    return ((CR_new & 0xffbf0000) | (cr & ~0xffbf0000)); // merge new with old CR[0:15] exclude sov 

} // ebd of CR_status


// ADD status function
bits<32> CR_add_status(bits<33> A, bits<33> B, bits<1> Cin)
{
// A      - opperand A
// B      - opperand B
// Cin    - carry in


    bits<33> R  = A + B + Cin ;
//    bits<32> C  = A(2,32) + B(2,32) + Cin ;
    bits<32> C  = concat(zero(1), A(2,32)) + concat(zero(1), B(2,32)) + Cin ;

    bits<1> ov  = R(0) ^ C(0);

    bits<1> sov = ov | cr(9);
	
    bits<32> CR_new = 0; 

	CR_new.set(0,0,R(0));
	CR_new.set(8,8,ov);
	CR_new.set(9,9,sov);

//    return merge(CR_new, CR, 0x80c00000); // insert of cary, ov, sov in to old CR 
    return ((CR_new & 0x80c00000) | (cr & ~0x80c00000)); // insert of cary, ov, sov in to old CR 

} // end of CR_add_status


// SUB status function
bits<32> CR_sub_status(bits<32> A, bits<32> B, bits<1> Cin)
{
// A      - opperand A
// B      - opperand B
// Cin    - carry in

	bits<33> AL = A;
	bits<33> AS = signExtend(A, 33);
	
	bits<33> BL = B;
	bits<33> BS = signExtend(B, 33);
	
    bits<33> R  = AL + BL + Cin ;
    bits<32> C  = concat(zero(1), A(1,31)) + concat(zero(1), B(1,31)) + Cin ;

    bits<1> ov  = R(0) ^ C(0);
	
    bits<1> sov = ov | cr(9);

	bits<33> RS = AS + BS + Cin ;
	bits<1>  sl = RS(0);

	bits<1> sle = sl | (R(1,32) == 0);
	
    bits<32> CR_new = cr; 

	CR_new.set(0,0,~R(0));
	CR_new.set(8,8,ov);
	CR_new.set(9,9,sov);
	CR_new.set(10,10,sle);
	CR_new.set(11,11,sl);


//	CR_new = concat(RS(0,7), AS(0,7), BS(0,7), zero(6), sl, Cin); 
    return CR_new;  
//    return merge(CR_new, CR, 0x80f00000); // insert of cary, ov, sov, sle, sl in to old CR 

} // end of CR_sub_status


// alu swap function
bits<32> swap(bits<32> D, bits<32> type)
{
     bits<32> sw = D;
	 
    if (type == 0) // bit swap
	{

		sw.set(0,0,D(7));
		sw.set(1,1,D(6));
		sw.set(2,2,D(5));
		sw.set(3,3,D(4));
		sw.set(4,4,D(3));
		sw.set(5,5,D(2));
		sw.set(6,6,D(1));
		sw.set(7,7,D(0));
		sw.set(8,8,D(15));
		sw.set(9,9,D(14));
		sw.set(10,10,D(13));
		sw.set(11,11,D(12));
		sw.set(12,12,D(11));
		sw.set(13,13,D(10));
		sw.set(14,14,D(9));
		sw.set(15,15,D(8));
		sw.set(16,16,D(23));
		sw.set(17,17,D(22));
		sw.set(18,18,D(21));
		sw.set(19,19,D(20));
		sw.set(20,20,D(19));
		sw.set(21,21,D(18));
		sw.set(22,22,D(17));
		sw.set(23,23,D(16));
		sw.set(24,24,D(31));
		sw.set(25,25,D(30));
		sw.set(26,26,D(29));
		sw.set(27,27,D(28));
		sw.set(28,28,D(27));
		sw.set(29,29,D(26));
		sw.set(30,30,D(25));
		sw.set(31,31,D(24));
	}

	else if(type == 1) // byte swap
	{
		sw = concat(D(8,15),D(0,7),D(24,31),D(16,23));
	}

	else if(type == 2) // word swap
	{
		sw = concat(D(16,31),D(0,15));
	}

	else if(type == 3) // byte sift right
	{
		sw = concat(zero(8),D(0,23));
	}

	else if(type == 4) // bit sift right
	{
		sw = concat(zero(1),D(0,30));
	}

	else if(type == 5) // exclude upper word
	{
		sw = concat(zero(16),D(16,31));
	}

	else if(type == 6) // little endian swap
	{
		sw = concat(D(24,31),D(16,23),D(8,15),D(0,7));
	}

    return sw;
}

// shift function
bits<33> bit_shift(bits<32> D, bits<1> Cin, bits<5> size_, bits<3> type, bits<1> dir)
{
// Inputs:
// D    - data for shift
// Cin  - carry in
// size - size of shift
// type - shift type
// dir  - direction; 1/0 - left/rigth

// Output 
// bits<1>  Cout - carry out
// bits<32> Dout - data 

	bits<1>  Cout  = 0;
	bits<1>  Carry = Cin; 
	bits<32> Dout  = D;
	
	bits<33> k=0;

	bits<6> i=0;

	for(i=0; i < size_; i=i+1)
	{
		if(dir == 1) // shift left
		{
			Cout = Dout(0);
			
			if (type == 2) // rotate with carry
			{
			  Dout  = concat(Dout(1,31), Carry);
			  Carry = Cout;
			}
			
			else if (type == 3) // rotate
			{
			  Dout  = concat(Dout(1,31), Cout);
			}
			
			else if (type == 4) // shift algebrical with carry
			{
			  Dout  = concat(Dout(1,31), Carry);
			  Carry = 0;
			}
			
			else if (type == 5) // shift algebrical
			{
			  Dout  = concat(Dout(1,31), zero(1));
			}
			
			else if (type == 6) // shift logical with carry
			{
			  Dout  = concat(Dout(1,31), Carry);
			  Carry = 0;
			}
			
			else if (type == 7) // shift logical
			{
			  Dout  = concat(Dout(1,31), zero(1));
			}
		} // end of if(dir == 1) // shift left
		
		else // shift right
		{
			Cout = Dout(31);
			
			if (type == 2) // rotate with carry
			{
			  Dout  = concat(Carry, Dout(0,30));
			  Carry = Cout;
			}
			
			else if (type == 3) // rotate
			{
			  Dout  = concat(Cout, Dout(0,30));
			}
			
			else if (type == 4) // shift algebrical with carry
			{
			  Dout  = concat(Carry, Dout(0,30));
			}
			
			else if (type == 5) // shift algebrical
			{
			  Dout  = concat(Dout(0), Dout(0,30));
			}
			
			else if (type == 6) // shift logical with carry
			{
			  Dout  = concat(Carry, Dout(0,30));
			  Carry = 0;
			}
			
			else if (type == 7) // shift logical
			{
			  Dout  = concat(zero(1), Dout(0,30));
			}

		} // end of else // shift right

	} // end of for
	
	bits<33> res = concat(Cout, Dout);

    return res; 

} // end of shift function 

	define (reg=PR)
	{
		"""
		Temporal regester for debug prints .
		""";
		width = 65;

    }

	//
	// Registers.
	//

//	define (reg=CIA)
//	{
//		"""
//		Current instruction address for fetch.
//		""";
//	    classes = cia;
//	    attrs = cia;
//		reset = 0;
//		define(write)
//		{
//			action = func(bits<32> value)
//			{
//	      	    CIA.set(6,29,PC);
//			};
//		}
//    }

	define (reg=NIA) 
	{
		"""
		Next instruction address for fetch.
	    """;
//		classes = nia;
		attrs = nia;
//		reset = 4;
		reset = 0;
		define(write)
		{
			action = func(bits<32> value)
			{
//	      	    NIA.set(6,29,NPC);
//	      	    NIA.set(0,31,NPC);
              NIA(0,31) = PC;
			};
		}
	}
	
	define (reg=PC)
	{
		"""
		Current instruction address.
		""";

		width = 24;
		reset = 0;
	    attrs = cia;
    }

	define (reg=NPC) 
	{
		"""
		Next instruction address.
	    """;
		width = 24;
		reset = 1;
//		attrs = nia;
	}
	
	define (reg=NNPC) 
	{
		"""
		NPC+.
	    """;
		width = 24;
		reset = 2;
	}
	
        define (reg=r1)    {}
        define (reg=r2)    {}
        define (reg=r3)    {}
        define (reg=r4)    {}
        define (reg=r5)    {}
        define (reg=r6)    {}
        define (reg=r7)    {}
        define (reg=r8)    {}
        define (reg=r9)    {}
        define (reg=r10)   {}
        define (reg=r11)   {}
        define (reg=r12)   {}
        define (reg=r13)   {}
        define (reg=r14)   {}
        define (reg=r15)   {}
        define (reg=r16)   {}
        define (reg=r17)   {}
        define (reg=r18)   {}
        define (reg=r19)   {}
        define (reg=r20)   {}
        define (reg=r21)   {}
        define (reg=r22)   {}
        define (reg=r23)   {}
        define (reg=r24)   {}
        define (reg=r25)   {}
        define (reg=r26)   {}
        define (reg=rpage) {}
        define (reg=rba)   {}
        define (reg=ser)   {}
        define (reg=sst)   {}
        define (reg=sp)    {}
        define (reg=r0)
        {
            reset   = 0;
			
			define (read)  
			{
				action = { return 0; };
			}
			
			define (write)  
			{
				ignore = true;
			}
        }

	define (regfile=GPR0)
	{
		"""
		General purpose registers.
		""";
		size = 32;
	
		define (entry=0 ) { reg = r1    ;}  
		define (entry=1 ) { reg = r2    ;}  
		define (entry=2 ) { reg = r3    ;}  
		define (entry=3 ) { reg = r4    ;}  
		define (entry=4 ) { reg = r5    ;}  
		define (entry=5 ) { reg = r6    ;}  
		define (entry=6 ) { reg = r7    ;}  
		define (entry=7 ) { reg = r8    ;}  
		define (entry=8 ) { reg = r9    ;}  
		define (entry=9 ) { reg = r10   ;}  
		define (entry=10) { reg = r11   ;}  
		define (entry=11) { reg = r12   ;}  
		define (entry=12) { reg = r13   ;}  
		define (entry=13) { reg = r14   ;}  
		define (entry=14) { reg = r15   ;}  
		define (entry=15) { reg = r16   ;}  
		define (entry=16) { reg = r17   ;}  
		define (entry=17) { reg = r18   ;}  
		define (entry=18) { reg = r19   ;}  
		define (entry=19) { reg = r20   ;}  
		define (entry=20) { reg = r21   ;}  
		define (entry=21) { reg = r22   ;}  
		define (entry=22) { reg = r23   ;}  
		define (entry=23) { reg = r24   ;}  
		define (entry=24) { reg = r25   ;}  
		define (entry=25) { reg = r26   ;}  
		define (entry=26) { reg = rpage ;}  
		define (entry=27) { reg = rba   ;}  
		define (entry=28) { reg = ser   ;}  
		define (entry=29) { reg = sst   ;}  
		define (entry=30) { reg = sp    ;}  
		define (entry=31) { reg = r0    ;}
		prefix=GPR;
	}

	define(regfile=GPR) 
        {
	  alias=GPR0;
	  prefix=GPR;
        }

	define (reg=cr) 
	{
		"""
		Conditional Regester .
	    """;

//		regfile = (SPR, 1);
		reset   = 0x8001;

		define (field=carry)
		{
			bits = 0;
		}
		
		define (field=zero)
		{
			bits = 1;
		}
		
		define (field=neg)
		{
			bits = 2;
		}
		
		define (field=leq)
		{
			bits = 3;
		}
		
		define (field=awz)
		{
			bits = 4;
		}
		
		define (field=lwz)
		{
			bits = 5;
		}
		
		define (field=lwn)
		{
			bits = 6;
		}
		
		define (field=lbz)
		{
			bits = 7;
		}
		
		define (field=ov)
		{
			bits = 8;
		}
		
		define (field=sov)
		{
			bits = 9;
		}
		
		define (field=sle)
		{
			bits = 10;
		}
		
		define (field=sl)
		{
			bits = 11;
		}
		
		define (field=abz)
		{
			bits = 12;
		}
		
		define (field=odd)
		{
			bits = 13;
		}
		
		define (field=mod)
		{
			bits = 14;
		}
		
		define (field=min)
		{
			bits = 15;
		}
		
		define (field=rcnf0)
		{
			bits = 16;
		}
		
		define (field=rcnf1)
		{
			bits = 17;
		}
		
		define (field=rcnf2)
		{
			bits = 18;
		}
		
		define (field=rcnf3)
		{
			bits = 19;
		}
		
		define (field=rcnf4)
		{
			bits = 20;
		}
		
		define (field=rcnf5)
		{
			bits = 21;
		}
		
		define (field=leac)
		{
			bits = 22;
		}
		
		define (field=rcnf7)
		{
			bits = 23;
		}
		
		define (field=cr24)
		{
			bits = 24;
		}
		
		define (field=cr25)
		{
			bits = 25;
		}
		
		define (field=cr26)
		{
			bits = 26;
		}
		
		define (field=cr27)
		{
			bits = 27;
		}
		
		define (field=emrd)
		{
			bits = 28;
		}
		
		define (field=emr)
		{
			bits = 29;
		}
		
		define (field=sm)
		{
			bits = 30;
		}
		
		define (field=alw)
		{
			bits = 31;
			readonly=true;
		}
	}
	
	define (reg=SNUMR) 
	{
		"""
		Serial Number Register .
	        """;

		reset   = 0x80000000;

		define (field=org_bg)
		{
			bits = 0;
		}
		
		define (field=org_snum)
		{
			bits = (8,15);
		}
		
		define (field=bg)
		{
			bits = 16;
		}
		
		define (field=snum)
		{
			bits = (24,31);
		}
	}
	
	define (reg=ILR) 
	{
		"""
		Interrupt Link Register .
	    """;

		reset   = 0;

		define (field=en)
		{
			bits = 0;
		}
		
		define (field=addr)
		{
			bits = (8,31);
		}
	}
	
	define (reg=ITR) 
	{
		"""
		Interrupt Temporal Register .
	    """;

		reset   = 0;

	}
	
	define (reg=BTR) 
	{
		"""
		Breakpoint Temporal Register .
	    """;

		reset   = 0;

	}
	
	define (reg=DVR) 
	{
		"""
		Debug Virtual Register .
	    """;
 		define (read)  
		{ 
			action = { return 0; }; 
		}
		
		define (write) 
		{
			ignore = true; 
		} 
	}
	
	define (reg=BGTLR) 
	{
		"""
		BackGround Task Link Register .
	    """;

		reset   = 0;

		define (field=en)
		{
			bits = 0;
		}
		
		define (field=addr)
		{
			bits = (8,31);
		}
	}
	
	define (reg=RESERVED0) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVED2) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVED4) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVED6) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVED8) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVEDa) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVEDc) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	define (reg=RESERVEDe) { define (read)  { action = { return 0; }; } define (write) { ignore = true; } } 
	
	define (regfile=SPR)
	{
		"""
		Special purpose registers.
		""";
		size = 0x80;
		
		define (entry=0x1) {reg=cr;}
		define (entry=0x3) {reg=SNUMR;}
		define (entry=0x5) {reg=ILR;}
		define (entry=0x7) {reg=ITR;}
		define (entry=0x9) {reg=BTR;}
		define (entry=0xb) {reg=DVR;}
		define (entry=0xd) {reg=BGTLR;}
		
		define (entry=0x0) {reg=RESERVED0;}
		define (entry=0x2) {reg=RESERVED2;}
		define (entry=0x4) {reg=RESERVED4;}
		define (entry=0x6) {reg=RESERVED6;}
		define (entry=0x8) {reg=RESERVED8;}
		define (entry=0xa) {reg=RESERVEDa;}
		define (entry=0xc) {reg=RESERVEDc;}
		define (entry=0xe) {reg=RESERVEDe;}
	}

	//
	// Instruction fields.
	//

	define (instrfield=OPCD) 
	{
		"""
		Primary opcode.
		""";
		bits = (0,4);
	}

	define (instrfield=OPCD_SHRT) 
	{
		"""
		Primary short opcode.
		""";
		bits = (0,3);
	}

	define (instrfield=SW) 
	{
		"""
		Swap option for LD instruction
		""";
		bits = 4;
		enumerated = ("",".leswp");
		value = "";
	}

	define (instrfield=SM) 
	{
		"""
		Semaphor option for DMA instructions
		""";
		bits = 4;
		enumerated = ("",".sm");
		value = "";
	}

	define (instrfield=OPCD_BTM) 
	{
		"""
		Secondary opcode for BTM instructions
		""";
		bits = (5,7);
	}

	define (instrfield=CRC) 
	{
		"""
		CRC type for BCRC/BCOPY instructions
		""";
		bits = (8,9);
		enumerated = ("",".crc10",".crc32",".s");
		value = "";
	}

	define (instrfield=DSIZE) 
	{
		"""
		DSIZE field for BCAM/BMIN/BMAX instructions
		""";
		bits = (8,9);
		enumerated = (".b1",".b2",".b4",".b8");
		value = ".b4";
	}

	define (instrfield=RV) 
	{
		"""
		RV option for BCRC/BCOPY instructions
		""";
		bits = 10;
		enumerated = ("",".rv");
		value = "";
	}

	define (instrfield=RVS) 
	{
		"""
		RVS option for BCRCI/BCOPYI instructions
		""";
		bits = (10,11);
		enumerated = ("",".rvc",".rv");
		value = "";
	}

	define (instrfield=M) 
	{
		"""
		M option for BCAM instructions
		""";
		bits = 10;
		enumerated = ("",".mask");
		value = "";
	}

	define (instrfield=DMA_SIZE) 
	{
		"""
		Size option for DMA instructions
		""";
		bits = (5,8);
		enumerated = ("",".r",".b1",".b1!",".b2",".b2!",".b4",".b4!",".b8",".b8!",
		                 ".rs",".rs!",".b24",".b32",".b48",".eob");
		value = "";		   
	}

	define (instrfield=DATA) 
	{
		"""
		Size option for DMA instructions
		""";
		bits = 9;
		enumerated = ("",".d");
		value = "";
	}

	define (instrfield=OPCD_B10) 
	{
		"""
		DMAR/DMAW selector for DMA instructions
		""";
		bits = 10;
	}

	define (instrfield=OPCD_B11) 
	{
		"""
		Reserved field for BCAMI/BMINI/BMAXI instructions
		""";
		bits = 11;
	}

	define (instrfield=OPCD_B12) 
	{
		"""
		Reserved field for BCAMI/BMINI/BMAXI instructions
		""";
		bits = 12;
	}

	define (instrfield=DES) 
	{
		"""
		DES option for BCOPYI instruction
		""";
		bits = 12;
		enumerated = ("",".des");
		value = "";
	}

	define (instrfield=BUFFER_SIZE) 
	{
		"""
		BUFFER_SIZE field for BTM Imm instructions
		""";
		bits = (13,15);
		enumerated = ("",".r",".bf4",".bf8",".bf16",".bf32",".bf48",".bf64");
		value = "";
	}

	define (instrfield=SML) 
	{
		"""
		Semaphor option for LD instruction
		""";
		bits = 8;
		enumerated = ("",".sm");
		value = "";
	}

	define (instrfield=HWS) 
	{
		"""
		High Word Select for ALU immideate instructions
		""";
		bits = 4;
	}

	define (instrfield=NOT_J) 
	{
		"""
		Condition NOT for JMP instructions
		""";
		bits = 4;
		enumerated = ("","~");
		value = "";
	}

	define (instrfield=OPCD_B5) 
	{
		"""
		Secondary opcode.
		""";
		bits = 5;
	}

	define (instrfield=HU) 
	{
		"""
		Flag to update half of target register for push instruction.
		""";
		bits = 5;
		enumerated = (".c","");
		value = "";
	}

	define (instrfield=RS) 
	{
		"""
		RS field for mfspr instruction.
		""";
		bits = 5;
	}

	define (instrfield=AU) 
	{
		"""
		Address Update option for pushsch/ldsch instructions.
		""";
		bits = 5;
	}

	define (instrfield=SBS) 
	{
		"""
		BS field for mtspri instruction.
		""";
		bits = (6,7);
		enumerated = (".by0",".by1",".by2",(".by3",""));
	}

	define (instrfield=OPCD_B6) 
	{
		"""
		Secondary opcode for push/pushl instructions.
		""";
		bits = 6;
	}

	define (instrfield=OPCD_B7) 
	{
		"""
		Secondary opcode.
		""";
		bits = 7;
	}

	define (instrfield=CMPRS) 
	{
		"""
		CMPRS option for push/pushl instructions.
		""";
		bits = 7;
		enumerated = ("",".c");
		value = "";
	}

    define (instrfield=B8) 
	{
		"""
		mfspr.b8 instructions.
		""";
		bits = 7;
		enumerated = (".b4",".b8");
		value = ".b4";
	}

	define (instrfield=CMPRS_J) 
	{
		"""
		CMPRS option for jmp instructions.
		""";
		bits = 23;
		enumerated = ("",".c");
		value = "";
	}


    define (instrfield=OPCD_B8) 
	{
		"""
		LD/ST selector for LDM/STM instructions.
		""";
		bits = 8;
	}

    define (instrfield=IMM8S) 
	{
		"""
		IMM8 for mtspri instructions.
		""";
		bits = (8,15);
	}

    define (instrfield=CASE_SIZE) 
	{
		"""
		size of case instruction.
		""";
		bits = (8,10);
		enumerated = (".b2",".b4",".b8",".b16",".b32",".b64",".b128",".b256");
		value = ".b16";
	}

	define (instrfield=NOP_J) 
	{
		"""
		NOP option in JMP instruction.
		""";
		bits = 5;
		
		enumerated = ("",".n");
		value = "";
	}

	define (instrfield=INVA) 
	{
		"""
		INV operand B in ALU instruction.
		""";
		bits = 5;
		enumerated = ("","~");
		value = "";
	}

	define (instrfield=SIZEB) 
	{
		"""
		SIZEB field for mtspr instruction.
		""";
		bits = (5,7);
		enumerated = (".b1",".b2",".b3",".b4",".b1m",".b2m",".b3m");
		value = ".b4";
	}

	define (instrfield=SIZEA) 
	{
		"""
		SIZEA field for mtspr instruction.
		""";
		bits = (8,10);
		enumerated = (".b1",".b2",".b3",".b4",".b1m",".b2m",".b3m");
		value = ".b4";		
	}
	define (instrfield=SIZE_P) 
	{
		"""
		Pseudo field for ".size" in mtspr instruction.
		""";
 	        width = 4;
		pseudo = true;
		enumerated = (".b1",".b2",".b3",".b4",".b1m",".b2m",".b3m");
		value = ".b4";
		
	}

   define (instrfield=OPCD_ALU) 
	{
		"""
		Secondary opcode for ALU instructions.
		""";
		bits = (6,8);
	}

   define (instrfield=SIZE_LD) 
	{
		"""
		size field for ld instructions.
		""";
		bits = (5,7);
		enumerated = (".b1",".b1s",".b2",".b2s",".b4",".b3",".b8",".q");
		value = ".b4";
	}
	
   define (instrfield=SIZE_ST) 
	{
		"""
		size field for st instructions.
		""";
		bits = (5,7);
		enumerated = (".b1",reserved,".b2",reserved,".b4",".b3",".b8",".q");
		value = ".b4";
	}
    define (instrfield=RT1) 
	{
		"""
		Reserved tag for pushsch/ldsch instructions.
		""";
		bits = 7;
		enumerated = ("",".rt1");
		value = "";
	}

    define (instrfield=RT2) 
	{
		"""
		Reserved tag for pushsch/ldsch instructions.
		""";
		bits = 8;
		enumerated = ("",".rt2");
		value = "";
	}

    define (instrfield=UPDATE) 
	{
		"""
		Update option of ALU instruction.
		""";
		bits = 9;
		enumerated = (".n","");
		value = "";
	}
    define (instrfield=NUPDATE) 
	{
		"""
		Not update option of ALU instruction.
		""";
		bits = 9;
		enumerated = ("",".u");
		value = "";
	}	
    define (instrfield=RT3) 
	{
		"""
		Reserved tag for pushsch/ldsch instructions.
		""";
		enumerated = ("",".rt3");
		value = "";		
		bits = 9;
	}

	define (instrfield=FLAGS) 
	{
		"""
		CR update for ALU instruction.
		""";
		bits = 10;
		enumerated = ("",".f");
		value = "";
	}

	define (instrfield=UR) 
	{
		"""
		Micro code requesr option for pushsch/ldsch instructions.
		""";
		bits = 10;
		enumerated = ("",".ur");
		value = "";
	}

	define (instrfield=IMM16) 
	{
		"""
		immideate 16.
		""";
		bits = (16,31);
	}

	define (instrfield=IMM8) 
	{
		"""
		immideate 8.
		""";
		bits = (24,31);
	}

    	define (instrfield=IMM_P1)
	{
		"""
		Pseudo immediate for addi,addci,subi,subci
		""";
		pseudo = true;
                width = 32;
		valid_masks = ((0xFFFF0000,0),(0xFFFF,0));
		display = hex;	
	}

    	define (instrfield=IMM_P2)
	{
		"""
		Pseudo immediate for mtspri,addis,subis,addcis,subcis
		""";
		pseudo = true;
                width = 32;
		valid_masks = ((0xFFFFFF00,0),(0xFFFF00FF,0),(0xFF00FFFF,0),(0x00FFFFFF,0));
		display = hex;	

	}

    	define (instrfield=IMM_P3)
	{
		"""
		Pseudo immediate for andi,ori,xori,movei
		""";
		pseudo = true;
                width = 32;
		valid_masks = ((0xFFFF0000,0),(0xFFFF,0),(0xFFFF0000,0xFFFF0000),(0xFFFF,0xFFFF));
		display = hex;	
	}

    	define (instrfield=IMM_P4)
	{
		"""
		Pseudo immediate for andis,oris,xoris
		""";
		pseudo = true;
                width = 32;
		valid_masks = ((0xFFFFFF00,0),(0xFFFF00FF,0),(0xFF00FFFF,0),(0x00FFFFFF,0),
		               (0xFFFFFF00,0xFFFFFF00),(0xFFFF00FF,0xFFFF00FF),
			       (0xFF00FFFF,0xFF00FFFF),(0x00FFFFFF,0x00FFFFFF));
		display = hex;	
			       
	}		
	define (instrfield=RSV_B21) 
	{
		"""
		Reserved bit.
		""";
		bits = 21;
	}

    define (instrfield=OPCD_B21) 
	{
		"""
		CALL/POP/RETURN bit.
		""";
		bits = 21;
	}

    define (instrfield=OPCD_B22) 
	{
		"""
		CALL/POP/RETURN bit.
		""";
		bits = 22;
	}

    define (instrfield=BS) 
	{
		"""
		Bite select bit for ALUIS instructions.
		""";
		bits = (22,23);
	}

    define (instrfield=SWAP_TYPE) 
	{
		"""
		ALU swap type.
		""";
		bits = (26,28);
		enumerated = (".bitsw", ".bytsw", ".wrdsw", ".bytshr", ".bitshr", ".extuw",".leswp","");
		value = ""; 

	}

    define (instrfield=DS_ALU) 
	{
		"""
		data size for cnt and ffs instructions.
		""";
		bits = (26,29);
		enumerated = (reserved,".b1",reserved,".b2",reserved,reserved,reserved,
		              ".b3",".b1m",reserved,reserved,reserved,".b2m",reserved,".b3m",".b4");
		value = ".b4";	      
	}

    define (instrfield=DIRECTION) 
	{
		"""
		Shift instructions direction.
		""";
		bits = 26;
		enumerated = (".r",".l");
	}

    define (instrfield=SHIFT_OPTION) 
	{
		"""
		shift type for shift* instructions.
		""";
		bits = (27,29);
		enumerated = (reserved,reserved,".rotc",".rot",".algc",".alg",".logc","");
		value = "";
	}

    define (instrfield=RSV_B29) 
	{
		"""
		Reserved bit.
		""";
		bits = 29;
	}

    define (instrfield=RSV_B30) 
	{
		"""
		Reserved bit.
		""";
		bits = 30;
	}

    define (instrfield=RSV_B31) 
	{
		"""
		Reserved bit.
		""";
		bits = 31;
	}

    define (instrfield=OPCD_B31) 
	{
		"""
		Secondary opcode.
		""";
		bits = 31;
	}

    define (instrfield=ONE) 
	{
		"""
		ONE option for add/sub instructions.
		""";
		bits = 31;	
		enumerated = ("",".one");
		value = "";
	}


	define (instrfield=ML)
	{
		"""
		Mask Left.
		""";
		bits = (6,10);
	}
	
	define (instrfield=BIT)
	{
		"""
		Conditional BIT select for JMP instruction.
		""";
		bits = (6,10);
	}
	
	define (instrfield=MR)
	{
		"""
		Mask Rigth.
		""";
		bits = (26,30);
	}
	
	define (instrfield=RA)
	{
		"""
		RA.
		""";
		bits = (11,15);
		ref = GPR;
		//value = 0x1e;
	}
	
	define (instrfield=RA_2)
	{
		"""
		RA_2.
		""";
		table = ((0,1), reserved,(2,3),reserved,(4,5),reserved,(6,7),reserved,
			 (8,9), reserved,(10,11),reserved,(12,13),reserved,(14,15),reserved,	
			 (16,17), reserved,(18,19),reserved,(20,21),reserved,(22,23),reserved,
			 (24,25), reserved,(26,27),reserved,(28,29),reserved,(30,31),reserved);

		bits = (11,15);
		ref = GPR;
	}

	define (instrfield=RA_4)
	{
		"""
		RA_4.
		""";
		table = ((0,1,2,3),reserved,reserved,reserved,(4,5,6,7),reserved,reserved,reserved,
			 (8,9,10,11),reserved,reserved,reserved,(12,13,14,15),reserved,reserved,reserved,
			 (16,17,18,19),reserved,reserved,reserved,(20,21,22,23),reserved,reserved,reserved,	
			 (24,25,26,27),reserved,reserved,reserved,(28,29,30,31),reserved,reserved,reserved);	
		bits = (11,15);
		ref = GPR;
	}
	

	define (instrfield=RB)
	{
		"""
		RB.
		""";
		bits = (16,20);
		ref  = GPR;
		//value = 0x1f;
	}
	
	define (instrfield=RC)
	{
		"""
		RC.
		""";
		bits = (21,25);
		ref = GPR;
	}
	
	define (instrfield=DATA5)
	{
		"""
		DATA5 field for mergei instruction.
		""";
		bits = (11,15);
	}
	
	define (instrfield=IMM5M)
	{
		"""
		IMM5 field for rlmerge and mergei instructions.
		""";
		bits = (21,25);
	}
	
	define (instrfield=IMM5)
	{
		"""
		shift size for shifti instruction.
		""";
		bits = (16,20);
	}
	
	define (instrfield=CFA)
	{
		"""
		pointer to CR bit for alu conditional instructions.
		""";
		bits = (26,30);
		enumerated =	("carry","zero","neg","leq","awz","lwz","lwn",
				"lbz",("ov","cr[23]"),"sov","sle",
		                "sl","abz","odd","mod","min","rcnf0","rcnf1","rcnf2",
			        "rcnf3","rcnf4", "rcnf5",("leac","rcnf6"),
			        "rcnf7","emrd","emr","sm");
	}
	
	define (instrfield=NOTAC)
	{
		"""
		NOT of CR flag for alu conditional instructions.
		""";
		bits = 31;
		enumerated = ("","~");
		value = "";
	}
	
	define (instrfield=INSTR_OFFSET)
	{
		"""
		instruction offset for imm. jmp instructions
		""";
		bits = (16,31);
	}
	
	define (instrfield=LONG_OFFSET)
	{
		"""
		instruction offset for pushl instruction
		""";
		bits = (8,31);
	}
	
	define (instrfield=DRAM_OFFSET)
	{
		"""
		MURAM offset for ld/st/spr instructions
		""";
		bits = (21,31);
		is_signed = true;
	}
	
	define (instrfield=SPRF)
	{
		"""
		SPR address field for mtspr/mfspr instructions
		""";
		bits = (21,31);
	}
	
	define (instrfield=SPRF_I)
	{
		"""
		SPR address field for mtspr/mfspr instructions
		""";
		bits = (29,31);
	        table = ((1),(3),(5),(7)) ;
	}
	
	define (parm=Fetch) 
	{
    	options = (Normal,JmpN);
    	value = Normal;
	}

//	post_fetch = func(unsigned size_) 
//	{
//
//		NPC = NPC + 1; 
//	};

	post_exec =
	{
//PR=PC;		
//PR=NPC;		
//PR=NNPC;		
		bits<24> s = 1;

		PC(0,23) = (Fetch == JmpN) ? NNPC : NPC;

		NIA(0,31) = PC;
		
		NPC(0,23) = (Fetch == JmpN) ? NNPC + s : NNPC;

		NNPC(0,23) = NPC + 1;
		
//PR=PC;		
//PR=NPC;		
//PR=NNPC;		
    	Fetch = Normal;
		
	};

    define (subinstr=ld2) {
	fields = (SW,SIZE_LD(6),RA_2,FLAGS);
	action = func(bits<64> data1) {
	        bits<64> data_ = data1;
		GPR(RA_2(0)) = (SW == 1) ? concat(data_(24,31), data_(16,23), data_(8,15), data_(0,7)) 
  			                 : data_(0 ,31);
			       GPR(RA_2(1)) = (SW == 1) ? concat(data_(56,63), data_(48,55), data_(40,47), data_(32,39))
                                             : data_(32,63);

			if(FLAGS == 1)
		        {
			     cr = CR_status(GPR(RA_2(0)),GPR(RA_2(0)));
			     cr.min = 0;
			}
		data1 = data_;
	   };
        }

    define (subinstr=ld4) {
	fields = (SW,SIZE_LD(7),RA_4,FLAGS);
	action = func(bits<64> data1) {
		       bits<64> data_ = data1;

			GPR(RA_4(0)) = (SW == 1) ? concat(zero(16), data_ (24,31), data_(16,23)) 
				 	         : concat(zero(16), data_(0 ,15)) ;
											
			GPR(RA_4(1)) = (SW == 1) ? concat(zero(16), data_ (8 ,15), data_(0,7)) 
					         : concat(zero(16), data_(16,31)) ;
											
			GPR(RA_4(2)) = (SW == 1) ? concat(zero(16), data_ (56,63), data_(48,55)) 
					         : concat(zero(16), data_(32,47)) ;
												
			GPR(RA_4(3)) = (SW == 1) ? concat(zero(16), data_ (40,47), data_(32,39))
					         : concat(zero(16), data_(48,63)) ;

			if(FLAGS == 1)
  			{
			  bits<32> tmps = concat(GPR(RA_4(0))(16,31), GPR(RA_4(1))(16,31));		
			  cr = CR_status(tmps, tmps);
			  cr.min = 0;
			}

			data1 = data_;
	  };
        }
    define(subinstr=ld1) {
	fields = (SW,SIZE_LD,RA,FLAGS);
	action = func(bits<64>& data1) {
			bits<64> data_ = data1;
			if     (SIZE_LD == 0) GPR(RA) = concat(zero(24), data_(0,7));
			
			// .b1s
			if(SIZE_LD == 1) GPR(RA) = signExtend(data_(0,7), 32);
			
			// .b2
			if(SIZE_LD == 2) GPR(RA) = (SW == 1) ? concat(zero(16), data_(8,15), data_(0,7)) 
								    : concat(zero(16), data_(0,15)) ;
											
			// .b2s
			if(SIZE_LD == 3) GPR(RA) = (SW == 1) ? signExtend(concat(data_(8,15), data_(0,7)), 32) 
								    : signExtend(data_(0,15), 32) ;
											
			// .b4
			if(SIZE_LD == 4) GPR(RA) = (SW == 1) ? concat(data_(24,31), data_(16,23), data_(8,15), data_(0,7)) 
								    : data_(0,31) ;
											
			// .b3
			if(SIZE_LD == 5) GPR(RA) = concat(zero(8), data_(8,31));
			
			if(FLAGS == 1)
		        {
			     cr = CR_status(GPR(RA),GPR(RA));
			     cr.min = 0;
			}
			data1 = data_;
        } ;
    }	
	define(instr=ld) {
		fields=(OPCD_SHRT(0), reg_update, SML, NUPDATE, RB, DRAM_OFFSET );
		define (subinstrs=reg_update) {
		  subs= (ld1,ld2,ld4);
		}
		names = (ld_1,ld_2, ld_4);
	        syntax  =  ("ld%p%p%p%p%p %f,%f(%f)",SIZE_LD   ,SW,SML,NUPDATE,FLAGS,RA    ,DRAM_OFFSET,RB,
			   "ld%p%p%p%p%p %f,%f(%f)",SIZE_LD(6),SW,SML,NUPDATE,FLAGS,RA_2  ,DRAM_OFFSET,RB,
		           "ld%p%p%p%p%p %f,%f(%f)",SIZE_LD(7),SW,SML,NUPDATE,FLAGS,RA_4  ,DRAM_OFFSET,RB);
			 
	//	dsyntax = ("ld%p%p%p%p%p  %f,%f(%f)",SIZE_LD,SW,SML,NUPDATE,FLAGS,RA    ,DRAM_OFFSET,RB,
	//		   "ld.b8%p%p%p%p %f,%f(%f)",        SW,SML,NUPDATE,FLAGS,RA_2  ,DRAM_OFFSET,RB,
	//          "ld.q%p%p%p%p  %f,%f(%f)",        SW,SML,NUPDATE,FLAGS,RA_4  ,DRAM_OFFSET,RB);
	//
		action = {
		 	bits<64> data_  ;
			bits<24> leswp_addr_correction = ((SW & cr(22)) == 1) ? 0x3 : 0;
			
			 bits<24> EA_temp = GPR(RB) + signExtend(DRAM_OFFSET,24);
			
			 bits<24> EA = EA_temp ^ leswp_addr_correction;

		        if(SIZE_LD == 1 || SIZE_LD == 5) EA = EA & 0xfffffe;
		        if(SIZE_LD == 2 || SIZE_LD == 6) EA = EA & 0xfffffc;
		        if(SIZE_LD == 3 || SIZE_LD == 7) EA = EA & 0xfffff8;

//			 if(SIZE_LDST(0,1) == 1) EA = EA & 0xfffffe;
//			 else if(SIZE_LDST(0,1) == 2) EA = EA & 0xfffffc;
//			 else if(SIZE_LDST(0,1) == 3) EA = EA & 0xfffff8;

			 if (NUPDATE == 1) GPR(RB) = merge(GPR(RB), EA_temp, 0xff000000);
			
			 bits<3>  addr_lsb = EA(21,23);

			 bits<8>  be;
			
			 if     (SIZE_LD == 0) be = 0x80;
			 else if(SIZE_LD == 1) be = 0x80;
		 	 else if(SIZE_LD == 2) be = 0xc0;
			 else if(SIZE_LD == 3) be = 0xc0;
			 else if(SIZE_LD == 4) be = 0xf0;
			 else if(SIZE_LD == 5) be = 0x70;
			 else if(SIZE_LD == 6) be = 0xff;
			 else if(SIZE_LD == 7) be = 0xff;
				
			 be = be >> addr_lsb;
			
			 bits<65> tmp  = muram_bus_access(1, EA, be, 0, SML);
 
			 bits<6>  bit_shift = concat(EA(21,23), zero(3));

			 data_  = tmp(1,64) << bit_shift;

			 if(SML == 1)
  			 {
			 	cr.sm = tmp(0);
  			 }

		         reg_update(data_);
		};

        }

	define(subinstr=st1) 
        {
	   fields = (RA,SIZE_ST,FLAGS);
	   action = func(bits<64>& data_) {
			// .b4/.b3
		data_ = concat(GPR(RA), GPR(RA));

		// .b1
		if     (SIZE_ST == 0) 
		{
                        data_ = concat(zero(32),GPR(RA)(24,31),GPR(RA)(24,31),GPR(RA)(24,31),GPR(RA)(24,31));
										  
                        data_ = concat(data_(32,63),data_(32,63));
		}									  
			
		// .b2
		else if(SIZE_ST == 2) data_ = concat(GPR(RA)(16,31),GPR(RA)(16,31),GPR(RA)(16,31), GPR(RA)(16,31));

		   if(FLAGS == 1)
	          {
		     cr = CR_status(GPR(RA), GPR(RA));
	             cr.min = 0;
		  }


           };
        }
	define(subinstr=st0) 
        {
	   fields = (RA(0x1f),SIZE_ST(6),FLAGS);
           action = func(bits<64> &data_) {
		data_ = concat(GPR(31), GPR(31));
		   if(FLAGS == 1)
	          {
		     cr = CR_status(GPR(31), GPR(31));
	             cr.min = 0;
		  }


           };
        }

	define(subinstr=st2) 
        {
	   fields = (RA_2,SIZE_ST(6),FLAGS);
	   action = func(bits<64> &data_) {
		data_ = concat(GPR(RA_2(0)), GPR(RA_2(1)));
 	        if(FLAGS == 1)
	        {
		   cr = CR_status(GPR(RA_2(0)), GPR(RA_2(0)));
	           cr.min = 0;
		}
           };
		
        }

	define(subinstr=st4) 
        {
	   fields = (RA_4,SIZE_ST(7),FLAGS);
	   action = func(bits<64> &data_) {
	   data_ = concat(GPR(RA_4(0))(16,31), GPR(RA_4(1))(16,31), GPR(RA_4(2))(16,31), GPR(RA_4(3))(16,31));	
           if(FLAGS == 1)
	   {
               cr = CR_status(GPR(RA_4(0)), GPR(RA_4(0)));
           }

           };
	}

	define(instr=st)
	{
	  width=32;
		fields=(OPCD(2), reg_store, SML, NUPDATE, RB, DRAM_OFFSET );
		define(subinstrs = reg_store) {
		  subs = (st0,st1,st2,st4);
              	}
	        names = (st_0,st_1,st_2,st_4);
	        syntax =  ("st%p%p%p%p %f,%f(%f)",SIZE_ST(6),NUPDATE,SML,FLAGS,RA(31),DRAM_OFFSET,RB,
		           "st%p%p%p%p %f,%f(%f)",SIZE_ST   ,NUPDATE,SML,FLAGS,RA    ,DRAM_OFFSET,RB,
			   "st%p%p%p%p %f,%f(%f)",SIZE_ST(6),NUPDATE,SML,FLAGS,RA_2  ,DRAM_OFFSET,RB,
		           "st%p%p%p%p %f,%f(%f)",SIZE_ST(7),NUPDATE,SML,FLAGS,RA_4  ,DRAM_OFFSET,RB);
			 
		//dsyntax = ("st.b8%p%p%p GPR31,%f(%f)",     NUPDATE,SML,FLAGS,       DRAM_OFFSET,RB,
		//           "st%p%p%p%p  %f,%f(%f)",SIZE_ST,NUPDATE,SML,FLAGS,RA    ,DRAM_OFFSET,RB,
		//	   "st.b8%p%p%p %f,%f(%f)",        NUPDATE,SML,FLAGS,RA_2  ,DRAM_OFFSET,RB,
		//           "st.q%p%p%p  %f,%f(%f)",        NUPDATE,SML,FLAGS,RA_4  ,DRAM_OFFSET,RB);
		
		action = {		
                    bits<64> data_;
	            reg_store(data_);
		    bits<24> EA_temp = GPR(RB) + signExtend(DRAM_OFFSET,24);
			
		    bits<24> EA = EA_temp;
		   if(SIZE_ST == 1 || SIZE_ST == 5) EA = EA & 0xfffffe;
		   if(SIZE_ST == 2 || SIZE_ST == 6) EA = EA & 0xfffffc;
		   if(SIZE_ST == 3 || SIZE_ST == 7) EA = EA & 0xfffff8;

	//	    if(SIZE_LDST(0,1) == 1) EA = EA & 0xfffffe;
	//	    else if(SIZE_LDST(0,1) == 2) EA = EA & 0xfffffc;
	//	    else if(SIZE_LDST(0,1) == 3) EA = EA & 0xfffff8;
		    bits<3>  addr_lsb = EA(21,23);
		    bits<8>  be;
		    if(SIZE_ST == 0) be = 0x80;
		    else if(SIZE_ST == 1) be = 0x80;
		    else if(SIZE_ST == 2) be = 0xc0;
		    else if(SIZE_ST == 3) be = 0xc0;
		    else if(SIZE_ST == 4) be = 0xf0;
		    else if(SIZE_ST == 5) be = 0x70;
		    else if(SIZE_ST == 6) be = 0xff;
		    else if(SIZE_ST == 7) be = 0xff;
			
		    be = be >> addr_lsb;
				
		    muram_bus_access(0, EA, be, data_, SML);

		  if (NUPDATE == 1) GPR(RB) = merge(GPR(RB), EA_temp, 0xff000000);
	           if(FLAGS == 1)
		   {
		       cr.min = 0;
        	   }

		
           };
	}

	define(subinstr=ldm1) 
        {
	  fields = (SIZE_LD,RA,FLAGS);
	  action = func(bits<64>& data1) {
	  bits<64> data_ = data1;
		// .b1
	   		if(SIZE_LD == 0) GPR(RA) = concat(zero(24), data_(0,7) );
			
			// .b1s
    	   		else if(SIZE_LD == 1) GPR(RA) = signExtend(data_(0,7), 32 );
			
			// .b2
			else if(SIZE_LD == 2) GPR(RA) = concat(zero(16), data_(0,15) );
											
			// .b2s
			else if(SIZE_LD == 3) GPR(RA) = signExtend(data_(0,15), 32 );
											
			// .b4
			else if(SIZE_LD == 4) GPR(RA) = data_(0,31);
											
			// .b3
			else if(SIZE_LD == 5) GPR(RA) = concat(zero(8), data_(8,31));
			if(FLAGS == 1)
			{
			  cr = CR_status(GPR(RA),GPR(RA));
			}	
		data1 = data_;
	    };
        }


	define(subinstr=ldm2) 
        {
	  fields = (SIZE_LD(6),RA_2,FLAGS);
	  action = func(bits<64>& data1) {
	  bits<64> data_ = data1;
	   	   GPR(RA_2(0)) = data_(0 ,31);
 		   GPR(RA_2(1)) = data_(32,63);
	   	   
                    if(FLAGS == 1)
	            {
		      bits<32> tmps = concat(GPR(RA_2(0)), GPR(RA_2(0)));		
	              cr = CR_status(tmps, tmps);
	            }
		   data1 = data_;	
		};
	}

	define(subinstr=ldm4) 
        {
	  fields = (SIZE_LD(7),RA_4,FLAGS);
	  action = func(bits<64>& data1) {
		  bits<64> data_ = data1;	
 		   GPR(RA_4(0)) = concat(zero(16), data_(0 ,15) );
		   GPR(RA_4(1)) = concat(zero(16), data_(16,31) );
		   GPR(RA_4(2)) = concat(zero(16), data_(32,47) );
        	   GPR(RA_4(3)) = concat(zero(16), data_(48,63) );

	           if(FLAGS == 1)
		   {
		      bits<32> tmps = concat(GPR(RA_4(0))(16,31), GPR(RA_4(1))(16,31));		
	              cr = CR_status(tmps, tmps);
	           }
		   data1 = data_;
	     } ;
        } 

    define(instr=ldm)
	{
	  width=32;
		fields=(OPCD(3), OPCD_B8(0), reg_update,NUPDATE, RB, DRAM_OFFSET );
		define(subinstrs=reg_update) {
		   subs = (ldm1,ldm2,ldm4);
		}
		names = (ldm_1,ldm_2m,ldm_4m);
	        syntax =  ("ldm%p%p%p %f,%f(%f)",SIZE_LD   ,NUPDATE,FLAGS,RA    ,DRAM_OFFSET,RB,
			   "ldm%p%p%p %f,%f(%f)",SIZE_LD(6),NUPDATE,FLAGS,RA_2  ,DRAM_OFFSET,RB,
		           "ldm%p%p%p %f,%f(%f)",SIZE_LD(7),NUPDATE,FLAGS,RA_4  ,DRAM_OFFSET,RB);
			 
		//dsyntax = ("ldm%p%p%p  %f,%f(%f)",SIZE_LD,NUPDATE,FLAGS,RA    ,DRAM_OFFSET,RB,
		//	   "ldm.b8%p%p %f,%f(%f)"        ,NUPDATE,FLAGS,RA_2  ,DRAM_OFFSET,RB,
		//           "ldm.q%p%p  %f,%f(%f)"        ,NUPDATE,FLAGS,RA_4  ,DRAM_OFFSET,RB);
		//
		action =
		{
		   bits<64>  data_;
	 	   bits<7>  modulo = GPR(RB)(1,7);
		   bits<7>  addr   = GPR(RB)(22,28);

		   bits<7>  mask   = (modulo(0) == 1) ? 0x7f :
  		 		     (modulo(1) == 1) ? 0x3f :
		   		     (modulo(2) == 1) ? 0x1f :
				     (modulo(3) == 1) ? 0x0f :
				     (modulo(4) == 1) ? 0x07 :
				     (modulo(5) == 1) ? 0x03 :
			             (modulo(6) == 1) ? 0x01 : 0 ;

		   bits<32> wrap    = ((addr & mask) == (modulo & mask)) ? 0x80000000 : 0;

		   bits<24> EA_temp = (wrap == 0) ? GPR(RB) +  signExtend(DRAM_OFFSET,24) 
	        	                  : GPR(RB) & ~concat(zero(14), mask, zero(3)) ;

		   bits<24> EA = EA_temp;
		   if(SIZE_LD == 1 || SIZE_LD == 5) EA = EA & 0xfffffe;
		   if(SIZE_LD == 2 || SIZE_LD == 6) EA = EA & 0xfffffc;
		   if(SIZE_LD == 3 || SIZE_LD == 7) EA = EA & 0xfffff8;
//		   if     (SIZE_LDST(0,1) == 1) EA = EA & 0xfffffe;
//		   else if(SIZE_LDST(0,1) == 2) EA = EA & 0xfffffc;
//		   else if(SIZE_LDST(0,1) == 3) EA = EA & 0xfffff8;

		   if (NUPDATE == 1) GPR(RB) = merge(GPR(RB), EA_temp, 0xff000000) ^ wrap;
			
		   bits<3>  addr_lsb = EA(21,23);

		   bits<8>  be;
		   if     (SIZE_LD == 0) be = 0x80;
		   else if(SIZE_LD == 1) be = 0x80;
		   else if(SIZE_LD == 2) be = 0xc0;
		   else if(SIZE_LD == 3) be = 0xc0;
		   else if(SIZE_LD == 4) be = 0xf0;
		   else if(SIZE_LD == 5) be = 0x70;
		   else if(SIZE_LD == 6) be = 0xff;
		   else if(SIZE_LD == 7) be = 0xff;
			
		   be = be >> addr_lsb;
			
		   bits<64> tmp  = muram_bus_access(1, EA, be, 0, 0);
 
		   bits<6>  bit_shift = concat(EA(21,23), zero(3));

		   data_  = tmp(0,63) << bit_shift;

	           reg_update(data_);

		};
	}

    define(instr=stm)
	{
	  width=32;
		fields=(OPCD(3), OPCD_B8(1), reg_store, NUPDATE, RB, DRAM_OFFSET );
		define(subinstrs=reg_store) {
		  subs = (st0,st1,st2,st4);
              	}
	        names = (stm_0,stm_1,stm_2,stm_4);
	        syntax =  ("stm%p%p%p %f,%f(%f)",SIZE_ST(6),NUPDATE,FLAGS,RA(31),DRAM_OFFSET,RB,
		           "stm%p%p%p %f,%f(%f)",SIZE_ST   ,NUPDATE,FLAGS,RA    ,DRAM_OFFSET,RB,
			   "stm%p%p%p %f,%f(%f)",SIZE_ST(6),NUPDATE,FLAGS,RA_2  ,DRAM_OFFSET,RB,
		           "stm%p%p%p %f,%f(%f)",SIZE_ST(7),NUPDATE,FLAGS,RA_4  ,DRAM_OFFSET,RB);
			 
		//dsyntax = ("stm.b8%p%p GPR31,%f(%f)",     NUPDATE,FLAGS,       DRAM_OFFSET,RB,
		//           "stm%p%p%p  %f,%f(%f)",SIZE_ST,NUPDATE,FLAGS,RA    ,DRAM_OFFSET,RB,
		//	   "stm.b8%p%p %f,%f(%f)",        NUPDATE,FLAGS,RA_2  ,DRAM_OFFSET,RB,
		//           "stm.q%p%p  %f,%f(%f)",        NUPDATE,FLAGS,RA_4  ,DRAM_OFFSET,RB);
		










		action =
		{
	            bits<64> data_;
                    reg_store(data_);

		    bits<7>  modulo = GPR(RB)(1,7);
		    bits<7>  addr   = GPR(RB)(22,28);
		    bits<7>  mask   = (modulo(0) == 1) ? 0x7f :
  		    (modulo(1) == 1) ? 0x3f :
 		    (modulo(2) == 1) ? 0x1f :
		    (modulo(3) == 1) ? 0x0f :
		    (modulo(4) == 1) ? 0x07 :
		    (modulo(5) == 1) ? 0x03 :
		    (modulo(6) == 1) ? 0x01 :
					0 ;
		    bits<32> wrap    = ((addr & mask) == (modulo & mask)) ? 0x80000000 : 0;										

		    bits<24> EA_temp = (wrap == 0) ? GPR(RB) +  signExtend(DRAM_OFFSET,24)       
					 : GPR(RB) & ~concat(zero(14), mask, zero(3)) ;
			
		    bits<24> EA = EA_temp;

		  if(SIZE_ST == 1 || SIZE_ST == 5) EA = EA & 0xfffffe;
		  if(SIZE_ST == 2 || SIZE_ST == 6) EA = EA & 0xfffffc;
		  if(SIZE_ST == 3 || SIZE_ST == 7) EA = EA & 0xfffff8;
			
//		   if     (SIZE_LDST(0,1) == 1) EA = EA & 0xfffffe;
//		   else if(SIZE_LDST(0,1) == 2) EA = EA & 0xfffffc;
//		   else if(SIZE_LDST(0,1) == 3) EA = EA & 0xfffff8;

		   bits<3>  addr_lsb = EA(21,23);

		   bits<8>  be;
			
		   if     (SIZE_ST == 0) be = 0x80;
		   else if(SIZE_ST == 1) be = 0x80;
		   else if(SIZE_ST == 2) be = 0xc0;
		   else if(SIZE_ST == 3) be = 0xc0;
		   else if(SIZE_ST == 4) be = 0xf0;
		   else if(SIZE_ST == 5) be = 0x70;
		   else if(SIZE_ST == 6) be = 0xff;
		   else if(SIZE_ST == 7) be = 0xff;
			
		   be = be >> addr_lsb;

		   muram_bus_access(0, EA, be, data_, 0);


		   if (NUPDATE == 1) GPR(RB) = merge(GPR(RB), EA_temp, 0xff000000) ^ wrap;

		};
	}


    define(instr=pushsch)
	{
	  width=32;
		fields=(OPCD(0x04), AU, OPCD_B6(0), RT1, RT2, RT3, UR, RA(0x1f), RB );
		syntax  = ("%i%p%p%p%p %f",UR,RT1,RT2,RT3,RB,AU(RB!=0x1f));
		action =
		{
			bits<4>	 opcd     = 4;
//			bits<15> spr_addr = concat(OPCD(1,4), AU, OPCD_B6, RT1, RT2, RT3, UR, RA);
			bits<15> spr_addr = concat(opcd, AU, zero(1), RT1, RT2, RT3);
			         spr_addr = concat(spr_addr, UR, ~zero(5));

			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB), zero(32)), rba, sst);
		};
	}
		
    define(instr=pushschi)
	{
	  width=32;
		fields=(OPCD(0x04), AU(1), OPCD_B6(1), RT1, RT2, RT3, UR, RA(0x1f), INSTR_OFFSET );
		syntax  = ("%i%p%p%p%p %f",UR,RT1,RT2,RT3,INSTR_OFFSET,
		INSTR_OFFSET( (INSTR_OFFSET >= cia()) ? (INSTR_OFFSET - cia()) : (~(cia()-INSTR_OFFSET) + 1) ));
		action =
		{
			bits<4>	 opcd     = 4;
//			bits<15> spr_addr = concat(OPCD(1,4), AU, OPCD_B6, RT1, RT2, RT3, UR, RA);
			bits<15> spr_addr = concat(opcd, ~zero(2), RT1, RT2, RT3);
			         spr_addr = concat(spr_addr, UR, ~zero(5));

			var offset = signExtend(INSTR_OFFSET,24);
			
			bits<24> tmp  = PC + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(tmp, zero(32)), rba, sst);
		};
	}

    define(instr=ldsch)
	{
	  width=32;
		fields=(OPCD(0x05), AU, OPCD_B6(0), RT1, RT2, RT3, UR, RA, RB );
		syntax = ("%i%p%p%p%p %f,%f",UR,RT1,RT2,RT3,RA,RB,AU(RB != 0x1F));
		action =
		{
			bits<4>	 opcd     = 5;
//			bits<15> spr_addr = concat(OPCD(1,4), AU, OPCD_B6, RT1, RT2, RT3, UR, RA);
			bits<15> spr_addr = concat(opcd, AU, zero(1), RT1, RT2, RT3);
			         spr_addr = concat(spr_addr, UR, RA);

			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB), zero(23), SNUMR.org_bg, SNUMR.org_snum), rba, sst);

			bits<65> dispatch = dispatch_bus_access();
			
			bits<1>  ack    = dispatch(0);
			bits<8>  snum   = dispatch(1,8);
			bits<24> iaddr  = dispatch(9,32);
			bits<8>  status = dispatch(33,40);
			bits<24> page   = dispatch(41,64);
			
			if(ack == 1)
			{
				NNPC           = iaddr;
				GPR(RA)        = concat(zero(8), page);
				SNUMR          = concat(zero(8), snum, zero(8), snum);
				cr             = concat(cr(0,21), status, cr(30,31));
			}
			else
			{
//				halt();
			}
		};
	}
    define(instr=ldsch_shorthand)
	{
	  width=32;
		fields=(OPCD(0x05), OPCD_B6(0), RT1, RT2, RT3, UR, RA(0x1a),RB );
		alias = ldsch(UR(UR),RT1(RT1),RT2(RT2),RT3(RT3),RB(RB),AU(RB != 0x1F));
		syntax = ("ldsch%p%p%p%p %f",UR,RT1,RT2,RT3,RB);		
    	}
    
    define(instr=ldschi)
	{
	  width=32;
		fields=(OPCD(0x05), AU(1), OPCD_B6(1), RT1, RT2, RT3, UR, RA, INSTR_OFFSET );
		//syntax = ("ldschi%p%p%p%p %f,%f",UR,RT1,RT2,RT3,RA,INSTR_OFFSET,
		//INSTR_OFFSET( (INSTR_OFFSET >= PC) ? (INSTR_OFFSET - PC) : (~(PC-INSTR_OFFSET) + 1) )); 
		action =
		{
			bits<4>	 opcd     = 5;
//			bits<15> spr_addr = concat(OPCD(1,4), AU, OPCD_B6, RT1, RT2, RT3, UR, RA);
			bits<15> spr_addr = concat(opcd, ~zero(2), RT1, RT2, RT3);
			         spr_addr = concat(spr_addr, UR, RA);

			var offset = signExtend(INSTR_OFFSET,24);
			
			bits<24> tmp  = PC + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(tmp, zero(23), SNUMR.org_bg, SNUMR.org_snum), rba, sst);

			bits<65> dispatch = dispatch_bus_access();
			
			bits<1>  ack    = dispatch(0);
			bits<8>  snum   = dispatch(1,8);
			bits<24> iaddr  = dispatch(9,32);
			bits<8>  status = dispatch(33,40);
			bits<24> page   = dispatch(41,64);
			
			if(ack == 1)
			{
				NNPC           = iaddr;
				GPR(RA)        = concat(zero(8), page);
				SNUMR          = concat(zero(8), snum, zero(8), snum);
				cr             = concat(cr(0,21), status, cr(30,31));
			}
			else
			{
//				halt();
			}
			
		};
	}

    
    define(instr=ldschi_shorthand)
	{
	  width=32;	  
		fields= (OPCD(0x05), AU(1), OPCD_B6(1), RT1, RT2, RT3, UR, RA(0x1A), INSTR_OFFSET );
		alias = ldschi(RT1(RT1), RT2(RT2), RT3(RT3), UR(UR), INSTR_OFFSET( (INSTR_OFFSET >= cia()) ? (INSTR_OFFSET - cia()) : (~(cia()-INSTR_OFFSET) + 1) ) );
		syntax = ("ldschi%p%p%p%p %f",UR,RT1,RT2,RT3,INSTR_OFFSET); 
    	}
    
    define(instr=bcrc)
	{
	  width=32;
		fields=(OPCD(0x08), OPCD_BTM(0), CRC, RV, RA, RB, DRAM_OFFSET );
		syntax = ("%i%p%p %f,%f(%f)",CRC,RV,RA,DRAM_OFFSET,RB); 
		action =
		{
			bits<4>	 opcd     = 8;
			bits<3>	 opcd_btm = 0;
//			bits<15> spr_addr = concat(OPCD(1,4), OPCD_BTM, CRC, RV, RA);
			bits<15> spr_addr = concat(opcd,      opcd_btm, CRC, RV, RA);

			var offset = signExtend(DRAM_OFFSET,24);
			
			bits<24> EA  = GPR(RB) + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB)(0,7), EA, GPR(RA)), rba, sst);
		};
	}

    define(instr=bcam)
	{
	  width=32;
		fields=(OPCD(0x08), OPCD_BTM(1), DSIZE, M, RA, RB, DRAM_OFFSET );
		syntax = ("%i%p%p %f,%f(%f)",DSIZE,M, RA, DRAM_OFFSET, RB); 
		action =
		{
			bits<4>	 opcd     = 8;
			bits<3>	 opcd_btm = 1;
//			bits<15> spr_addr = concat(OPCD(1,4), OPCD_BTM, DSIZE, M, RA);
			bits<15> spr_addr = concat(opcd,      opcd_btm, DSIZE, M, RA);

			var offset = signExtend(DRAM_OFFSET,24);
			
			bits<24> EA  = GPR(RB) + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB)(0,7), EA, GPR(RA)), rba, sst);
		};
	}

    define(instr=bmin)
	{
	  width=32;
		fields=(OPCD(0x08), OPCD_BTM(2), DSIZE, OPCD_B10(0), RA, RB, DRAM_OFFSET );
		syntax = ("%i%p %f,%f(%f)",DSIZE,RA,DRAM_OFFSET,RB); 
		action =
		{
			bits<4>	 opcd     = 8;
			bits<3>	 opcd_btm = 2;
			bits<3>	 opcd_b10 = 0;
//			bits<15> spr_addr = concat(OPCD(1,4), OPCD_BTM, DSIZE, OPCD_B10, RA);
			bits<15> spr_addr = concat(opcd,      opcd_btm, DSIZE, opcd_b10, RA);

			var offset = signExtend(DRAM_OFFSET,24);
			
			bits<24> EA  = GPR(RB) + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB)(0,7), EA, GPR(RA)), rba, sst);
		};
	}

    define(instr=bmax)
	{
	  width=32;
		fields=(OPCD(0x08), OPCD_BTM(2), DSIZE, OPCD_B10(1), RA, RB, DRAM_OFFSET );
		syntax = ("%i%p %f,%f(%f)",DSIZE,RA,DRAM_OFFSET,RB); 
		action =
		{
			bits<4>	 opcd     = 8;
			bits<3>	 opcd_btm = 2;
			bits<3>	 opcd_b10 = 1;
//			bits<15> spr_addr = concat(OPCD(1,4), OPCD_BTM, DSIZE, OPCD_B10, RA);
			bits<15> spr_addr = concat(opcd,      opcd_btm, DSIZE, opcd_b10, RA);

			var offset = signExtend(DRAM_OFFSET,24);
			
			bits<24> EA  = GPR(RB) + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB)(0,7), EA, GPR(RA)), rba, sst);
		};
	}

    define(instr=bcopy)
	{
	  width=32;
		fields=(OPCD(0x08), OPCD_BTM(3), CRC, RV, RA, RB, DRAM_OFFSET );
		syntax = ("%i%p%p %f,%f(%f)", CRC,RV,RA,DRAM_OFFSET,RB); 
		action =
		{
			bits<4>	 opcd     = 8;
			bits<3>	 opcd_btm = 3;
//			bits<15> spr_addr = concat(OPCD(1,4), OPCD_BTM, CRC, RV, RA);
			bits<15> spr_addr = concat(opcd,      opcd_btm, CRC, RV, RA);

			var offset = signExtend(DRAM_OFFSET,24);
			
			bits<24> EA  = GPR(RB) + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB)(0,7), EA, GPR(RA)), rba, sst);
		};
	}

    define(instr=bcrci)
	{
	  width=32;
		fields=(OPCD(0x08), OPCD_BTM(4), CRC, RVS, OPCD_B12(0), BUFFER_SIZE, RB, DRAM_OFFSET );
		syntax = ("%i%p%p%p %f(%f)",CRC,RVS,BUFFER_SIZE,DRAM_OFFSET,RB); 
		action =
		{
			bits<4>	 opcd     = 8;
			bits<3>	 opcd_btm = 4;
			bits<3>	 opcd_b12 = 0;
//			bits<15> spr_addr = concat(OPCD(1,4), OPCD_BTM, CRC, RVS, OPCD_B12, BUFFER_SIZE);
			bits<15> spr_addr = concat(opcd,      opcd_btm, CRC, RVS, opcd_b12, BUFFER_SIZE);

			var offset = signExtend(DRAM_OFFSET,24);
			
			bits<24> EA  = GPR(RB) + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB)(0,7), EA, zero(32)), rba, sst);
		};
	}

    define(instr=bcami)
	{
	  width=32;
		fields=(OPCD(0x08), OPCD_BTM(5), DSIZE, M, OPCD_B11(0), OPCD_B12(0), BUFFER_SIZE, RB, DRAM_OFFSET );
		syntax = ("%i%p%p%p %f(%f)",DSIZE,M,BUFFER_SIZE,DRAM_OFFSET, RB); 
		action =
		{
			bits<4>	 opcd     = 8;
			bits<3>	 opcd_btm = 5;
			bits<3>	 opcd_b12 = 0;
//			bits<15> spr_addr = concat(OPCD(1,4), OPCD_BTM, DSIZE, M, OPCD_B11, OPCD_B12, BUFFER_SIZE);
			bits<15> spr_addr = concat(opcd,      opcd_btm, DSIZE, M, zero(2)           , BUFFER_SIZE);

			var offset = signExtend(DRAM_OFFSET,24);
			
			bits<24> EA  = GPR(RB) + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB)(0,7), EA, zero(32)), rba, sst);
		};
	}

    define(instr=bmini)
	{
	  width=32;
		fields=(OPCD(0x08), OPCD_BTM(6), DSIZE, OPCD_B10(0), OPCD_B11(0), OPCD_B12(0), BUFFER_SIZE, RB, DRAM_OFFSET );
		syntax = ("%i%p%p %f(%f)",DSIZE,BUFFER_SIZE,DRAM_OFFSET,RB); 
		action =
		{
			bits<4>	 opcd     = 8;
			bits<3>	 opcd_btm = 6;
			bits<3>	 opcd_b10 = 0;
//			bits<15> spr_addr = concat(OPCD(1,4), OPCD_BTM, DSIZE, OPCD_B10, OPCD_B11, OPCD_B12, BUFFER_SIZE);
			bits<15> spr_addr = concat(opcd,      opcd_btm, DSIZE, opcd_b10, zero(2)           , BUFFER_SIZE);

			var offset = signExtend(DRAM_OFFSET,24);
			
			bits<24> EA  = GPR(RB) + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB)(0,7), EA, zero(32)), rba, sst);
		};
	}
	 
    define(instr=bmaxi)
	{
	  width=32;
		fields=(OPCD(0x08), OPCD_BTM(6), DSIZE, OPCD_B10(1), OPCD_B11(0), OPCD_B12(0), BUFFER_SIZE, RB, DRAM_OFFSET );
		syntax = ("%i%p%p %f(%f)",DSIZE,BUFFER_SIZE,DRAM_OFFSET,RB); 
		action =
		{
			bits<4>	 opcd     = 8;
			bits<3>	 opcd_btm = 6;
			bits<3>	 opcd_b10 = 1;
//			bits<15> spr_addr = concat(OPCD(1,4), OPCD_BTM, DSIZE, OPCD_B10, OPCD_B11, OPCD_B12, BUFFER_SIZE);
			bits<15> spr_addr = concat(opcd,      opcd_btm, DSIZE, opcd_b10, zero(2)           , BUFFER_SIZE);

			var offset = signExtend(DRAM_OFFSET,24);
			
			bits<24> EA  = GPR(RB) + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB)(0,7), EA, zero(32)), rba, sst);
		};
	}

    define(instr=bcopyi)
	{
	  width=32;
		fields=(OPCD(0x08), OPCD_BTM(7), CRC, RVS, DES, BUFFER_SIZE, RB, DRAM_OFFSET );
		syntax = ("%i%p%p%p%p %f(%f)",CRC,RVS,DES,BUFFER_SIZE,DRAM_OFFSET,RB); 
		action =
		{
			bits<4>	 opcd     = 8;
			bits<3>	 opcd_btm = 7;
			bits<3>	 opcd_b12 = 0;
//			bits<15> spr_addr = concat(OPCD(1,4), OPCD_BTM, CRC, RVS, DES, BUFFER_SIZE);
			bits<15> spr_addr = concat(opcd,      opcd_btm, CRC, RVS, DES, BUFFER_SIZE);

			var offset = signExtend(DRAM_OFFSET,24);
			
			bits<24> EA  = GPR(RB) + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB)(0,7), EA, zero(32)), rba, sst);
		};
	}

    define(instr=dmar)
	{
	  width=32;
		fields=(OPCD_SHRT(5), SM, DMA_SIZE, DATA, OPCD_B10(0), RA, RB, DRAM_OFFSET );
		syntax = ("%i%p%p%p %f(%f),%f",SM,DMA_SIZE,DATA,DRAM_OFFSET,RB,RA); 
		action =
		{
			bits<3>	 opcd     = 5;
//			bits<15> spr_addr = concat(OPCD(1,3), SM, DMA_SIZE, DATA, OPCD_B10, RA);
			bits<15> spr_addr = concat(opcd,      SM, DMA_SIZE, DATA, zero(1),  RA);

			var offset = signExtend(DRAM_OFFSET,24);
			
			bits<24> EA  = GPR(RB) + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB)(0,7), EA, GPR(RA)), rba, sst);
		};
	}

    define(instr=dmaw)
	{
	  width=32;
		fields=(OPCD_SHRT(5), SM, DMA_SIZE, DATA, OPCD_B10(1), RA, RB, DRAM_OFFSET );
		syntax = ("%i%p%p%p %f(%f),%f",SM,DMA_SIZE,DATA,DRAM_OFFSET,RB,RA); 

		action =
		{
			bits<3>	 opcd     = 5;
//			bits<15> spr_addr = concat(OPCD(1,3), SM, DMA_SIZE, DATA, OPCD_B10, RA);
			bits<15> spr_addr = concat(opcd,      SM, DMA_SIZE, DATA, ~zero(1), RA);

			var offset = signExtend(DRAM_OFFSET,24);
			
			bits<24> EA  = GPR(RB) + offset;
			
			spr_bus_access(0, spr_addr, 0xff, concat(GPR(RB)(0,7), EA, GPR(RA)), rba, sst);
		};
	}
    define(instr=mtspris_1)
	{
	  width=32;
		fields=(OPCD(0x0c), SIZEB, IMM8S, RB, SPRF_I );
		syntax  = ("mtspris%p %f,%f,%f",SIZEB, RB, IMM8S, SPRF_I,SPRF_I(SPRF_I >> 1));
		action =
		{
			bits<32> imm = concat(zero(24), IMM8S);

			bits<32> maskA = 0x000000ff;
			
			bits<32> maskB = (SIZEB == 0) ? 0x000000ff :
			                 (SIZEB == 1) ? 0x0000ffff :
			                 (SIZEB == 2) ? 0x00ffffff :
			                 (SIZEB == 3) ? 0xffffffff :
			                 (SIZEB == 4) ? 0xff000000 :
			                 (SIZEB == 5) ? 0xffff0000 :
			                 (SIZEB == 6) ? 0xffffff00 :
			                                         0 ;

			bits<8>  be = concat(maskB(0),
								 maskB(8),
								 maskB(16),
								 maskB(24),
								 zero(3),
								 ~zero(1));
			
			SPR(SPRF_I(0))  = merge( imm, SPR(SPRF_I(0)), maskA );
						
		};
	}
    define(instr=mtspris_2)
	{
	  width=32;
		fields=(OPCD(0x14), SIZEB, IMM8S, RB, SPRF );
		syntax = ("mtspris%p %f,%f,%f",SIZEB, RB, IMM8S, SPRF, SPRF(SPRF>>1)); 
		action =
		{
			bits<32> imm = concat(zero(24), IMM8S);

			bits<32> maskA = 0x000000ff;
			
			bits<32> maskB = (SIZEB == 0) ? 0x000000ff :
			                 (SIZEB == 1) ? 0x0000ffff :
			                 (SIZEB == 2) ? 0x00ffffff :
			                 (SIZEB == 3) ? 0xffffffff :
			                 (SIZEB == 4) ? 0xff000000 :
			                 (SIZEB == 5) ? 0xffff0000 :
			                 (SIZEB == 6) ? 0xffffff00 :
			                                         0 ;

			bits<8>  be = concat(maskB(0),
								 maskB(8),
								 maskB(16),
								 maskB(24),
								 zero(3),
								 ~zero(1));
								   
			if(SPRF > 0x7f)
			{
				spr_bus_access(0, SPRF, be, concat(GPR(RB), imm), rba, sst);
			}
		};
	}
	
    define(instr=mtspri_1)
	{
	  width=32;
		fields=(OPCD(0x0d), RS, SBS, IMM8S, RB(0x1F), SPRF );
		syntax = ("mtspri%p %f,%f",SBS,IMM_P2,SPRF,
		                             RS(((SPRF&1) == 0) ? 0 : 1),
					     SPRF(SPRF>>1),
			                     IMM8S( (IMM_P2 <= 0xFF     ) ? IMM_P2 :
					            (IMM_P2 <= 0xFF00   ) ? IMM_P2 >>8 :
						    (IMM_P2 <= 0xFF0000 ) ? IMM_P2 >>16: 
						                       IMM_P2 >>24),
					     SBS( (IMM_P2 == 0 )       ? SBS :
					     	  (IMM_P2 <= 0xFF)     ? 3 :
					          (IMM_P2 <= 0xFF00)   ? 2 :
						  (IMM_P2 <= 0xFF0000) ? 1 : 0)); 
		
		action =
		{
		


			bits<32> mask =  (SBS == 0) ? 0xff000000 :
			                 (SBS == 1) ? 0x00ff0000 :
			                 (SBS == 2) ? 0x0000ff00 :
			                              0x000000ff ;
			
			bits<32> imm = concat(IMM8S, IMM8S, IMM8S, IMM8S);

			bits<4>  be4 = concat(mask(0), mask(8), mask(16), mask(24));
								   
			bits<8>  be  = (RS == 1) ? concat(zero(4), be4) : concat(be4, zero(4));
			if(SPRF > 0x7f)
			{		
				spr_bus_access(0, SPRF, be, concat(imm, imm), rba, sst);
			}
		};
	}
    define(instr=mtspri_2)
	{
	  width=32;
		fields=(OPCD(0x14), RS, SBS, IMM8S, RB(0x1F), SPRF_I );
		syntax = ("mtspri%p %f,%f",SBS,IMM_P2,SPRF_I,
		                             RS(((SPRF_I&1) == 0) ? 0 : 1),
					     SPRF_I(SPRF_I>>1),
			                     IMM8S( (IMM_P2 <= 0xFF     ) ? IMM_P2 :
					            (IMM_P2 <= 0xFF00   ) ? IMM_P2 >>8 :
						    (IMM_P2 <= 0xFF0000 ) ? IMM_P2 >>16: 
						                       IMM_P2 >>24),
					     SBS( (IMM_P2 == 0 )       ? SBS :
					     	  (IMM_P2 <= 0xFF)     ? 3 :
					          (IMM_P2 <= 0xFF00)   ? 2 :
						  (IMM_P2 <= 0xFF0000) ? 1 : 0));  
		
						                       		
	
		
		
		action =
		{
		


			bits<32> mask =  (SBS == 0) ? 0xff000000 :
			                 (SBS == 1) ? 0x00ff0000 :
			                 (SBS == 2) ? 0x0000ff00 :
			                              0x000000ff ;
			
			bits<32> imm = concat(IMM8S, IMM8S, IMM8S, IMM8S);

			bits<4>  be4 = concat(mask(0), mask(8), mask(16), mask(24));
								   
			bits<8>  be  = (RS == 1) ? concat(zero(4), be4) : concat(be4, zero(4));

		
			if(RS == 1) 
			       SPR(SPRF_I(0)) = merge(imm, SPR(SPRF_I(0)), mask );
						

		};
	}
    define(instr=mtspr_1)
	{
	  width=32;
		fields=(OPCD(0x0e), SIZEB, SIZEA, RA, RB, SPRF );
		syntax  = ("mtspr%f%f %f,%f,%f", SIZEB,SIZEA,RB,RA,SPRF,SPRF(SPRF>>1));

		action =
		{
			bits<16> spr_even = concat(zero(4), SPRF,  zero(1));
			bits<16> spr_odd  = concat(zero(4), SPRF, ~zero(1));

			bits<32> maskA = (SIZEA == 0) ? 0x000000ff :
			                 (SIZEA == 1) ? 0x0000ffff :
			                 (SIZEA == 2) ? 0x00ffffff :
			                 (SIZEA == 3) ? 0xffffffff :
			                 (SIZEA == 4) ? 0xff000000 :
			                 (SIZEA == 5) ? 0xffff0000 :
			                 (SIZEA == 6) ? 0xffffff00 :
			                                         0 ;
			
			bits<32> maskB = (SIZEB == 0) ? 0x000000ff :
			                 (SIZEB == 1) ? 0x0000ffff :
			                 (SIZEB == 2) ? 0x00ffffff :
			                 (SIZEB == 3) ? 0xffffffff :
			                 (SIZEB == 4) ? 0xff000000 :
			                 (SIZEB == 5) ? 0xffff0000 :
			                 (SIZEB == 6) ? 0xffffff00 :
			                                         0 ;

			bits<4>  beh = concat(maskB(0),
								  maskB(8),
								  maskB(16),
								  maskB(24));
								 
			bits<4>  bel = concat(maskA(0),
								  maskA(8),
								  maskA(16),
								  maskA(24));
								   
			bits<8>  be = concat(beh, bel);
								   
								   
			if(SPRF > 0x7f)
			{
				spr_bus_access(0, SPRF, be, concat(GPR(RB), GPR(RA)), rba, sst);
			}
		};
	}

    define(instr=mtspr_2)
	{
	  width=32;
		fields=(OPCD(0x11), SIZEB, SIZEA, RA, RB, SPRF_I );
		syntax  = ("mtspr%f%f %f,%f,%f", SIZEB,SIZEA,RB,RA,SPRF_I,SPRF_I(SPRF_I>>1));

		action =
		{
			bits<32> maskA = (SIZEA == 0) ? 0x000000ff :
			                 (SIZEA == 1) ? 0x0000ffff :
			                 (SIZEA == 2) ? 0x00ffffff :
			                 (SIZEA == 3) ? 0xffffffff :
			                 (SIZEA == 4) ? 0xff000000 :
			                 (SIZEA == 5) ? 0xffff0000 :
			                 (SIZEA == 6) ? 0xffffff00 :
			                                         0 ;
			
			bits<32> maskB = (SIZEB == 0) ? 0x000000ff :
			                 (SIZEB == 1) ? 0x0000ffff :
			                 (SIZEB == 2) ? 0x00ffffff :
			                 (SIZEB == 3) ? 0xffffffff :
			                 (SIZEB == 4) ? 0xff000000 :
			                 (SIZEB == 5) ? 0xffff0000 :
			                 (SIZEB == 6) ? 0xffffff00 :
			                                         0 ;

			bits<4>  beh = concat(maskB(0),
								  maskB(8),
								  maskB(16),
								  maskB(24));
								 
			bits<4>  bel = concat(maskA(0),
								  maskA(8),
								  maskA(16),
								  maskA(24));
								   
			bits<8>  be = concat(beh, bel);
								   
			SPR(SPRF_I(0))  = merge( GPR(RA), SPR(SPRF_I(0) ), maskA );
						

		};
	}
   
    define(instr=mfspr_1)
	{
	  width=32;
		fields=(OPCD(0x0f), RS, B8, RA, RB(0x1f), SPRF );
		syntax = ("mfspr%p %f,%f",B8, RA, SPRF, RS((!B8) && ((SPRF&1) == 1)),SPRF(SPRF>>1));
		action =
		{
			bits<64> rdata;

			bits<1>  rsn = ~RS;
			bits<1>  rs_b8 = RS|B8;
			bits<4>  beh = concat(rsn, rsn, rsn, rsn);
			bits<4>  bel = concat(rs_b8, rs_b8, rs_b8, rs_b8);
			bits<8>  be  = concat(beh, bel);
			
			if(SPRF > 0x7f) {
				rdata = spr_bus_access(1, SPRF, be, 0, rba, sst);
			}
			GPR(RA) = (RS == 1) ? rdata(32,63) : rdata(0,31);

			if(B8 == 1) GPR(RA|1) = rdata(32,63);
		};
	}
    define(instr=mfspr_2)
	{
	  width=32;
		fields=(OPCD(0x10), RS, B8, RA, RB(0x1f), SPRF_I );
		syntax = ("mfspr%p %f,%f",B8, RA, SPRF_I, RS((!B8) && ((SPRF_I&1) == 1)),SPRF_I(SPRF_I>>1));
		action =
		{

			bits<64> rdata;

			bits<1>  rsn = ~RS;
			bits<1>  rs_b8 = RS|B8;
			bits<4>  beh = concat(rsn, rsn, rsn, rsn);
			bits<4>  bel = concat(rs_b8, rs_b8, rs_b8, rs_b8);
			bits<8>  be  = concat(beh, bel);			
	
			rdata = concat (zero(32), SPR(SPRF_I(0)) );
			
		  	GPR(RA) = (RS == 1) ? rdata(32,63) : rdata(0,31);

			if(B8 == 1) GPR(RA|1) = rdata(32,63);
		};
	}
    define(instr=push)
	{
	  width=32;
		fields=(OPCD(0x18), HU, OPCD_B6(0), CMPRS, RA, INSTR_OFFSET );
		syntax = ("%i%f %f,%f",HU,INSTR_OFFSET,RA,CMPRS(1-HU),INSTR_OFFSET( (INSTR_OFFSET >= cia()) ? (INSTR_OFFSET - cia()) : (~(cia()-INSTR_OFFSET) + 1) ) );
		action =
		{

			var offset = signExtend(INSTR_OFFSET,24);
			
			bits<24> tmp  = PC + offset;

			if(CMPRS == 1) tmp = concat(tmp(0,7), tmp(0,0), tmp(9,23)); 
			
			GPR(RA) = (HU == 1) ? concat(zero(8), tmp) :
								  merge (GPR(RA), tmp, 0xffff0000);
		};
	}

    define(instr=pushl)
	{
	  width=32;
		fields=(OPCD(0x18), OPCD_B6(1), CMPRS, LONG_OFFSET);
		
		syntax = ("%i%p %f",CMPRS,LONG_OFFSET,
		LONG_OFFSET((LONG_OFFSET >= cia()) ? (LONG_OFFSET - cia()) : (~(cia()-LONG_OFFSET) + 1))); 
		action =
		{

			bits<24> tmp  = PC + LONG_OFFSET;

			if(CMPRS == 1) tmp = concat(tmp(0,7), tmp(0,0), tmp(9,23)); 
			
			sp = concat(zero(8), tmp);
		};
	}

    define(instr=merge)
	{
	  width=32;
		fields=(OPCD(0x19), OPCD_B5(0), ML, RA, RB, RC, MR, OPCD_B31(0) );
		syntax = ("%i %f,%f,%f,%f,%f", RC, RB, RA, ML, MR);				 				 
		action =
		{

			bits<32> mask = mmask(ML, MR);
			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? cr : GPR(RA);
			
			bits<32> tmp  = merge(op1, GPR(RB), mask);

			if(RC == 0x1f) 
			  cr = tmp;
			else  
			  GPR(RC) = tmp;
		};
	}

    define(instr=rland)
	{
	  width=32;
		fields=(OPCD(0x19), OPCD_B5(1), ML, RA, RB, RC, MR, OPCD_B31(0) );
		syntax  = ("%i %f,%f,%f,%f,%f", RC, RA, RB, ML, MR);
						
		action =
		{

			bits<32> mask = mmask(ML, MR);
			
			bits<5>  n    = GPR(RB);
			
			//shift(GPR(RA), cr(0), size, SHIFT_OPTION, DIRECTION);			
			bits<32> tmp  = bit_shift(GPR(RA), 0, n, 3, 1) & mask;

			if(RC == 0x1f) 
			  cr = tmp;
			else  
			  GPR(RC) = tmp;
		};
	}

    define(instr=rlandi)
	{
	  width=32;
		fields=(OPCD(0x19), OPCD_B5(1), ML, RA, IMM5, RC, MR, OPCD_B31(1) );
		syntax  = ("%i %f,%f,%f,%f,%f", RC, RA, IMM5, ML, MR);
		action =
		{

			bits<32> mask = mmask(ML, MR);
			
			//shift(GPR(RA), cr(0), size, SHIFT_OPTION, DIRECTION);			
			bits<32> tmp  = bit_shift(GPR(RA), 0, IMM5, 3, 1) & mask;

			if(RC == 0x1f) 
			  cr = tmp;
			else  
			  GPR(RC) = tmp;
		};
	}

    define(instr=rlmerge)
	{
	  width=32;
		fields=(OPCD(0x1f), INVA, ML, RA, RB, IMM5M, MR, OPCD_B31(0) );
		syntax  = ("%i %f%f,%f,%f,%f,%f", INVA, RB, RA, IMM5M, ML, MR);
		action =
		{

			bits<32> mask = mmask(ML, MR);
			
			//shift(GPR(RA), cr(0), size, SHIFT_OPTION, DIRECTION);			
			bits<32> rot = bit_shift(GPR(RA), 0, IMM5M, 3, 1);

			bits<32> op2 = (INVA == 1) ? ~GPR(RB) : GPR(RB);

			     GPR(RB) = merge(rot, op2, mask);
			
		};
	}

    define(instr=mergei)
	{
	  width=32;
		fields=(OPCD(0x1f), INVA, ML, DATA5, RB, IMM5M, MR, OPCD_B31(1) );
		syntax = ("%i %f%f,%f,%f,%f,%f", INVA, RB, DATA5,IMM5M,ML,MR);
		action =
		{

			bits<32> mask = mmask(ML, MR);
			
			//shift(GPR(RA), cr(0), size, SHIFT_OPTION, DIRECTION);			
			bits<32> rot = bit_shift(DATA5, 0, IMM5M, 3, 1);

			bits<32> op2 = (INVA == 1) ? ~GPR(RB) : GPR(RB);

			     GPR(RB) = merge(rot, op2, mask);
			
		};
	}

    define(instr=andi)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA, OPCD_ALU(2), UPDATE, FLAGS, RA, IMM16);
		syntax = ("%i%p%p %f,%f", UPDATE,FLAGS,RA,IMM_P3,
		                                 HWS( ((IMM_P3 & 0xFFFF0000) == 0) ||
						      ((IMM_P3 & 0xFFFF0000) == 0xFFFF0000) ?
						      1 : 0),
						INVA( ((IMM_P3 & 0xFFFF0000) == 0xFFFF0000) ||
						      ((IMM_P3 & 0xFFFF) == 0xFFFF) ? 1 : 0),
						IMM16( ((IMM_P3 & 0xFFFF0000) == 0) ? IMM_P3 :
						       ((IMM_P3 & 0xFFFF) == 0) ? IMM_P3 >> 16 :
						       ((IMM_P3 & 0xFFFF0000) == 0xFFFF0000) ? ~IMM_P3  :
						                                        ~(IMM_P3 >> 16)));       
	 							   
		action =
		{

			bits<32> op1  = (RA == 0x1f) ? cr : GPR(RA);

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> op2 = (INVA == 1) ? ~imm : imm;   
			
			bits<32> tmp  = op1 & op2;

			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=ori)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA, OPCD_ALU(3), UPDATE, FLAGS, RA, IMM16);
		syntax = ("%i%p%p %f,%f", UPDATE,FLAGS,RA,IMM_P3,
		                                 HWS( ((IMM_P3 & 0xFFFF0000) == 0) ||
						      ((IMM_P3 & 0xFFFF0000) == 0xFFFF0000) ?
						      1 : 0),
						INVA( ((IMM_P3 & 0xFFFF0000) == 0xFFFF0000) ||
						      ((IMM_P3 & 0xFFFF) == 0xFFFF) ? 1 : 0),
						IMM16( ((IMM_P3 & 0xFFFF0000) == 0) ? IMM_P3 :
						       ((IMM_P3 & 0xFFFF) == 0) ? IMM_P3 >> 16 :
						       ((IMM_P3 & 0xFFFF0000) == 0xFFFF0000) ? ~IMM_P3  :
						                                        ~(IMM_P3 >> 16)));       
	 action =
		{

			bits<32> op1 = (RA == 0x1f) ? cr : GPR(RA);
			
			bits<32> imm = imm16e(IMM16, HWS);
			
			bits<32> op2 = (INVA == 1) ? ~imm : imm;   

			bits<32> tmp = op1 | op2;
			
			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=xori)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA, OPCD_ALU(4), UPDATE, FLAGS, RA, IMM16);
		syntax = ("%i%p%p %f,%f", UPDATE,FLAGS,RA,IMM_P3,
		                                 HWS( ((IMM_P3 & 0xFFFF0000) == 0) ||
						      ((IMM_P3 & 0xFFFF0000) == 0xFFFF0000) ?
						      1 : 0),
						INVA( ((IMM_P3 & 0xFFFF0000) == 0xFFFF0000) ||
						      ((IMM_P3 & 0xFFFF) == 0xFFFF) ? 1 : 0),
						IMM16( ((IMM_P3 & 0xFFFF0000) == 0) ? IMM_P3 :
						       ((IMM_P3 & 0xFFFF) == 0) ? IMM_P3 >> 16 :
						       ((IMM_P3 & 0xFFFF0000) == 0xFFFF0000) ? ~IMM_P3  :
						                                        ~(IMM_P3 >> 16)));       
	 	action =
		{

			bits<32> op1  = (RA == 0x1f) ? cr : GPR(RA);

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> op2 = (INVA == 1) ? ~imm : imm;   
			
			bits<32> tmp  = op1 ^ op2;

			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=movei)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA, OPCD_ALU(7), UPDATE, FLAGS, RA, IMM16);
		syntax = ("%i%p%p %f,%f", UPDATE,FLAGS,RA,IMM_P3,
		                                 HWS( ((IMM_P3 & 0xFFFF0000) == 0) ||
						      ((IMM_P3 & 0xFFFF0000) == 0xFFFF0000) ?
						      1 : 0),
						INVA( ((IMM_P3 & 0xFFFF0000) == 0xFFFF0000) ||
						      ((IMM_P3 & 0xFFFF) == 0xFFFF) ? 1 : 0),
						IMM16( ((IMM_P3 & 0xFFFF0000) == 0) ? IMM_P3 :
						       ((IMM_P3 & 0xFFFF) == 0) ? IMM_P3 >> 16 :
						       ((IMM_P3 & 0xFFFF0000) == 0xFFFF0000) ? ~IMM_P3  :
						                                        ~(IMM_P3 >> 16)));       
	 	
		action =
		{

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> tmp = (INVA == 1) ? ~imm : imm;   
			
			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=addi)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA(0), OPCD_ALU(0), UPDATE, FLAGS, RA, IMM16);
		syntax = ("%i%p%p %f,%f", UPDATE, FLAGS, RA, IMM_P1, 
		                        HWS( IMM_P1 > 0xFFFF ? 0 : 1),
		                        IMM16( IMM_P1 > 0xFFFF ? IMM_P1 >> 16 : IMM_P1));
		
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> op2 = imm;   
			
			bits<32> tmp  = op1 + op2;

			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			  cr = CR_add_status(op1, op2, 0);
			}
		};
	}

  define(instr=subi)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA(1), OPCD_ALU(0), UPDATE, FLAGS, RA, IMM16);
		syntax = ("%i%p%p %f,%f", UPDATE, FLAGS, RA, IMM_P1, 
		                        HWS( IMM_P1 > 0xFFFF ? 0 : 1),
		                        IMM16( IMM_P1 > 0xFFFF ? IMM_P1 >> 16 : IMM_P1));
		
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> op2 = ~imm;   
			
			bits<32> tmp  = op1 + op2 + 1;

			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			  cr = CR_sub_status(op1, op2, 1);
			}
		};
	}

    define(instr=addci)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA(0), OPCD_ALU(1), UPDATE, FLAGS, RA, IMM16);
		syntax = ("%i%p%p %f,%f", UPDATE,FLAGS,RA,IMM_P1,		                                           
		                        HWS( IMM_P1 > 0xFFFF ? 0 : 1),
		                        IMM16( IMM_P1 > 0xFFFF ? IMM_P1 >> 16 : IMM_P1));

		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> op2 = imm;   
			
			bits<32> tmp  = op1 + op2 + cr.carry;

			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = cr.carry;
			  cr = CR_status(tmp, tmp);
			  cr = CR_add_status(op1, op2, Cin);
			}
		};
	}

    define(instr=subci)
	{
	  width=32;
		fields=(OPCD_SHRT(0xe), HWS, INVA(1), OPCD_ALU(1), UPDATE, FLAGS, RA, IMM16);
		syntax = ("%i%p%p %f,%f", UPDATE,FLAGS,RA,IMM_P1,		                                           
		                        HWS( IMM_P1 > 0xFFFF ? 0 : 1),
		                        IMM16( IMM_P1 > 0xFFFF ? IMM_P1 >> 16 : IMM_P1));
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm16e(IMM16, HWS);

			bits<32> op2 = ~imm;   
			
			bits<32> tmp  = op1 + op2 + ~cr.carry;

			if(UPDATE == 1)
			{
				if(RA == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RA) = tmp;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = ~cr.carry;
			  cr = CR_status(tmp, tmp);
			  cr = CR_sub_status(op1, op2, Cin);
			}
		};
	}

    define(instr=andis)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA, OPCD_ALU(2), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
		syntax = ("%i%p%p %f,%f,%f",UPDATE,FLAGS,RB,RA,IMM_P4,
	        INVA( ((IMM_P4 & 0xFFFFFF00)) == 0 ||		        
		               ((IMM_P4 & 0xFFFF00FF)) == 0 ||		
		               ((IMM_P4 & 0xFF00FFFF)) == 0 ||
			       ((IMM_P4 & 0x00FFFFFF)) == 0 ? 0 : 1),
		BS( ((IMM_P4 & 0xFFFFFF00) == 0) ||((IMM_P4 & 0xFFFFFF00) == 0xFFFFFF00) ? 3 :
		    ((IMM_P4 & 0xFFFF00FF) == 0) ||((IMM_P4 & 0xFFFF00FF) == 0xFFFF00FF) ? 2 :
		    ((IMM_P4 & 0xFF00FFFF) == 0) ||((IMM_P4 & 0xFF00FFFF) == 0xFF00FFFF) ? 1 : 0 ),
		IMM8(((IMM_P4 & 0xFFFFFF00) == 0) ? IMM_P4 :
		     ((IMM_P4 & 0xFFFF00FF) == 0) ? IMM_P4 >>  8 :
		     ((IMM_P4 & 0xFF00FFFF) == 0) ? IMM_P4 >> 16 :
		     ((IMM_P4 & 0x00FFFFFF) == 0) ? IMM_P4 >> 24 :
		     ((IMM_P4 & 0xFFFFFF00) == 0xFFFFFF00) ? ~ IMM_P4 : 
		     ((IMM_P4 & 0xFFFF00FF) == 0xFFFF00FF) ? ~(IMM_P4 >>  8) : 
		     ((IMM_P4 & 0xFF00FFFF) == 0xFF00FFFF) ? ~(IMM_P4 >> 16) : ~(IMM_P4 >> 24)));
		     
		                 
		    
		 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = (INVA == 1) ? ~imm : imm;   
			
			bits<32> tmp  = op1 & op2;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=oris)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA, OPCD_ALU(3), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
		syntax = ("%i%p%p %f,%f,%f",UPDATE,FLAGS,RB,RA,IMM_P4,
	        INVA( ((IMM_P4 & 0xFFFFFF00)) == 0 ||		        
		               ((IMM_P4 & 0xFFFF00FF)) == 0 ||		
		               ((IMM_P4 & 0xFF00FFFF)) == 0 ||
			       ((IMM_P4 & 0x00FFFFFF)) == 0 ? 0 : 1),
		BS( ((IMM_P4 & 0xFFFFFF00) == 0) ||((IMM_P4 & 0xFFFFFF00) == 0xFFFFFF00) ? 3 :
		    ((IMM_P4 & 0xFFFF00FF) == 0) ||((IMM_P4 & 0xFFFF00FF) == 0xFFFF00FF) ? 2 :
		    ((IMM_P4 & 0xFF00FFFF) == 0) ||((IMM_P4 & 0xFF00FFFF) == 0xFF00FFFF) ? 1 : 0 ),
		IMM8(((IMM_P4 & 0xFFFFFF00) == 0) ? IMM_P4 :
		     ((IMM_P4 & 0xFFFF00FF) == 0) ? IMM_P4 >>  8 :
		     ((IMM_P4 & 0xFF00FFFF) == 0) ? IMM_P4 >> 16 :
		     ((IMM_P4 & 0x00FFFFFF) == 0) ? IMM_P4 >> 24 :
		     ((IMM_P4 & 0xFFFFFF00) == 0xFFFFFF00) ? ~ IMM_P4 : 
		     ((IMM_P4 & 0xFFFF00FF) == 0xFFFF00FF) ? ~(IMM_P4 >>  8) : 
		     ((IMM_P4 & 0xFF00FFFF) == 0xFF00FFFF) ? ~(IMM_P4 >> 16) : ~(IMM_P4 >> 24)));
		     
		
		
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = (INVA == 1) ? ~imm : imm;   
			
			bits<32> tmp  = op1 | op2;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=xoris)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA, OPCD_ALU(4), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
		syntax = ("%i%p%p %f,%f,%f",UPDATE,FLAGS,RB,RA,IMM_P4,
	        INVA( ((IMM_P4 & 0xFFFFFF00)) == 0 ||		        
		               ((IMM_P4 & 0xFFFF00FF)) == 0 ||		
		               ((IMM_P4 & 0xFF00FFFF)) == 0 ||
			       ((IMM_P4 & 0x00FFFFFF)) == 0 ? 0 : 1),
		BS( ((IMM_P4 & 0xFFFFFF00) == 0) ||((IMM_P4 & 0xFFFFFF00) == 0xFFFFFF00) ? 3 :
		    ((IMM_P4 & 0xFFFF00FF) == 0) ||((IMM_P4 & 0xFFFF00FF) == 0xFFFF00FF) ? 2 :
		    ((IMM_P4 & 0xFF00FFFF) == 0) ||((IMM_P4 & 0xFF00FFFF) == 0xFF00FFFF) ? 1 : 0 ),
		IMM8(((IMM_P4 & 0xFFFFFF00) == 0) ? IMM_P4 :
		     ((IMM_P4 & 0xFFFF00FF) == 0) ? IMM_P4 >>  8 :
		     ((IMM_P4 & 0xFF00FFFF) == 0) ? IMM_P4 >> 16 :
		     ((IMM_P4 & 0xFF00FFFF) == 0) ? IMM_P4 >> 24 :
		     ((IMM_P4 & 0xFFFFFF00) == 0xFFFFFF00) ? ~ IMM_P4 : 
		     ((IMM_P4 & 0xFFFF00FF) == 0xFFFF00FF) ? ~(IMM_P4 >>  8) : 
		     ((IMM_P4 & 0xFF00FFFF) == 0xFF00FFFF) ? ~(IMM_P4 >> 16) : ~(IMM_P4 >> 24)));
		     
		
		action = 
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = (INVA == 1) ? ~imm : imm;   

			bits<32> tmp  = op1 ^ op2;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=addis)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA(0), OPCD_ALU(0), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
		syntax = ("%i%p%p %f,%f,%f",UPDATE,FLAGS,RB,RA,IMM_P2,
		                              BS( IMM_P2 <= 0xFF     ? 3 :
					          IMM_P2 <= 0xFF00   ? 2 :
						  IMM_P2 <= 0xFF0000 ? 1 : 0),
				            IMM8( IMM_P2 <= 0xFF     ? IMM_P2 :
					          IMM_P2 <= 0xFF00   ? IMM_P2 >>8 :
						  IMM_P2 <= 0xFF0000 ? IMM_P2 >>16: 
						                       IMM_P2 >>24)); 
          					                       								       
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = imm;   

			bits<32> tmp  = op1 + op2;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			  cr = CR_add_status(op1, op2, 0);
			}
		};
	}

    define(instr=subis)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA(1), OPCD_ALU(0), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
		syntax = ("%i%p%p %f,%f,%f",UPDATE,FLAGS,RB,RA,IMM_P2,
		                              BS( IMM_P2 <= 0xFF     ? 3 :
					          IMM_P2 <= 0xFF00   ? 2 :
						  IMM_P2 <= 0xFF0000 ? 1 : 0),
				            IMM8( IMM_P2 <= 0xFF     ? IMM_P2 :
					          IMM_P2 <= 0xFF00   ? IMM_P2 >>8 :
						  IMM_P2 <= 0xFF0000 ? IMM_P2 >>16: 
						                       IMM_P2 >>24)); 
           					                       								       
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = ~imm;   

			bits<32> tmp  = op1 + op2 + 1;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			  cr = CR_sub_status(op1, op2, 1);
			}
		};
	}

    define(instr=addcis)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA(0), OPCD_ALU(1), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
		syntax = ("%i%p%p %f,%f,%f", UPDATE, FLAGS, RB, RA, IMM_P2, 			     
				BS(   IMM_P2 <=     0xFF ? 3 :
				      IMM_P2 <=   0xFF00 ? 2 :
				      IMM_P2 <= 0xFF0000 ? 1 : 
		                        		   0),		      
				IMM8( IMM_P2 <=     0xFF ? IMM_P2       :
				      IMM_P2 <=   0xFF00 ? IMM_P2 >>  8 :
				      IMM_P2 <= 0xFF0000 ? IMM_P2 >> 16 : 
		                        		   IMM_P2 >> 24));				     
	action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = imm;   

			bits<32> tmp  = op1 + op2 + cr.carry;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = cr.carry;
			  cr = CR_status(tmp, tmp);
			  cr = CR_add_status(op1, op2, Cin);
			}
		};
	}

    define(instr=subcis)
	{
	  width=32;
		fields=(OPCD(0x1e), INVA(1), OPCD_ALU(1), UPDATE, FLAGS, RA, RB, RSV_B21(0), BS, IMM8);
		syntax = ("%i%p%p %f,%f,%f", UPDATE, FLAGS, RB, RA, IMM_P2, 			     
				BS(   IMM_P2 <=     0xFF ? 3 :
				      IMM_P2 <=   0xFF00 ? 2 :
				      IMM_P2 <= 0xFF0000 ? 1 : 
		                        		   0),		      
				IMM8( IMM_P2 <=     0xFF ? IMM_P2       :
				      IMM_P2 <=   0xFF00 ? IMM_P2 >>  8 :
				      IMM_P2 <= 0xFF0000 ? IMM_P2 >> 16 : 
		                        		   IMM_P2 >> 24));				     
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> imm = imm8e(IMM8, BS);

			bits<32> op2 = ~imm;   

			bits<32> tmp  = op1 + op2 + ~cr.carry;

			if(UPDATE == 1)
			{
			  GPR(RB) = tmp;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = ~cr.carry;
			  cr = CR_status(tmp, tmp);
			  cr = CR_sub_status(op1, op2, Cin);
			}
		};
	}

    define(instr=add)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA(0), OPCD_ALU(0), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), ONE);
		syntax = ("%i%p%p%p%p %f,%f,%f",SWAP_TYPE, UPDATE, FLAGS, ONE,  RC, RA, RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2 = GPR(RB);   

			bits<32> tmp  = op1 + op2 + ONE;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 
			
			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp_s, tmp);
			  cr = CR_add_status(op1, op2, ONE);
			}
		};
	}

    define(instr=sub)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA(1), OPCD_ALU(0), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), ONE);
		syntax = ("%i%p%p%p%p %f,%f,%f",SWAP_TYPE, UPDATE, FLAGS, ONE,  RC, RA, RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2 = ~GPR(RB);   

			bits<32> tmp  = op1 + op2 + ~ONE;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp_s, tmp);
			  cr = CR_sub_status(op1, op2, ~ONE);
			}
		};
	}

    define(instr=addc)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA(0), OPCD_ALU(1), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), RSV_B31(0));
		syntax = ("%i%p%p%p %f,%f,%f",SWAP_TYPE,UPDATE,FLAGS,RC,RA,RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2 = GPR(RB);   

			bits<32> tmp  = op1 + op2 + cr.carry;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = cr.carry;
			  cr = CR_status(tmp_s, tmp);
			  cr = CR_add_status(op1, op2, Cin);
			}
		};
	}

    define(instr=subc)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA(1), OPCD_ALU(1), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), RSV_B31(0));
		syntax = ("%i%p%p%p %f,%f,%f",SWAP_TYPE,UPDATE,FLAGS,RC,RA,RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2 = ~GPR(RB);   

			bits<32> tmp  = op1 + op2 + ~cr.carry;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			bits<32> Cin;
			if(FLAGS == 1)
			{
		      bits<32> Cin = ~cr.carry;
			  
			  cr = CR_status(tmp_s, tmp);
			  cr = CR_sub_status(op1, op2, Cin);
			}
		};
	}

    define(instr=and)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA, OPCD_ALU(2), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), RSV_B31(0));
		syntax = ("%i%p%p%p %f,%f,%f%f",SWAP_TYPE,UPDATE,FLAGS,RC,RA,INVA,RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? cr : GPR(RA);

			bits<32> op2 = (INVA == 1) ? ~GPR(RB) : GPR(RB);   

			bits<32> tmp  = op1 & op2;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp_s, tmp);
			}
		};
	}

    define(instr=or)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA, OPCD_ALU(3), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), RSV_B31(0));
		syntax = ("%i%p%p%p %f,%f,%f%f",UPDATE,FLAGS,SWAP_TYPE,RC,RA,INVA,RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? cr : GPR(RA);

			bits<32> op2 = (INVA == 1) ? ~GPR(RB) : GPR(RB);   

			bits<32> tmp  = op1 | op2;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp_s, tmp);
			}
		};
	}

    define(instr=xor)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA, OPCD_ALU(4), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE, RSV_B29(0), RSV_B30(0), RSV_B31(0));
		syntax = ("%i%p%p%p %f,%f,%f%f",UPDATE,FLAGS,SWAP_TYPE,RC,RA,INVA,RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? cr : GPR(RA);

			bits<32> op2 = (INVA == 1) ? ~GPR(RB) : GPR(RB);   

			bits<32> tmp  = op1 ^ op2;

			bits<32> tmp_s = swap(tmp, SWAP_TYPE); 

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp_s;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp_s, tmp);
			}
		};
	}

    define(instr=bset)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA, OPCD_ALU(5), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE(7), RSV_B29(0), RSV_B30(0), OPCD_B31(0));
		syntax = ("%i%p%p %f,%f,%f%f",UPDATE,FLAGS,RC,RA,INVA,RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? cr : GPR(RA);

			bits<5>  op2 = (INVA == 1) ? ~GPR(RB) : GPR(RB);  

			bits<32> mask = 1;
					 mask = mask << op2;

			bits<32> tmp  = op1 | mask;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=bclr)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA, OPCD_ALU(6), UPDATE, FLAGS, RA, RB, RC, SWAP_TYPE(7), RSV_B29(0), RSV_B30(0), OPCD_B31(0));
		syntax = ("%i%p%p %f,%f,%f%f", UPDATE, FLAGS, RC,RA,INVA,RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? cr : GPR(RA);

			bits<5>  op2 = (INVA == 1) ? ~GPR(RB) : GPR(RB);  

			bits<32> mask = 1;
					 mask = mask << op2;

			bits<32> tmp  = op1 & ~mask;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=cnt)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA, OPCD_ALU(5), UPDATE, FLAGS, RA(0x1f), RB, RC, DS_ALU, RSV_B30(0), OPCD_B31(1));
		syntax = ("%i%p%p%p %f,%f%f",UPDATE,FLAGS,DS_ALU,RC,INVA,RB); 
		action =
		{

			bits<32> mask = 0;

			if(DS_ALU(0) == 1) mask = mask | 0xff000000;
			if(DS_ALU(1) == 1) mask = mask | 0x00ff0000;
			if(DS_ALU(2) == 1) mask = mask | 0x0000ff00;
			if(DS_ALU(3) == 1) mask = mask | 0x000000ff;

			bits<32> op2 = (INVA == 1) ? ~GPR(RB) : GPR(RB);  
			         op2 = op2 & mask;

			bits<16> d16 = op2(0,15) | op2(16,31);

			bits<32> tmp = 0;

			bits<32> i = 0;

			for(i=0;i<16; i=i+1)
			{
			  tmp = tmp + d16(0);
			  d16 = concat(d16(1,15),zero(1));
			}  

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}

    define(instr=ffs)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA, OPCD_ALU(6), UPDATE, FLAGS, RA(0x1f), RB, RC, DS_ALU, RSV_B30(0), OPCD_B31(1));
		syntax = ("%i%p%p%p %f,%f%f",UPDATE,FLAGS,DS_ALU,RC,INVA,RB); 
		action =
		{

			bits<32> mask = 0;

			if(DS_ALU(0) == 1) mask = mask | 0xff000000;
			if(DS_ALU(1) == 1) mask = mask | 0x00ff0000;
			if(DS_ALU(2) == 1) mask = mask | 0x0000ff00;
			if(DS_ALU(3) == 1) mask = mask | 0x000000ff;

			bits<32> op2 = (INVA == 1) ? ~GPR(RB) : GPR(RB);  
			         op2 = op2 & mask;

			bits<32> tmp = 32;

			bits<32> i = 0;

			for(i=0;i<32; i=i+1)
			{
			  if(op2(i) == 1)
			  {
			    tmp = i;
			    break;
			  }	
			}  

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			  cr.carry = tmp(26);
			}
		};
	}

    define(instr=shift_)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA, OPCD_ALU(7), UPDATE, FLAGS, RA, RB, RC, DIRECTION, SHIFT_OPTION, RSV_B30(0), OPCD_B31(0));
		syntax = ("shift%p%p%p%p %f,%f,%f%f",DIRECTION,SHIFT_OPTION,UPDATE,FLAGS,RC,RA,INVA,RB); 
		action =
		{

			bits<32> op2  = (INVA == 1) ? ~GPR(RB) : GPR(RB);  

			bits<5>  size_ = (op2 & 0x1f);
			
			bits<33> tmp = bit_shift(GPR(RA), cr.carry, size_, SHIFT_OPTION, DIRECTION);

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp(1,32);
				else  
				  GPR(RC) = tmp(1,32);
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp(1,32), tmp(1,32));
			  cr.carry = tmp(0);
			}
		};
	}

    define(instr=shifti)
	{
	  width=32;
		fields=(OPCD(0x1b), INVA(0), OPCD_ALU(7), UPDATE, FLAGS, RA, IMM5, RC, DIRECTION, SHIFT_OPTION, RSV_B30(0), OPCD_B31(1));
		syntax = ("%i%p%p%p%p %f,%f,%f",DIRECTION,SHIFT_OPTION,UPDATE,FLAGS,RC,RA,IMM5); 
		action =
		{
			bits<33> tmp = bit_shift(GPR(RA), cr.carry, IMM5, SHIFT_OPTION, DIRECTION);

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp(1,32);
				else  
				  GPR(RC) = tmp(1,32);
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp(1,32), tmp(1,32));
			  cr.carry =tmp(0);
			}
		};
	}

    define(instr=cadd)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA(0), OPCD_ALU(0), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
		syntax = ("add%p%p %f%f,%f,%f,%f",UPDATE, FLAGS, NOTAC, CFA, RC, RA, RB);
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2  = GPR(RB);  

			bits<1> cond  = NOTAC ^ cr(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 + op2 : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			  
			  if(cond == 1)
			     cr = CR_add_status(op1, op2, 0);
			}
		};
	}
	
    define(instr=csub)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA(1), OPCD_ALU(0), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
		syntax = ("sub%p%p %f%f,%f,%f,%f",UPDATE, FLAGS, NOTAC, CFA, RC, RA, RB);
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2  = ~GPR(RB);  

			bits<1> cond  = NOTAC ^ cr(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 + op2 + 1 : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			  
			  if(cond == 1)
			     cr = CR_sub_status(op1, op2, 1);
			}
		};
	}
	
    define(instr=caddc)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA(0), OPCD_ALU(1), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
		syntax = ("addc%p%p %f%f,%f,%f,%f",UPDATE,FLAGS,NOTAC,CFA,RC,RA,RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2  = GPR(RB);  

			bits<1> cond  = NOTAC ^ cr(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? (op1 + op2 + cr.carry) : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = cr.carry;
			  cr = CR_status(tmp, tmp);
			  
			  if(cond == 1)
			     cr = CR_add_status(op1, op2, Cin);
			}
		};
	}
	
    define(instr=csubc)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA(1), OPCD_ALU(1), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
		syntax = ("subc%p%p %f%f,%f,%f,%f",UPDATE,FLAGS,NOTAC,CFA,RC,RA,RB); 
		action =
		{

			bits<32> op1  = GPR(RA);

			bits<32> op2  = ~GPR(RB);  

			bits<1> cond  = NOTAC ^ cr(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 + op2 + ~cr.carry : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
		      bits<32> Cin = ~cr.carry;
			  cr = CR_status(tmp, tmp);
			  
			  if(cond == 1)
			     cr = CR_sub_status(op1, op2, Cin);
			}
		};
	}
	
    define(instr=cand)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA, OPCD_ALU(2), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
		syntax = ("and%p%p %f%f,%f,%f,%f%f",UPDATE,FLAGS,NOTAC,CFA,RC,RA,INVA,RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? cr : GPR(RA);

			bits<32> op2  = (INVA == 1) ? ~GPR(RB) : GPR(RB);  

			bits<1> cond  = NOTAC ^ cr(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 & op2 : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}
	
    define(instr=cor)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA, OPCD_ALU(3), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
		syntax = ("or%p%p %f%f,%f,%f,%f%f",UPDATE, FLAGS, NOTAC, CFA, RC, RA,INVA,RB);
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? cr : GPR(RA);

			bits<32> op2  = (INVA == 1) ? ~GPR(RB) : GPR(RB);  

			bits<1> cond  = NOTAC ^ cr(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 | op2 : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}
	
    define(instr=cxor)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA, OPCD_ALU(4), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
		syntax = ("xor%p%p %f%f,%f,%f,%f%f",UPDATE, FLAGS, NOTAC, CFA, RC, RA,INVA,RB);
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? cr : GPR(RA);

			bits<32> op2  = (INVA == 1) ? ~GPR(RB) : GPR(RB);  

			bits<1> cond  = NOTAC ^ cr(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 ^ op2 : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}
	
    define(instr=cbset)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA(0), OPCD_ALU(5), UPDATE, FLAGS, RA, IMM5, RC, CFA, NOTAC);
		syntax = ("bset%p%p %f%f,%f,%f,%f",UPDATE, FLAGS, NOTAC, CFA, RC, RA,IMM5);
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? cr : GPR(RA);

			bits<32> op2  = 1;  
                     op2 = op2 << IMM5;

			bits<1> cond  = NOTAC ^ cr(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 | op2 : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}
	
    define(instr=cbclr)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA(0), OPCD_ALU(6), UPDATE, FLAGS, RA, IMM5, RC, CFA, NOTAC);
		syntax = ("bclr%p%p %f%f,%f,%f,%f", UPDATE, FLAGS, NOTAC, CFA,RC,RA,IMM5); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? cr : GPR(RA);

			bits<32> mask = 1;
					 mask = mask << IMM5;

			bits<1> cond  = NOTAC ^ cr(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op1 & ~mask : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}
	
    define(instr=select)
	{
	  width=32;
		fields=(OPCD(0x1a), INVA, OPCD_ALU(7), UPDATE, FLAGS, RA, RB, RC, CFA, NOTAC);
		syntax = ("%i%p%p %f%f,%f,%f,%f%f",UPDATE,FLAGS,NOTAC,CFA,RC,RA,INVA,RB); 
		action =
		{

			bits<32> op1  = ((RA == 0x1f) && (RC == 0x1f)) ? cr : GPR(RA);

			bits<32> op2  = (INVA == 1) ? ~GPR(RB) : GPR(RB);  

			bits<1> cond  = NOTAC ^ cr(CFA,CFA);

			bits<32> tmp  = (cond == 1) ? op2 : op1;

			if(UPDATE == 1)
			{
				if(RC == 0x1f) 
				  cr = tmp;
				else  
				  GPR(RC) = tmp;
			}  
			
			if(FLAGS == 1)
			{
			  cr = CR_status(tmp, tmp);
			}
		};
	}
	
	define(instr=loop)
	{
	  width=32;
		fields=(OPCD(0x12), NOP_J, OPCD_B6(0), OPCD_B7(0), RA, RB, CMPRS_J);
		syntax = ("%i%p%p (%f)-,%f",NOP_J,CMPRS_J,RA,RB);
		action =
		{
			bits<24> tmp  = GPR(RB);

			if(CMPRS_J == 1) 
			   tmp = concat(tmp(8), zero(8), tmp(9,23));

			if(GPR(RA) != 0)
			{
			  NNPC = tmp;

              if(NOP_J == 1) 
			     Fetch = JmpN;
			}	 

			GPR(RA) = GPR(RA) - 1;
		};
	}

	define(instr=loopi)
	{
	  width=32;
		fields=(OPCD(0x12), NOP_J, OPCD_B6(1), OPCD_B7(0), RA, INSTR_OFFSET);
		syntax = ("%i%f (%f)-,%f",NOP_J,RA,INSTR_OFFSET,
		INSTR_OFFSET( (INSTR_OFFSET >= cia()) ? (INSTR_OFFSET - cia()) : (~(cia()-INSTR_OFFSET) + 1) ) );

		action =
		{
			var offset = signExtend(INSTR_OFFSET,24);

			if(GPR(RA) != 0)
			{
			  NNPC = PC + offset;

              if(NOP_J == 1) 
			     Fetch = JmpN;
			}

			GPR(RA) = GPR(RA) - 1;
		};
	}

	define(instr=cases)
	{
	  width=32;
		fields=(OPCD(0x12), NOP_J, OPCD_B6(1), OPCD_B7(1), CASE_SIZE, RA, INSTR_OFFSET);
		syntax = ("case%p%p %f,%f",NOP_J,CASE_SIZE,INSTR_OFFSET,RA,
		INSTR_OFFSET( (INSTR_OFFSET >= cia()) ? (INSTR_OFFSET - cia()) : (~(cia()-INSTR_OFFSET) + 1) ) );
		action =
		{
			var offset = signExtend(INSTR_OFFSET,24);

//			var op1 = (CASE_SIZE == 0) ? GPR(RA)(31) :
//			          (CASE_SIZE == 1) ? GPR(RA)(30,31) :
//			          (CASE_SIZE == 2) ? GPR(RA)(29,31) :
//			          (CASE_SIZE == 3) ? GPR(RA)(28,31) :
//			          (CASE_SIZE == 4) ? GPR(RA)(27,31) :
//			          (CASE_SIZE == 5) ? GPR(RA)(26,31) :
//			          (CASE_SIZE == 6) ? GPR(RA)(25,31) :
//			                             GPR(RA)(24,31) ;

			var op1 = (CASE_SIZE == 0) ? concat(zero(8), GPR(RA)(31)) :
			          (CASE_SIZE == 1) ? concat(zero(7), GPR(RA)(30,31)) :
			          (CASE_SIZE == 2) ? concat(zero(6), GPR(RA)(29,31)) :
			          (CASE_SIZE == 3) ? concat(zero(5), GPR(RA)(28,31)) :
			          (CASE_SIZE == 4) ? concat(zero(4), GPR(RA)(27,31)) :
			          (CASE_SIZE == 5) ? concat(zero(3), GPR(RA)(26,31)) :
			          (CASE_SIZE == 6) ? concat(zero(2), GPR(RA)(25,31)) :
			                             concat(zero(1), GPR(RA)(24,31)) ;

			var index = concat(op1, zero(1));		  

			NNPC = PC + offset + index;

            if(NOP_J == 1) 
			   Fetch = JmpN;
			
		};
	}

	define(instr=call)//absolute
	{
	  width=32;
		fields=(OPCD(0x13), NOP_J, BIT, RA, RB, OPCD_B21(0), OPCD_B22(0), CMPRS_J, NOTAC);
		syntax = ("%i%p%p %f%f[%f],%f",NOP_J,CMPRS_J,NOTAC,RA,BIT,RB,BIT(31-BIT));
		action =
		{
			bits<32> op1  = (RA == 0x1f) ? cr : GPR(RA);

			bits<1> cond  = NOTAC ^ op1(BIT,BIT);
			
			bits<24> tmp  = GPR(RB);

			if(CMPRS_J == 1) 
			   tmp = concat(tmp(8), zero(8), tmp(9,23));

			if(cond == 1)
			{
			  NNPC = tmp;

              if(NOP_J == 1) 
			     Fetch = JmpN;
			}

			tmp = PC + 2;

			sp = tmp;
		};
	}

		
	define(instr=pop)
	{
	  width=32;
		fields=(OPCD(0x13), NOP_J, BIT, RA, RB, OPCD_B21(1), OPCD_B22(0), CMPRS_J, NOTAC);
		syntax = ("%i%p%p %f%f[%f],%f",NOP_J,CMPRS_J,NOTAC,RA,BIT,RB,BIT(31-BIT)); 
		action =
		{
			bits<32> op1  = (RA == 0x1f) ? cr : GPR(RA);

			bits<1> cond  = NOTAC ^ op1(BIT,BIT);
			
			bits<24> tmp  = GPR(RB);

			if(CMPRS_J == 1) 
			   tmp = concat(tmp(8), zero(8), tmp(9,23));

			if(cond == 1)
			{
			  NNPC = tmp;

              if(NOP_J == 1) 
			     Fetch = JmpN;
			}
		};
	}
	

	
	define(instr=returnn)
	{
	  width=32;
	  	//fixme notac was not opcode
		fields=(OPCD(0x13), NOP_J, BIT(0x1f), RA(0x1f), RB, OPCD_B21(1), OPCD_B22(1), CMPRS_J(0), NOTAC(0));
		syntax = ("return%f %f",NOP_J,RB);
		action =
		{
			NNPC = GPR(RB);

            if(NOP_J == 1) 
			   Fetch = JmpN;

			ILR.en = 1;   
		};
	}

	define(instr=calli)//relative
	{
	  width=32;
		fields=(OPCD_SHRT(0xa), NOT_J, NOP_J, BIT, RA, INSTR_OFFSET);
		syntax=("%i%p %f%f[%f],%f",NOP_J,NOT_J,RA,BIT,INSTR_OFFSET,BIT(31-BIT),INSTR_OFFSET( (INSTR_OFFSET >= cia()) ? (INSTR_OFFSET - cia()) : (~(cia()-INSTR_OFFSET) + 1) ) );
		action =
		{
			bits<32> op1  = (RA == 0x1f) ? cr : GPR(RA);

			bits<1> cond  = NOT_J ^ op1(BIT,BIT);
			
			var offset = signExtend(INSTR_OFFSET,24);

			if(cond == 1)
			{
			  NNPC = PC + offset;

              if(NOP_J == 1) 
			     Fetch = JmpN;
			}	

			bits<24> tmp = PC + 2;

			sp = tmp;
		};
	}
	
	define(instr=jmp)
	{
	  width=32;
		fields=(OPCD_SHRT(0xb), NOT_J, NOP_J, BIT, RA, INSTR_OFFSET);
		syntax = ("%i%f %f%f[%f],%f",NOP_J,NOT_J,RA,IMM_P1,INSTR_OFFSET,
		                      INSTR_OFFSET( (INSTR_OFFSET >= cia()) ? INSTR_OFFSET - cia() : ~(cia()-INSTR_OFFSET) + 1),
				      BIT(31-IMM_P1));
		action =
		{
			bits<32> op1  = (RA == 0x1f) ? cr : GPR(RA);

			bits<1> cond  = NOT_J ^ op1(BIT,BIT);
			
			var offset = signExtend(INSTR_OFFSET,24);

			if(cond == 1)
			{
			  NNPC = PC + offset;

              if(NOP_J == 1) 
			     Fetch = JmpN;
			}	 
		};
	}



// Special instruction:  This is used for simulation purposes and is
    // not a PPC instruction.
    define (instr=halt)
    {
	  width=32;
      fields=(OPCD(0x09));
      action = 
	  {
		 halt();
      };
    }
    
    

}



//define (core = qe_risc) 
//{
//	archs = qe_risc_3_11;
//}

define (sys=QE_2risc) 
{
	
	define (core = qe_risc) 
	{
		archs = qe_risc_3_11;
		
	}

	define(shared)
	{
//      regfiles = DMEM;
//      mems      = DMEM;
      regfiles = DSEM;
	}

	qe_risc core0;
//	qe_risc core1;

}


