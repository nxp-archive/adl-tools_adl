#!/usr/bin/env perl
#
# Copyright (C) 2005 by Freescale Semiconductor Inc.  All rights reserved.
#
# You may distribute under the terms of the Artistic License, as specified in
# the COPYING file.
#

# Reads in a *.C.in file and inserts autogenerated code where necessry.
# Writes out a *.C file.

use File::Basename;

my $infile = shift;
my $outfile = "out.C";
my $size_str;
my ($fbase,$fpath,$fext) = fileparse($infile,".C.in");
if ($fext) { 
	$outfile = "$fbase.C"; 
}

print "Output file is: $outfile\n"; 
 
`rm -f $outfile`;
open OUT, ">$outfile" or die "unable to open $outfile for writing.\n";
open IN,  "<$infile" or die "unable to open $infile for reading.\n";

my @sizes;
my $n = 0;

print OUT "// WARNING: THIS FILE IS AUTOGENERATED BY callTemplatizer.pl DO NOT EDIT.  \n";
print OUT "// EDIT $infile INSTEAD!!! \n";

while (<IN>)
  {
    if (/PERL:(.*)/)
      {
        # sizes
        @sizes = split /,/, $1;
        $n = @sizes;
        $size_str = $1;
      }
    
    my ($single,$nomodify);
    if (/t.check/) 
      {
        # take function to be templatized and
        # get all combinations of pairs of sizes
        my $i; my $j;
        my $single = 0;
        my $all = 0;
        my $both = 0;
        my $str2 = "";
        if (/PopCounts/) {$single = 1; }
        if (/CountLeadingZeros/) {$single = 1; }
        if (/BitAccessors/) {$single = 1; }
        if (/Inversions/) {$single = 1; } 
        if (/Shifts/) {$single = 1; }
        if (/SetAlls/) {$single = 1; }
        if (/ClearAlls/) {$single = 1; }
        if (/GetInts/) {$single = 1; }
        if (/SignExtends/) {$both = 1; }
        if (/Concat/) { $all = 1;}
        if (/SignedCompar/) {$both = 1;} 
	if (/ByteSwaps/) {$nomodify = 1;}
	if (/WordSwaps/) {$nomodify = 1;}
	if ($nomodify) {
	  print OUT $_;
	  next;
	}
		
        if ($all) {
          # all sizes
          my $str = $_;
          $str=~s/\(/\<$size_str>\(/;
          print OUT $str;
        }
        elsif (!$single) {
          # all combinations of pairs of the sizes
          for ($i = 0; $i < $n; $i++) {
            for ($j = $i; $j < $n; $j++)
              {    
                my $str = $_;

                if ($both) {      # the test wants both calls, <larger,smaller> and <smaller,larger>
                  if ($sizes[$j] != $sizes[$i]) {
                    $str2 = $str;
                    $str2=~s/\(/\<$sizes[$i],$sizes[$j]>\(/;
                    print OUT $str2;
                  }
                  $str=~s/\(/\<$sizes[$j],$sizes[$i]>\(/; 
                }                 # the tests assume the first size is larger, so reorder if necessary
                elsif (eval($sizes[$i]) <= eval($sizes[$j])) { $str=~s/\(/\<$sizes[$i],$sizes[$j]>\(/; }
                else  { $str=~s/\(/\<$sizes[$j],$sizes[$i]>\(/; }
                print OUT $str;
              }
          }
        }
        
        else {
          foreach $i (@sizes)
            { 
              # just takes a single size or pair of same size
              my $str = $_;
              if (!$single)
                { $str=~s/\(/\<$i,$i>\(/;}
              else { $str=~s/\(/\<$i>\(/;}
              print OUT $str;
            }
        }
      }
    else {
      print OUT $_;
    }
  }

# remove write permission
`chmod -w $outfile`;
