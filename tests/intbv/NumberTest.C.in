//
// intbv testbench program.
//

#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#include <stdio.h>
#include <unistd.h>
#include <stdexcept>
#include <cassert>
#include <algorithm>
#include <sstream> 
#include  <iostream>


// 0 - intbv
// 1 - bits
// 2 - sintbv
// 3 - le_intbv
// 4 - le_sitbv


#if NumType == 0
#  include "intbv.h"
#  define Num  intbv
#  define UNum intbv
#  define SIGNED false
#  define LE false
#elif NumType == 1
#  include "bits.h"
#  define Num  bits
#  define UNum bits
#  define SIGNED false
#  define LE false
#elif NumType == 2
#  include "sintbv.h"
#  define Num  sintbv
#  define UNum  intbv
#  define SIGNED true
#  define LE false
#elif NumType == 3
#  include "le_intbv.h"
#  define Num  le_intbv
#  define UNum le_intbv
#  define SIGNED false
#  define LE true
#elif NumType == 4
#  include "le_sintbv.h"
#  define Num  le_sintbv
#  define UNum le_intbv
#  define SIGNED true
#  define LE true
#else
#  error "You must define NumType from [0,4]."
#endif

#if NumType >= 3
const bool LittleEndian = true;
#else
const bool LittleEndian = false;
#endif

#if __WORDSIZE == 64
# define PRIsz "lu"
#else
# define PRIsz "u"
#endif

inline void set_pos(size_t& a, size_t &b) {
  if (LittleEndian) {
    size_t tmp = a;
    a = b;
    b = tmp;
  };
}

inline void set_pos(size_t& var1, size_t& var2, size_t size1,size_t size2) {
  if (LittleEndian) {
    var1 = size2;
    var2 = size1;
  } else { 
    var1 = size1;
    var2 = size2;
  }
};

inline size_t msb(size_t size) {
  return LittleEndian? size-1 : 0;
}

#include "rnumber/RNumber.h"
#include "rnumber/Random.h"
#include "AnyOption.h"
 
  
using namespace std;
using namespace rnumber;
using namespace intbv_io;
using namespace adl;

int maxIter = 100;
   
// create a functor to pass to intbv for use in
//  generating random intbv's
class rand_functor {
private:
  mutable RandomObj _r;
  unsigned _seed;
public:
  // ctor
  rand_functor(unsigned s) : _r(s), _seed(s) {}
  // access to the random number generator
  unsigned uniform(unsigned limit) const { return _r.getInteger(limit); };
  unsigned uniform(unsigned min,unsigned max) const { return _r.getFromRange(min,max); };
  // the functor
  unsigned operator()() const { return _r.getInteger(); } 
};

class Calculator {
public:
  
  Calculator (const char *pgm);
  ~Calculator ();
  
  template <size_t size1, size_t size2, size_t size3>
  unsigned checkArith (Num<size1> a, Num<size2> b, const Num<size3>& c, const char *op, bool ext = false);

#if SIGNED
  template <size_t size1, size_t size2, size_t size3>
  unsigned checkArith (Num<size1> a, UNum<size2> b, const UNum<size3>& c, const char *op, bool ext = false);  

  template <size_t size1, size_t size2, size_t size3>
  unsigned checkArith (UNum<size1> a, Num<size2> b, const UNum<size3>& c, const char *op, bool ext = false);
#endif  

  template <size_t size1, size_t size2>
  unsigned checkArith (Num<size1> a, int32_t b, const Num<size2>& c, const char *op, bool ext = false);

  template <size_t size1, size_t size2>
  unsigned checkArith (int32_t a, Num<size1> b, const Num<size2>& c, const char *op, bool ext = false);

  template <size_t size1, size_t size2>
  unsigned checkArith (Num<size1> a, uint64_t b, const Num<size2>& c, const char *op, bool ext = false);

  template <size_t size1, size_t size2>
  unsigned checkArith (uint64_t a, Num<size1> b, const Num<size2>& c, const char *op, bool ext = false);

  template <size_t size1, size_t size2>
  unsigned checkComparator (const Num<size1>& a, const Num<size2>& b, int res, const char *op, bool ext = false);

  template <size_t size1>
  unsigned checkComparator (const Num<size1>& a, uint32_t b, int res, const char *op, bool ext = false);
  
private:
  const char *_pgm;
  int _fd1[2];
  int _fd2[2];
  
  void init ();
  void terminate ();

  template <size_t size>
  unsigned arithCalc (const char *astr,unsigned asize,
                      const char *bstr,unsigned bsize,
                      const Num<size> &c,const char *op,
                      bool ext);
};



class tests {
private:

  template <size_t size1,size_t size2,size_t size3,size_t size4>
  unsigned checkLogicalOp (const Num<size1>& a, const Num<size2>& b, const Num<size3>& res1, const Num<size4>& res2, const char *op);
   
  template <size_t size1,size_t size2,size_t size3>
  unsigned checkLogicalOp (const Num<size1>& a, int b, const Num<size2>& res1, const Num<size3>& res2, const char *op);
    
  template <size_t size1,size_t size2>
  unsigned checkLogicalOp (const Num<size1>& a, int b, const Num<size2>& res1, unsigned res2, const char *op);
    
  template <size_t size1,size_t size2,size_t size3>
  unsigned checkLogicalOp (const Num<size1>& a, const Num<size2>& b, const Num<size3>& res1, unsigned res2, const char *op);
  rand_functor _genRandom;   // the randomization class
  
public:
        // ctor
  tests(unsigned s): _genRandom(rand_functor(s)) {}
  // test functions
  template <size_t size1> unsigned checkPopCounts ();
  template <size_t size1> unsigned checkCountLeadingZeros ();
  template <size_t size1, size_t size2,size_t size3,size_t size4,size_t size5,size_t size6,size_t size7,size_t size8> unsigned checkConcatenation ();
  template <size_t size1, size_t size2> unsigned checkConstructors ();  
  unsigned checkByteSwaps();
  unsigned checkWordSwaps();
  template <size_t size1, size_t size2> unsigned checkLogicals ();
  template <size_t size1, size_t size2> unsigned checkOperator    (const char *op, Calculator *calc,bool is_signed=false);
  template <size_t size1, size_t size2> unsigned checkMutator     (const char *op, Calculator *calc,bool is_signed=false);
  template <size_t size1, size_t size2> unsigned checkComparator  (const char *op, Calculator *calc, bool ext);
  template <size_t size1, size_t size2> unsigned checkSignExtends ();
  template <size_t size1, size_t size2> unsigned checkSignedComparator  (const char *op, Calculator *calc); 
  template <size_t size1> unsigned checkBitAccessors();
  template <size_t size1, size_t size2> unsigned checkFieldAccessors ();
  template <size_t size1> unsigned checkInversions ();
  template <size_t size1> unsigned checkShifts ();
  template <size_t size1> unsigned checkSetAlls ();
  template <size_t size1> unsigned checkClearAlls ();
  template <size_t size1> unsigned checkGetInts ();
  template <size_t size1, size_t size2> unsigned checkMisc ();
  template<size_t size1> Num<size1> genRandom();
};



//========================== the tests =========================================
template <size_t size1>
static unsigned checkReadWrite (const Num<size1>& numa, int radix)
{
  unsigned rc = 0;
  const int PHex = (ihex | iprefix);
  ostringstream ss1;
  int realradix = 0;
  if (radix & ihex) {
    realradix = 16;
    ss1.setf(std::ios_base::hex);
  } else if (radix & idec) {
    realradix = 10;
    ss1.setf(std::ios_base::dec);
  } else if (radix & ibin) {
    realradix = 2;
    ss1.setf(std::ios_base::oct);
  } else {
    assert(0);
  }
  ss1.setf(std::ios_base::showbase);
  
 
  numa . printToOS(ss1);

  ostringstream ss2;
  ss2.setf(std::ios_base::hex | std::ios_base::showbase);
  Num<64> db = 0x12345678deadbeefULL;
  db . printToOS(ss2);

  // construct same size Num from string
  Num<size1> numb (ss1.str());
  if (numa != numb) {
    cout << "Error in reading/writing of "<<numb.str(PHex)<<" with implied radix "<<realradix<<"\n"
         << "                  expected: "<<numa.str(PHex)<<endl;
    rc = 1;
  }
  
  // fix me: add test for construct from stream
  
  return rc;
}

template <size_t size1>
Num<size1> tests::genRandom() {
  Num <size1> res (0,_genRandom);
  unsigned num_words = _INTBV_WORDS(size1);
  size_t start = 0;
  size_t stop = 31;
  set_pos(start,stop);
  Num<32> r;
  for (unsigned i = 0; i < num_words; i++){
    r = _genRandom();    
    if (LittleEndian) {
      if (start >= size1) {
        start = size1 -1; 
      }    
    } else {
      if (stop >= size1) {
        stop = size1 -1;
      }
    }  
          res.set(start,stop,r);
    start += 32;
    stop += 32;
  }  
  return res;
} 

template <size_t size1>
unsigned tests::checkPopCounts () {
  unsigned rc = 0;
  
  { // 1
    Num<size1> a = genRandom<size1>();
    size_t const actual = a.count_ones();
    size_t expected = 0;
    for (unsigned i = 0; i < size1; ++i) {
      if (a[i] != 0) ++expected;
    }
    //++expected; // debug ONLY - use this to contrive a failure, to test that condition
    if (actual != expected) {
      cout << "Error occurred in population count: "<<a<<"<"<<size1<<">.count_ones() resulted in "<<actual<<" (expected "<<expected<<")"<<endl;
      rc = 1;
    }
  }
  
  return rc;
} 

template <size_t size1>
unsigned tests::checkCountLeadingZeros () {
  unsigned rc = 0;
  
  { // 1
    Num<size1> a = genRandom<size1>();
    size_t const actual = a.count_leading_zeros();
    size_t expected = 0;
    if (LE) {
      for (int i = size1-1; i >= 0; --i) {
        if (a[i] != 0) break;
        ++expected;
      }
    } else {
      for (unsigned i = 0; i < size1; ++i) {
        if (a[i] != 0) break;
        ++expected;
      }
    }

    if (actual != expected) {
      cout << "Error occurred in count-leading-zeros: "<<a<<"<"<<size1<<">.count_leading_zeros() resulted in "<<actual<<" (expected "<<expected<<")"<<endl;
      rc = 1;
    }
  }
  
  return rc;
} 

template <size_t size1, size_t size2,size_t size3,size_t size4,size_t size5,size_t size6,size_t size7,size_t size8>
unsigned tests::checkConcatenation ()    
{
  unsigned rc = 0;
    

  Num<size1> a =genRandom<size1>();
  Num<size2> b =genRandom<size2>();
  Num<size3> c =genRandom<size3>();
  Num<size4> d =genRandom<size4>();
  Num<size5> e =genRandom<size5>();
  Num<size6> f =genRandom<size6>();
  Num<size1> tmp_a;
  Num<size2> tmp_b;
  Num<size3> tmp_c;
  Num<size4> tmp_d;
  Num<size5> tmp_e;
  Num<size6> tmp_f;
  size_t s1,s2;


  // 2
  Num<size1+size2> res2 = LittleEndian ? concat(b,a) : concat(a,b);
  set_pos(s1,s2,0,size1-1);
  tmp_a = res2 (s1, s2);
  set_pos(s1,s2,size1,size1+size2-1);
  tmp_b = res2 (s1, s2);
  if ((a != tmp_a) || (b != tmp_b)) {      
    cout << hex << "1Error occurred in concatenation: concat("<< a << "," <<b<<") resulted in "<<res2<<endl;
    rc = 1;
  }
  // 3
  Num<size1+size2+size3> res3 = LittleEndian ? concat(c,b,a) : concat(a,b,c);
  set_pos(s1,s2,0,size1-1);
  tmp_a = res3 (s1, s2);
  set_pos(s1,s2,size1,size1+size2 -1);
  tmp_b = res3 (s1, s2);
  set_pos(s1,s2,size1+size2,size1+size2+size3 -1);
  tmp_c = res3 (s1, s2);
  if ((a != tmp_a) || (b != tmp_b) || (c != tmp_c)) {      
    cout << hex << "2Error occurred in concatenation: concat("<< a << "," <<b <<","<< c<<") resulted in "<<res3<<endl;
    rc = 1;
  }
  // 4
  Num<size1+size2+size3+size4> res4 = LittleEndian ? concat(d,c,b,a) : concat(a,b,c,d);
  set_pos(s1,s2,0,size1-1);
  tmp_a = res4 (s1, s2);
  set_pos(s1,s2,size1,size1+size2 -1);
  tmp_b = res4 (s1, s2);
  set_pos(s1,s2,size1+size2,size1+size2+size3 -1);
  tmp_c = res4 (s1, s2);
  set_pos(s1,s2,size1+size2+size3,size1+size2+size3+size4  -1);
  tmp_d = res4 (s1, s2);
    
  if ((a != tmp_a) || (b != tmp_b) || (c != tmp_c) || (d != tmp_d)) {      
    cout << hex << "3Error occurred in concatenation: concat("<< a << "," <<b <<","<< c<<","<<d<<") resulted in "<<res4<<endl;
    rc = 1;
  }
  
  // 5
  Num<size1+size2+size3+size4+size5> res5 = LittleEndian ? concat(e,d,c,b,a) : concat(a,b,c,d,e);
  set_pos(s1,s2,0,size1-1);
  tmp_a = res5 (s1, s2);
  set_pos(s1,s2,size1,size1+size2 -1);
  tmp_b = res5 (s1, s2);
  set_pos(s1,s2,size1+size2,size1+size2+size3 -1);
  tmp_c = res5 (s1, s2);
  set_pos(s1,s2,size1+size2+size3,size1+size2+size3+size4  -1);
  tmp_d = res5 (s1, s2);
  set_pos(s1,s2,size1+size2+size3+size4,size1+size2+size3+size4+size5  -1);
  tmp_e = res5 (s1, s2);

  if ((a != tmp_a) || (b != tmp_b) || (c != tmp_c) || (d != tmp_d) || (e != tmp_e)) {      
    cout << hex << "4Error occurred in concatenation: concat("<< a << "," <<b <<","<< c<<","<<d<<","<<e<<") resulted in "<<res5<<endl;
    rc = 1;
  }
  // 6
  Num<size1+size2+size3+size4+size5+size6> res6 = LittleEndian ? concat(f,e,d,c,b,a) : concat(a,b,c,d,e,f);
  set_pos(s1,s2,0,size1-1);
  tmp_a = res6 (s1, s2);
  set_pos(s1,s2,size1,size1+size2 -1);
  tmp_b = res6 (s1, s2);
  set_pos(s1,s2,size1+size2,size1+size2+size3 -1);
  tmp_c = res6 (s1, s2);
  set_pos(s1,s2,size1+size2+size3,size1+size2+size3+size4  -1);
  tmp_d = res6 (s1, s2);
  set_pos(s1,s2,size1+size2+size3+size4,size1+size2+size3+size4+size5  -1);
  tmp_e = res6 (s1, s2);
  set_pos(s1,s2,size1+size2+size3+size4+size5,size1+size2+size3+size4+size5+size6  -1);
  tmp_f = res6 (s1, s2);

  if ((a != tmp_a) || (b != tmp_b) || (c != tmp_c) || (d != tmp_d) || (e != tmp_e) || (f != tmp_f)) {      
    cout << hex << "5Error occurred in concatenation: concat("<< a << "," <<b <<","<< c<<","<<d<<","<<e<<","<<f<<") resulted in "<<res6<<endl;
    rc = 1;
  }

  return rc;

}

template <size_t size1, size_t size2>
unsigned tests::checkConstructors ()    
{ 
  unsigned rc = 0;        
  assert (size2 >= size1);
  if(SIGNED && (size1==1)) {
    return 0;
  }
  // construct from unsigned long long
  uint64_t x1 = 0x12345678deadbeefULL;
  Num<64> a1(x1);
  Num<64> b1("0x12345678deadbeef");
  if ( b1 != a1) {
    cout << "Error occurred in string constructor of "<< b1 <<endl;
    rc = 1;
  }

  // construct from long long int 
  long long int x2 = 0x12345678deadbeef;
  Num<64> a2(x2);
  Num<64> b2("0x12345678deadbeef");
  if ( b2 != a2) {
    cout << "Error occurred in string constructor of "<< b2 <<endl;
    rc = 1;
  }
  
  // construct from unsigned long
  unsigned long x3 = 0xdeadbeefUL;
  Num<32> a3(x3);
  Num<32> b3("0xdeadbeef");
  if ( b3 != a3) {
    cout << "Error occurred in string constructor of "<< b3 <<endl;
    rc = 1;
  }
  
  // construct from long
  long x4 = 0xdeadbeef;
  Num<32> a4(x4);
  Num<32> b4("0xdeadbeef");
  if ( b4 != a4) {
    cout << "Error occurred in string constructor of "<< b4 <<endl;
    rc = 1;
  }

  for (int i = 0; i < maxIter; i++) { 
    // test various string constructors
    Num<size1> num1a =genRandom<size1>();
    rc |= checkReadWrite (num1a, ihex);
    rc |= checkReadWrite (num1a, ibin);
    rc |= checkReadWrite (num1a, idec);
        
        
    Num<size1> x0 =genRandom<size1>();
    Num<size2> y0 =genRandom<size2>();
    Num<size2> tmp (0);
        
    // basic copy constructor
    Num<size1> z1 (x0);
    if (z1 != x0 || z1 . size () != size1) {
      cout<<"Error occurred in basic copy constructor of "<< x0 <<endl;
      rc = 1;
    }
        
    // construct larger number
    Num<size2> z2 (x0);
    if (z2 != x0 || z2 . size () != size2) {
      cout << "Error (1) occurred in sized copy constructor of " << hex << z2 << " from" << x0 << endl;
      rc = 1;
    }
        
    // construct smaller number
    Num<size1> z3 (y0);
    tmp = y0;
    tmp <<= (size2 - size1);
    tmp >>= (size2 - size1);
    if(SIGNED) {
      if (LittleEndian) {
        tmp.signExtend(size1 -1);
      } else {
        tmp.signExtend(size2-size1);
      }
    }
    if (z3 != tmp || z3 . size () != size1) {
      cout << "Error (2) occurred in sized copy constructor of " << hex << z3 << " from " << tmp << dec << endl;
      rc = 1;
    }
        
    // construct from integer
    unsigned num = _genRandom();
    unsigned num_mask = 0xfffffffful;
    
    num_mask >>= max(0,(32-(int)size2));
    
    Num<32> z31 = num;
    if (z31 != num ) {
      cout << "Error occurred in constructing from integer" <<num<<endl;
      rc = 1; 
    }

    // construct from an integer expression via uint32_t conversion.
    {
      Num<32> x = _genRandom();
      Num<32> y = x.uint32() & 0xffff0000;
      if ( y != (x & 0xffff0000) ) {
        cout << "Error occurred in constructing from integer" << x << " & 0xffff0000." << endl;
        rc = 1; 
      }
    }
        
    // construct to larger from integer
    Num<size2> z32 (num);
    if ((UNum<size2>)z32 != (num_mask&num) || z32 . size () != size2) {
      cout << hex << "Error occurred in constructing larger number from integer " << z32 << " != " << num << endl;
      cout << dec << "size,size2" << z32.size() << " " << size2 << endl;
      rc = 1;
    }
        
    // construct to smaller from integer
    const size_t size3 = 20; 
    Num<size3> z33 (num);
    unsigned diff = 32 - size3;
    unsigned num2 = (num << diff) >> diff;
    if ((UNum<size3>)z33 != num2 || z33 . size () != size3) {
      cout << "Error occurred in constructing smaller number from integer "<< hex << num << endl;
      cout << "z33 = " << z33 << endl;
      cout << "num2 = " << num2 << endl;
      rc = 1;
    }

    // construct using RNumber.
    {
      Num<size1> x = genRandom<size1>();
      rnumber::RNumber t = x.rnum();
      Num<size1> y = t;
      Num<size1> z;
      z = t;
      if (x != y) {
        cout << "Error occurred in constructing from an RNumber of " << x << endl;
        rc = 1;
      }
      if (x != z) {
        cout << "Error occurred in assigning from an RNumber of " << x << endl;
        rc = 1;
      }
    }

    // construct using a smaller RNumber.
    {
      Num<size1> x = genRandom<size1>();
      rnumber::RNumber t = x.rnum();
      Num<size2> y = t;
      Num<size2> z;
      z = t;
      if (x != y) {
        cout << "Error occurred in constructing intbv<" << size2 << "> from an RNumber of " << x << " (size " << size1 << ")" << endl;
        rc = 1;
      }
      if (x != z) {
        cout << "Error occurred in assigning intbv<" << size2 << "> from an RNumber of " << x << " (size " << size1 << ")" << endl;
        rc = 1;
      }
    }

    // construct using a larger RNumber.
    {
      Num<size2> x = genRandom<size2>();
      Num<size1> x_t = x;
      rnumber::RNumber t = x.rnum();
      Num<size1> y = t;
      Num<size1> z;
      z = t;
      if (x_t != y) {
        cout << "Error occurred in constructing intbv<" << size1 << "> from an RNumber of " << x << " (size " << size2 << ")" << endl;
        rc = 1;
      }
      if (x_t != z) {
        cout << "Error occurred in assigning intbv<" << size1 << "> from an RNumber of " << x << " (size " << size2 << ")" << endl;
        rc = 1;
      }
    }
        
    // basic operator=
    Num<size1> z7  =genRandom<size1>();
    z7 = x0;
    if (z7 != x0 || z7 . size () != size1) {  
      cout << "Error occurred in basic operator= of "<<x0 <<endl;
      rc = 1;
    }
        
    // operator= from smaller
    Num<size2> z8  =genRandom<size2>();
    z8 = x0;
    if (z8 != x0 || z8 . size () != size2) {
      cout << "Error occurred in sized operator= of "<<x0 <<endl;
      rc = 1;
    }
        
    // operator= from larger
    Num<size1> z9  =genRandom<size1>();
    z9 = y0;
    if (z9.size() != size1) {
      cout << "Error occurred in sized operator= of "<<y0 <<endl;
      rc = 1;
    }
        
    // operator= from integer
    Num<32> z91 (0);
    unsigned num91 = _genRandom();
    z91 = num91;
    if (z91 != num91 || z91 . size () != 32) {
      cout << "Error occurred in operator= of "<< num91<<endl;
      rc = 1;
    }
        
    // operator= to larger from integer
    Num<size2> z92 =genRandom<size2>();
    unsigned num92 = _genRandom();
    z92 = num92;
    if ((UNum<size2>)z92 != (num92&num_mask) || z92 . size () != size2) {
      cout << "Error occurred in operator= of %x to larger from integer"<<num92<<endl;
      rc = 1;
    }
        
    // operator= to smaller from integer
    const size_t size93 = 20;
    Num<size93> z93 =genRandom<size93>();
        
    unsigned num93 = _genRandom();
    z93 = num93;
    unsigned mask = 0x1;
    unsigned count = 32 - size93;
    for (unsigned  i = 0; i <count; i++) {
      mask |= 1;
      mask <<= 1;
    }  
    mask |= 1;
    mask <<= size93;
    num93 = num93 & ~mask;
    if ((UNum<size93>)z93 != num93 ) {
      cout<<"Error occurred in operator= to smaller from integer of "<<z93<<" = "<<hex<<num93<<" mask = "<<mask<<endl;
      rc = 1;
    }    
  }    
  return rc;  
}

// Some byte-swap tests.
unsigned tests::checkByteSwaps()
{
  unsigned rc = 0;

  {
    Num<32> a = 0xdeadbeef;
    Num<32> b = a.swap_bytes();
    
    if ( b != 0xefbeadde ) {
      cout << "Error occurred swapping 32-bit quantity (swapped " << a << " and got " << b << ")."<<endl;
      rc = 1;
    }
  }

  {
    Num<16> a = 0x1234;
    Num<16> b = a.swap_bytes();

    if ( b != 0x3412 ) {
      cout << "Error occurred swapping 16-bit quantity (swapped " << a << " and got " << b << ")."<<endl;
      rc = 1;
    }
  }

  {
    Num<64> a = 0x012345678abcdef0ULL;
    Num<64> b = a.swap_bytes();

    if ( b != 0xf0debc8a67452301ULL ) {
      cout << "Error occurred swapping64-bit quantity (swapped " << a << " and got " << b << ")."<<endl;
      rc = 1;
    }
  }

  {
    Num<24> a = 0x123456;
    Num<24> b = a.swap_bytes();

    if ( b != 0x563412 ) {
      cout << "Error occurred swapping 23-bit quantity (swapped " << a << " and got " << b << ")."<<endl;
      rc = 1;
    }
  }

  {
    Num<48> a = 0x12345678abcdULL;
    Num<48> b = a.swap_bytes();

    if ( (UNum<48>)b != 0xcdab78563412ULL ) {
      cout << "Error occurred swapping 48-bit quantity (swapped " << a << " and got " << b << ")."<<endl;
      rc = 1;
    }
  }

  return rc;
}

// Some word-swap tests.
unsigned tests::checkWordSwaps()
{
  unsigned rc = 0;

  {
    const int Nb = 32;
    Num<Nb> a = 0xdeadbeef;
    Num<Nb> b = a.swap_words();
    
    if ( b != 0xdeadbeef ) {
      cout << "Error occurred swapping " << Nb << "-bit quantity (swapped " << hex << a << " and got " << b << ")."<<endl;
      rc = 1;
    }
  }

  {
    const int Nb = 64;
    Num<Nb> a = 0x12345678abcdef01ULL;
    Num<Nb> b = a.swap_words();

    if ( b != 0xabcdef0112345678ull ) {
      cout << "Error occurred swapping " << Nb <<"-bit quantity (swapped " << hex << a << " and got " << b << ")."<<endl;
      rc = 1;
    }
  }

  {
    const int Nb = 48;
    Num<Nb> a = 0x12345678abcdULL;
    Num<Nb> b = a.swap_words();

    if ( (UNum<Nb>)b != 0x5678abcd1234ull ) {
      cout << "Error occurred swapping " << Nb << "-bit quantity (swapped " << hex << a << " and got " << b << ")."<<endl;
      rc = 1;
    }
  }

  {
    const int Nb = 56;
    Num<Nb> a = 0x12345678abcdefULL;
    Num<Nb> b = a.swap_words();

    if ( (UNum<Nb>)b != 0x78abcdef123456ull ) {
      cout << "Error occurred swapping " << Nb <<"-bit quantity (swapped " << hex << a << " and got " << b << ")."<<endl;
      rc = 1;
    }
  }

  {
    const int Nb = 128;
    Num<Nb> a("0x12345678_9abcdef0_87654321_45123784");
    Num<Nb> b = a.swap_words();
    Num<Nb> c("0x45123784_87654321_9abcdef0_12345678");

    if ( (UNum<Nb>)b != c ) {
      cout << "Error occurred swapping " << Nb << "-bit quantity (swapped " << hex << a << " and got " << b << ")."<<endl;
      rc = 1;
    }
  }

  {
    const int Nb = 112;
    Num<Nb> a("0x5678_9abcdef0_87654321_45123784");
    Num<Nb> b = a.swap_words();
    Num<Nb> c("0x45123784_87654321_9abcdef0_5678");

    if ( (UNum<Nb>)b != c ) {
      cout << "Error occurred swapping " << Nb << "-bit quantity (swapped " << hex << a << " and got " << b << ")."<<endl;
      rc = 1;
    }
  }

  cout << dec;

  return rc;
}


template <size_t size1, size_t size2>
unsigned tests::checkOperator    (const char *op, Calculator *calc,bool is_signed)  
{
    
  unsigned rc = 0;
 
  if ((is_signed || SIGNED) && (size1 == 1 || size2 ==1)) {
    return 0;
  }
 
  for (int iter = 0; iter < maxIter; iter++) {
    Num <size1> a = genRandom<size1>();
    Num <size2> b = genRandom<size2>(); 

#if SIGNED    
    UNum <size1> a1 = genRandom<size1>();
    UNum <size2> b1 = genRandom<size2>(); //
    UNum <(MAX(size1,size2))> c01 (0); 
    UNum <(MAX(size1,size2))> c10 (0); 
#endif
    
    Num <(MAX(size1,size2))> c  (0);
      
    Num <(MAX(size1,64))> d;
    Num <(MAX(size1,64))> e; 
    Num <(MAX(size1,32))> f;
    Num <(MAX(size1,32))> g;    
    
    // Want to check small numbers too;
    if (iter%2) {
      unsigned shift1 = _genRandom.uniform (size1);        
      a >>= shift1;
      unsigned shift2 = _genRandom.uniform (size2);
      b >>= shift2;
#if SIGNED
      unsigned shift3 = _genRandom.uniform (size2);
      b1 >>= shift3;     
#endif
    }
    
    // make sure a won't = 0
    Num<size1> tmp3 (a);
    Num<size1> zer (0);    
    if (op[0] == '/' || op[0] == '%') {
      while (tmp3 == zer) {
        a = genRandom<size1>();
        tmp3 = a;
      } 
    } 
    
    // make sure b won't = 0
    Num<size2> tmp2 (b);
    Num<size2> zero (0);
    if (op[0] == '/' || op[0] == '%') {
      while (tmp2 == zero) {
        b = genRandom<size2>(); 
        tmp2 = b;
      } 
    }  

#if SIGNED
    // make sure b1 won't = 0
    tmp2 = b1;
    if (op[0] == '/' || op[0] == '%') {
      while (tmp2 == zero) {
        b1 = genRandom<size2>(); 
        tmp2 = b1;
      } 
    }
#endif


    uint64_t i = b.uint64();


    int32_t  j = (int32_t)i; // signed 
   
    
    if(j == 0) { j = 1;};    
   
    if(( op[0] == '/' || op[0] == '%') &&(j==0)) {
      cout << "jjjjjjjj" << endl;
    }   
   
    if (!SIGNED) {
      if (j < 0 ) {
        j = -j;
      }    
    }
  
    // tests intbv op intbv, intbv op integer and integer op intbv.
    if (!strcmp(op,"+")) {
      c = a + b;
      d = a + i;
      e = i + a;
      f = a + j;
      g = j + a;
#if SIGNED 
      c01 = a  + b1;
      c10 = a1 + b;	     
#endif
    } else if (!strcmp(op,"-")) {
      c = a - b;
      d = a - i;
      e = i - a;
      f = a - j;
      g = j - a;
#if SIGNED 
      c01 = a  - b1;
      c10 = a1 - b;	     
#endif
    } else if (!strcmp(op,"*")) {
      if (!is_signed) {
        c = a * b;
        d = a * i;
        e = i * a;
      } else {
#       if SIGNED
#         if LE
        c = le_sbitsSignedMultiply(a,b);
        d = le_sbitsSignedMultiply(a,i);
        e = le_sbitsSignedMultiply(i,a);  
#         else
        c = sbitsSignedMultiply(a,b);
        d = sbitsSignedMultiply(a,i);
        e = sbitsSignedMultiply(i,a);  
#         endif        
#       else
        c = signedMultiply(a,b);
        d = signedMultiply(a,i);
        e = signedMultiply(i,a);  
#       endif
      }     
      f = a * j;
      g = j * a;      
#if SIGNED 
      c01 = a  * b1;
      c10 = a1 * b;	     
#endif
    } else if (!strcmp(op,"/")) {
      if (!is_signed) {
        c = a / b;
        d = a / i;
        e = i / a;
      } else {
#       if SIGNED
#         if LE
        c = le_sbitsSignedDivide(a,b);
        d = le_sbitsSignedDivide(a,i);
        e = le_sbitsSignedDivide(i,a);
#         else
        c = sbitsSignedDivide(a,b);
        d = sbitsSignedDivide(a,i);
        e = sbitsSignedDivide(i,a);
#         endif        
#       else
        c = signedDivide(a,b);
        d = signedDivide(a,i);
        e = signedDivide(i,a);
#       endif
      }
      f = a / j;
      g = j / a; 
#if SIGNED 
      c01 = a  / b1;
      c10 = a1 / b;	
#endif
    } else if (!strcmp(op,"%")) {
      if (!is_signed) {
        c = a % b;
        d = a % i;
        e = i % a;
      } else {
#        if SIGNED
#         if LE
        c = le_sbitsSignedMod(a,b);
        d = le_sbitsSignedMod(a,i);
        e = le_sbitsSignedMod(i,a);
#         else
        c = sbitsSignedMod(a,b);
        d = sbitsSignedMod(a,i);
        e = sbitsSignedMod(i,a);
#         endif        
#       else
        c = signedMod(a,b);
        d = signedMod(a,i);
        e = signedMod(i,a);
#       endif
      }
      f = a % j;
      g = j % a;
#if SIGNED 
      c01 = a  % b1;
      c10 = a1 % b;	     
#endif
    } else {
      assert(0);
    }        


#if SIGNED    
    rc |= calc -> checkArith (a, b, c, op, true);      
    rc |= calc -> checkArith (a, i, d, op, true);
    rc |= calc -> checkArith (i, a, e, op, true);      
    rc |= calc -> checkArith (a, j, f, op, true);
    rc |= calc -> checkArith (j, a, g, op, true); 
    rc |= calc -> checkArith (a, b1, c01, op, true);
    rc |= calc -> checkArith (a1, b, c10, op, true);    
#else
    rc |= calc -> checkArith (a, b, c, op, is_signed);
    rc |= calc -> checkArith (i, a, e, op, is_signed);     
    rc |= calc -> checkArith (a, i, d, op, is_signed);      
    if (size1 != 1) {
      rc |= calc -> checkArith (a, j, f, op, false);
      rc |= calc -> checkArith (j, a, g, op, false); 
    }
#endif 
      
    
    if (rc) {
      break;
    }
  }
  return rc;
}

template <size_t size1, size_t size2>
unsigned tests::checkMutator     (const char *op, Calculator *calc,bool is_signed)
{
 
  if ((is_signed || SIGNED) && (size1 == 1 || size2 == 1)) {
    return 0;
  }
  unsigned rc = 0;
  for (int i = 0; i < maxIter; i++) {
    Num<size1> a =genRandom<size1>();
    Num<size2> b =genRandom<size2>();        

    // make sure b won't = 0
    Num<size1> tmp2 (b);
    Num<size1> zero (0);
    if (op[0] == '/' || op[0] == '%') {
      while (tmp2 == zero) {
        b = _genRandom();
        tmp2 = b;
      } 
    }

    Num<size1> tmp (a);
    switch (op[0]) {
    case '+': a += b; break;
    case '-': a -= b; break;
    case '*': 
      if (!is_signed) {
        a *= b; 
      } else {
        a.signedMultiplyEqual(b);
      }
      break;
    case '/':
      if (!is_signed) {
        a /= b; 
      } else {
        a.signedDivideEqual(b);
      }
      break;
    case '%': a %= b;  break;
    default:  assert (0);
    }
    
    rc |= calc -> checkArith (tmp, b, a, op,(SIGNED || is_signed));
    if (rc) {
      break;
    }
  }    
  return rc;
}

template <size_t size1,size_t size2>
unsigned tests::checkSignedComparator  (const char *op, Calculator *calc)
{  
  int i;
  unsigned rc = 0;
  bool failed,cmp ;
  
  // you can't represent a signed number in only 1 bit
  if ((size1==1) or (size2 ==1)) {
    return 0;
  }

  for (i = 0; i < maxIter; i++) {

      Num<size1> a =genRandom<size1>();
      Num<size2> b =genRandom<size2>(); 
      Num<size1> c =genRandom<size1>();
      size_t msb_a = msb(size1);
      size_t msb_b = msb(size2);
      size_t msb_c = msb(size1);

    // test b negative, a positive
    if (size1 <= size2) {
      a . set (msb_a, 0);
      b . set (msb_b, 1);
      failed = false;
      if (strcmp (op, "GT") == 0) {
        cmp = a . signedGT (b);
        failed = (! cmp);
      }
      else if (strcmp (op, "GE") == 0) {
        cmp = a . signedGE (b);
        failed = (! cmp);
      }
      else if (strcmp (op, "LT") == 0) {
        cmp = a . signedLT (b);
        failed = cmp;
      }
      else if (strcmp (op, "LE") == 0) {
        cmp = a. signedLE (b);
        failed = cmp;
      }
      if (failed) {
        cout<<"Error occurred in signed comparison: "<< a<<" (" << size1 << " bits) " << op << " " << b << " (" << size2 << " bits)" << endl; 
        rc = 1;
      }
    }

    // test a negative, b positive
    if (size1 >= size2) {
      a . set (msb_a, 1);
      b . set (msb_b, 0);
      failed = false;
      if (strcmp (op, "GT") == 0) {
        cmp = a . signedGT (b);
        failed = cmp;  
      }
      else if (strcmp (op, "GE") == 0) {
        cmp = a . signedGE (b);
        failed = cmp;
      }
      else if (strcmp (op, "LT") == 0) {
        cmp = a . signedLT (b);
        failed = (! cmp);
      }
      else if (strcmp (op, "LE") == 0) {
        cmp = a. signedLE (b);
        failed = (! cmp);
      }
      else
        assert (0);
      if (failed) {
        cout<<"Error occurred in signed comparison: "<< a<<" (" << size1 << " bits) " << op << " " << b << " (" << size2 << " bits)" << endl; 
        rc = 1;
      }
    }

    // test same sign
    unsigned s = _genRandom.uniform (2);
    a . set (msb_a, s);
    b . set (msb_b, s);
    c . set (msb_c, s);
        
    if (size1 < size2) {
      c = a;
      b . set (msb_b, 0);
    }
    else {
      a = c;
    }
        
    int res1, res2;
    const char *newop;
    if (strcmp (op, "GT") == 0) {
      res1 = a . signedGT (b);
      res2 = a . signedGT (c);
      newop = ">";
    }
    else if (strcmp (op, "GE") == 0) {
      res1 = a . signedGE (b);
      res2 = a . signedGE (c);
      newop = ">=";  
    }
    else if (strcmp (op, "LT") == 0) {
      res1 = a . signedLT (b);
      res2 = a . signedLT (c);
      newop = "<";
    }
    else if (strcmp (op, "LE") == 0) {
      res1 = a . signedLE (b);
      res2 = a . signedLE (c);
      newop = "<=";
    }
    else
      assert (0);
    
    rc |= calc -> checkComparator (a, b, res1, newop,true);
    rc |= calc -> checkComparator (a, c, res2, newop,true);
  }

  return rc;
}

template <size_t size1, size_t size2>
unsigned tests::checkComparator  (const char *op, Calculator *calc, bool ext)
{  
  int i;
  unsigned rc = 0;
  if ((ext || SIGNED) && (size1 == 1 || size2 ==1)) {
    return 0;
  }   
  Num<32> x =genRandom<32>();
  Num<32> y =genRandom<32>();
 
  // The 3.x series can't handle using an int, for some reason- causes an
  // ambiguous template error.
# if (__GNUC__ < 4)
  uint64_t a = 0, b = 0, c = 0;
# else
  int a = 0, b = 0, c = 0;
# endif
  UNum<4> d = 1;
  if (x < y) { a = 8; }
  else if (x > y) { b = 4; }
  else if (x == y) { c = 2; }
  UNum<4> res = a | b | c | d;
  
  if (x < y) {
    if (res != 9) {
      cout <<"Error(1) occurred in logical or of integer w/ intbv: ";
      cout << "a = "<<a<<", b = "<<b<<", c = "<<c<<", a | b | c | 1 = "<<res<<endl;
      rc = 1;
    }
  }
  else if (x > y) {
    if (res != 5) {
      cout <<"Error(2) occurred in logical or of integer w/ intbv: ";
      cout << "a = "<<a<<", b = "<<b<<", c = "<<c<<", a | b | c | 1 = "<<res<<endl;
      rc = 1;
    }
  }
  else if (res != 3) {
    cout <<"Error(3) occurred in logical or of integer w/ intbv: ";
    cout << "a = "<<a<<", b = "<<b<<", c = "<<c<<", a | b | c | 1 = "<<res<<endl;
    rc = 1;
  }
 
  for (i = 0; i < maxIter; i++) {
    Num<size1> a =genRandom<size1>();
    Num<size2> b =genRandom<size2>();
    Num<size2> c =genRandom<size2>();
    
    Num<32> tmp1 = genRandom<32>();
    Num<64> tmp2 = genRandom<64>();
    int32_t  d32  =tmp1.int32();
    uint32_t d32u = tmp1.uint32();
    int64_t d64 = tmp2.int64();
    uint64_t d64u = tmp2.uint64();

    if (size1 < size2)
      c = a;
    else
      a = c;
        
    int res0(0),res1(0), res2(0), res32(0),res32u(0),res64u(0),res64(0);
    if (strcmp (op, ">") == 0) {
      res0 = a > a;
      res1 = a > b;
      res2 = a > c;
      res32  = a > d32;
      res32u = a > d32u;
      res64u = a > d64u;
      res64  = a > d64;
    }
    else if (strcmp (op, ">=") == 0) {
      res0 = a >= a;
      res1 = a >= b;
      res2 = a >= c;
      res32  = a >= d32;
      res32u = a >= d32u;
      res64u = a >= d64u;
      res64  = a >= d64;
    }      
    else if (strcmp (op, "<") == 0) {
      res0 = a < a;
      res1 = a < b;
      res2 = a < c;
      res32  = a < d32;
      res32u = a < d32u;
      res64u = a < d64u;
      res64  = a < d64;
    }
    else if (strcmp (op, "<=") == 0) {
      res0 = a <= a;
      res1 = a <= b;
      res2 = a <= c;
      res32  = a <= d32;
      res32u = a <= d32u;
      res64u = a <= d64u;    
      res64  = a <= d64;
    }
    else if (strcmp (op, "==") == 0) {
      res0 = a == a;
      res1 = a == b;
      res2 = a == c;
      res32  = a == d32;
      res32u = a == d32u;
      res64u = a == d64u;      
      res64  = a == d64;
    }
    else if (strcmp (op, "!=") == 0) {
      res0 = a != a;
      res1 = a != b;
      res2 = a != c;
      res32  = a != d32;
      res32u = a != d32u;
      res64u = a != d64u;      
      res64  = a != d64;
    }

    else
      assert (0);
    rc |= calc -> checkComparator (a, a, res0, op, ext);
    rc |= calc -> checkComparator (a, b, res1, op, ext);
    rc |= calc -> checkComparator (a, c, res2, op, ext);
    rc |= calc -> checkComparator (a, tmp1, res32, op, ext);
    rc |= calc -> checkComparator (a, tmp1, res32u, op, ext);
    rc |= calc -> checkComparator (a, tmp2, res64u, op, ext);
    rc |= calc -> checkComparator (a, tmp2, res64 , op, ext);
  }
  return rc;
}

template <size_t size1>
unsigned tests::checkBitAccessors()     {
  unsigned rc = 0;
    
  unsigned i;
    
  for (i = 0; i < 50; i++) {
    unsigned n = _genRandom.uniform (size1);
        
    Num<size1> a (0);
    Num<size1> b (1);
    Num<size1> c (1);
    unsigned shift = LittleEndian? n : size1 - n - 1;
    b <<= shift;
        
        
    // test set/get
    a . set (n, 1);
    if (a != b) {
      cout <<"Error occurred in setting bit "<<n <<" to produce Num<"<<a.size()<<">"<<endl << a << endl;
      rc = 1;
    }
    if (a . get (n) != 1) {
      cout <<"Error occurred in getting bit "<<n <<" of Num<"<<a.size()<<">" <<endl<<a<<endl;
      rc = 1;
    }                                                                                                                                                                       
                
    a . set ();
    b . invert ();
        
    a . set (n, 0);
    if (a != b) {
      cout <<"Error occurred in setting bit "<<n <<" of Num<"<<a.size()<<">" <<endl<<a<<endl;
      rc = 1;
    }
    if (a . get (n) != 0) {
      cout <<"Error occurred in getting bit "<<n <<" of Num<"<<a.size()<<">" <<endl<<a<<endl;
      rc = 1;
            
    }
  }    
  return rc;
}


template <size_t size1, size_t size2>
unsigned tests::checkFieldAccessors ()  {  
  unsigned int rc = 0;
  int num_words = _INTBV_WORDS(size1);
  if (SIGNED && (size1 == 1 || size2 == 1)) {
    return 0;
  }
  
  for (int i = 0; i < maxIter; i++) {
    Num<size1> a (0);
    size_t start = _genRandom.uniform (size1);
    size_t stop  = _genRandom.uniform (start,size1-1);
    set_pos(start, stop);
    Num<size1> field =genRandom<size1>();
    Num<size1> zero1(0);
    if (LittleEndian) { 
      field <<=  num_words * _INTBV_BITS_PER_WORD - size1 + (size1 - start - 1);
      field >>=  MIN(size1-1,num_words * _INTBV_BITS_PER_WORD - size1 + (size1 - start - 1) + stop);
      // to handle signed shift
      unsigned ddd = MIN(size1-1,(num_words * _INTBV_BITS_PER_WORD - size1 + (size1 - start - 1) + stop));
      if (ddd > 0) {
        field.set(size1-1,(size1-1) - (ddd-1),zero1);
      }
    } else {
      field <<=  num_words * _INTBV_BITS_PER_WORD - size1 + start;
      field >>= MIN(size1-1,(num_words * _INTBV_BITS_PER_WORD - size1 + start) + (size1 -1 - stop));
      // to handle signed shift
      unsigned ddd = MIN(size1-1,(num_words * _INTBV_BITS_PER_WORD - size1 + start) + (size1 -1 - stop));
      if (ddd > 0) {
        field.set(0,ddd-1,zero1);
      }
    }

    Num<size2> b (field);
    if (LittleEndian) {
      b <<= stop;
    } else {
      b <<= size1 -1 - stop;
    }
 
    a.reset();
    // set using integers, set
    
    a.set (start, stop, field);
    if (static_cast<UNum<size1> >(a) != static_cast<UNum<size1> >(b)) {
      cout << hex << "set error (3): expected "<< b << " got "<<a<<endl;
      rc = 1;
    }
    // get using integers, get
    if (a.get(start, stop) != field) {
      cout << hex << "get error (4): expected "<< field << " got "<<a<<endl;
      rc = 1;
    }

    Num<size1> i_start(start);
    Num<size1> i_stop(stop);
            
    a.reset();
    a.set (i_start, i_stop, field);
    if (static_cast<UNum<size1> >(a) != static_cast<UNum<size1> >(b)) {
      cout << "set error (7): expected "<< b << " got "<<a<<endl;
      rc = 1;
    }
    
    if (static_cast<UNum<size1> >(a.get (i_start, i_stop)) != static_cast<UNum<size1> >(field)) {
      cout << "get error (8): expected "<< field << " got "<<a(i_start,i_stop)<<endl;
      rc = 1;
    }
    a . set ();
    b . invert ();
    a . set (start, stop, 0);
    if (a (start, stop) != 0) {
      cout << "get error (9): expected 0, got "<<a(start,stop)<<endl;
      rc = 1;
    }
    
    a . set();
    b . reset();
    if (LittleEndian) {
      b.set (size1-1,0,a.template get<size2>(size1-1,0));
    } else {
      b.set (size2-size1,size2-1,a.template get<size2>(0,size1-1));
    }
    if (static_cast<UNum<size1> >(a) != static_cast<UNum<size1> >(b))
    {
        cout << "get error (10): expected" <<a <<", got "<<b<<endl;
        rc = 1;

    }
  }
  return rc;
}

template <size_t size1,size_t size2> 
unsigned tests::checkMisc ()
{
    unsigned rc = 0;
    
    Num<size1> a;
    Num<size2> b;
    Num<MAX(size1,size2)> ones;
    ones.set();
    a.set();
    b.set();
    Num<MAX(size1,size2)> res = Carry (a,b,0);
    if (res != ones) {
        cout << "carry error: expected all ones, got "<<hex<<res<<endl;
        rc = 1;
    }
    a = 0;
    res = Carry (a,b,0);
    if (res != 0) {
        cout << "carry error: expected 0, got "<<hex<<res<<endl;
        rc = 1;
    }

    return rc;
}

template <size_t size1,size_t size2> 
unsigned tests::checkSignExtends ()
{
  unsigned rc = 0;
  unsigned i;

  for (i = 0; i < 50; i++) {
    Num<size1> a (0);
    unsigned n = _genRandom.uniform (size1);
    Num<size1> b (0);
    unsigned shift = LittleEndian ? n : size1 - n - 1;
    b . set ();
    b <<= shift;

        // negative number
    a . set (n, 1);
    a . signExtend (n);
    if (a != b) {
        cout<<"Error (1) occurred in extending bit "<<n<<" produced Num<"<<
            size1<<"> "<<hex<<a<<endl;
      rc = 1;
    }

    // positive number
    a . set ();
    a . set (n, 0);
    b . invert ();

    a . signExtend (n);
    if (a != b) {
          cout<<"Error (2) occurred in extending bit "<<n<<" produced Num<"<<
            size1<<"> "<<hex<<a<<endl;
 
      rc = 1;
    }

#if 0
    // Non-mutating form.
    a.reset();
    a.set(msb(size1),true);
    Num<size2> c = a.template signExtend<size2>();
    Num<size2> d;
    d.set();
    d <<= size1-1;
    if (size2 > size1) {
      // Expanding- new bits should all be set.
      if (c != d) {
        cout << "Error(3) occurred in extending from size "<<size1<<" to size "<<
          size2 << endl;
        rc = 1;
      }
    } else {
      // Shrinking- it's just a copy.
      if (c != Num<size2>(a)) {
        cout << "Error(3) occurred in extending from size "<<size1<<" to size "<<
          size2 << endl;
        rc = 1;
      }
    }
#endif

  }

  return rc;
}

template <size_t size1>
unsigned tests::checkInversions ()      
{  
  unsigned rc = 0;
   
  const int PHex = (ihex | iprefix);
  for (int i = 0; i < maxIter; i++) {
    Num <size1> a =genRandom<size1>();
    Num <size1> tmp = a;
    Num <size1> ones (0);
    ones . set ();
    Num <size1> zero (0);

    if (a != zero) {
      a . negate ();
      if (a + tmp != 0) {
        cout<<"Error occurred in negating "<<tmp.str(PHex)<<"; produced "<<a<<"("<<size1<<")"<<endl;
        rc = 1;
      }
    }
      
      
    /* fix me, add unary minus
       a = -tmp;
       if (a + tmp != 0) {
       printf ("Error occurred in negating %s; produced %s(%d)\n", tmp . str (PHex) . c_str (), a . str () . c_str (), size1);
       rc = 1;
       }
    */
    a = tmp;
    a . invert ();
    if ((a | tmp) != ones) {
      cout<<"Error occurred in inverting "<<tmp.str(PHex)<<"; produced "<<a.str(PHex)<<"("<<size1<<")"<<endl;
      rc = 1;
    }
      
    a = ~tmp;
    if ((a | tmp) != ones) {
      cout<<"Error occurred in inverting "<<tmp.str(PHex)<<"; produced "<<a.str(PHex)<<"("<<size1<<")"<<endl;
      rc = 1;
    }
      
  }  
  return rc;
}

template <size_t size1> 
unsigned tests::checkShifts ()     
{
  const int PHex = (ihex | iprefix);
  unsigned rc = 0;
  for (int i = 0; i < maxIter; i++) {
    // our random number
    
    unsigned n = _genRandom.uniform (size1);
    // a and b all ones
    Num<size1> a (0);
    a . set ();
    Num<size1> b (0);
    b . set ();
    
    Num<size1> i_n (n);
    Num<size1> i_size1(size1);
        
    Num<size1> tmp = (a << n) >> n; 
    /* Fix me: add support for arithmetic (sign extended) shift
       if (tmp != b) {
       printf ("Error (1) occurred in shifting %s(%d) by %d; produced %s\n", 
       a.str(PHex).c_str(), size1, n, tmp.str(PHex).c_str ());
       rc = 1;
       }
    */
        
    // Fix Me: you currently can't shift by an Num, you can only shift by an integer 
    /*
      tmp = (a << x) >> x;
      if (tmp != b) {
      printf ("Error (2) occurred in shifting %s(%d) by %s; produced %s\n", a.str (PHex)c_str (), size1, x.str().c_str(), tmpstr (PHex)c_str ());
      rc = 1;
      }
    */
        
        

    tmp = a;
    tmp <<= n;
    tmp.signedRightShiftEqual(n);
    if (tmp != b) {
      printf ("Error (3) occurred in shift/equaling %s(%" PRIsz ") by %d; produced %s\n", a.str (PHex).c_str (), size1, n, tmp.str (PHex).c_str ());
      rc = 1;
    }
    
    int rexp = SIGNED? -1 : 0;
        
    tmp = a << size1;
    if (tmp != 0) {
      cout<<"Error (4) occurred in shifting "<<a.str(PHex)<<"("<<size1<<") by "<<size1<<"; produced "<<tmp.str(PHex)<<endl;
      rc = 1;
    }
    tmp = a >> size1;
    if (tmp != rexp) {
      cout<<"Error (5) occurred in right shifting "<<a.str(PHex)<<"("<<size1<<") by "<<size1<<"; produced "<<tmp.str(PHex)<<endl;
      rc = 1;
    }
        
    tmp = a;  
    tmp = a << i_size1;
    if (tmp != 0) {
      cout<<"Error (6) occurred in shifting "<<a.str(PHex)<<"("<<size1<<") by "<<size1<<"; produced "<<tmp.str(PHex)<<endl;
      rc = 1;
    }
    tmp = a >> i_size1;
    if (tmp != rexp) {
      cout<<"Error (7) occurred in right shifting "<<a.str(PHex)<<"("<<size1<<") by "<<size1<<"; produced "<<tmp.str(PHex)<<endl;
      rc = 1;
    }
        
    tmp = a;
    tmp <<= size1;
    if (tmp != 0) {
      cout<<"Error (8) occurred in left shift/equaling "<<a.str(PHex)<<"("<<size1<<") by "<<size1<<"; produced "<<tmp.str(PHex)<<endl;
      rc = 1;
    }
    tmp = a;
    tmp >>= size1;
    if (tmp != rexp) {
      cout<<"Error (9) occurred in right shift/equaling "<<a.str(PHex)<<"("<<size1<<") by "<<size1<<"; produced "<<tmp.str(PHex)<<endl;
      rc = 1;
    }
        
    Num<size1> x=genRandom<size1>();
    Num<size1> orig_x (x);
    x = x.right_rotate(size1);
    if (x != orig_x)
      {
        cout << "Error (8) occurred in right rotating "<<orig_x.str(PHex)<<"("<<size1<<") by "<<size1<<"; produced "<<x.str(PHex)<<endl;
        rc = 1; 
      }
    x = x.left_rotate(size1);
    if (x != orig_x)
      {
        cout << "Error (9) occurred in left rotating "<<orig_x.str(PHex)<<"("<<size1<<") by "<<size1<<"; produced "<<x.str(PHex)<<endl;
        rc = 1;  
      }
    x = x.right_rotate(0);
    if (x  != orig_x)
      {
        cout << "Error (10) occurred in right rotating "<<orig_x.str(PHex)<<"("<<size1<<") by 0; produced "<<x.str(PHex)<<endl;
        rc = 1;  
      }
    x = x.left_rotate(0);
    if (x  != orig_x)
      {
        cout << "Error (11) occurred in left rotating "<<orig_x.str(PHex)<<"("<<size1<<") by 0; produced "<<x.str(PHex)<<endl;
        rc = 1; 
      }
        
	

    // left & right rotate by same amount to get back to original value
    if (n && (n != size1))
      {
        x = x.left_rotate(n);
        if (x == orig_x)
          {
            // fix me: this doesn't work: consider Num<10> 0x155 right rotated by 2 = 0x155.
            cout << "Warning: (12a) occurred in left rotating "<<orig_x.str(PHex)<<"("<<size1<<") by "<<n<<"; produced "<<x.str(PHex)<<endl; 
            // rc = 1
          }
        x = x.right_rotate(n);
        if (x != orig_x) {
          cout << "Error (12b) occurred in left & right rotating "<<orig_x.str(PHex)<<"("<<size1<<") by "<<n<<"; produced "<<x.str(PHex)<<endl;
          rc = 1;
                
        }
      }

        
    if (n && (n != size1))
      {
        x = x.left_rotate(i_n);
        if (x == orig_x)
          {
            // fix me: this doesn't work: consider Num<10> 0x155 right rotated by 2 = 0x155.
            cout << "Warning: (12a) occurred in left rotating "<<orig_x.str(PHex)<<"("<<size1<<") by "<<n<<"; produced "<<x.str(PHex)<<endl; 
            // rc = 1
          }
        x = x.right_rotate(i_n);
        if (x != orig_x) {
          cout << "Error (12b) occurred in left & right rotating "<<orig_x.str(PHex)<<"("<<size1<<") by "<<n<<"; produced "<<x.str(PHex)<<endl;
          rc = 1;
                
        }
      }	

    // We can only do this test for even-byte quantities, b/c otherwise the
    // shifting will throw off the value.
    if ( (size1 % 8) == 0 ) {
      tmp = orig_x.swap_bytes();
      x   = tmp.swap_bytes();
      if( x != orig_x )
        {
          cout << "Error (13) occurred in byte swapping "<<orig_x.str(PHex)<<"("<<size1<<") ; produced "<<x.str(PHex)<<endl;
          rc = 1; 
        }
    }
  }
    
  return rc;
}    
    
template <size_t size1>
unsigned tests::checkSetAlls () 
{  
    unsigned rc = 0;
    const int PHex = (ihex | iprefix);
    Num<size1> a (0);
    a . set ();
    Num<size1> b (0);
    b -= 1;
    if (a != b ) {
        cout << "Error occurred in set("<<size1<<"); produced "<<a.str(PHex)<<endl;
        rc = 1;
    }
    return rc;
}

template <size_t size1>
unsigned tests::checkClearAlls ()       {
  unsigned rc = 0; 
  const int PHex = (ihex | iprefix);
  Num<size1> a (0);
  a . set ();
  Num<size1> b (0);
  b -= 1;
  if (a != b ) {
    cout << "Error occurred in set("<<size1<<"); produced "<<a.str(PHex)<<endl;
    rc = 1;
  }

  return rc;
}

template <size_t size1>
unsigned tests::checkGetInts ()     
{  
  unsigned rc = 0;
  if (size1 <= 32) {
    // only applicable for size <= 32
    
    Num<size1> a =genRandom<size1>();
    unsigned ai = a . uint32 ();
    unsigned shift = (size1 > 32) ? size1 - 32 : 0;
    Num<size1> b = (a << shift) >> shift;
    
    if ((UNum<size1>)b != ai) {
      cout << "Error occurred in getInt on "<<hex<<a<<"("<<dec<<size1<<"); produced "<<hex<<ai<<endl;
      rc = 1;
    }
  }

  return rc;
}

template <size_t size1,size_t size2>
unsigned tests::checkLogicalOp (const Num<size1>& a, int b, const Num<size2>& res1, unsigned res2, const char *op)
{
  Num<size2> res_tmp (res2);    
  return checkLogicalOp(a,b,res1,res_tmp,op);
}
template <size_t size1,size_t size2,size_t size3>
unsigned tests::checkLogicalOp (const Num<size1>& a, const Num<size2>& b, const Num<size3>& res1, unsigned res2, const char *op)
{
  Num<size3> res_tmp (res2);    
  return checkLogicalOp(a,b,res1,res_tmp,op);
}

template <size_t size1,size_t size2,size_t size3,size_t size4>
unsigned tests::checkLogicalOp (const Num<size1>& a, const Num<size2>& b, const Num<size3>& res1, const Num<size4>& res2, const char *op)
{
  // Num op Num
  unsigned rc = (res1 != res2);

  if (rc) {
    cout << "Error (1) occurred in expression: " << a << op << b << endl;
    cout << "         res = " << res1 << endl;
    cout <<"expected res = " << res2 << endl;
  }

  return rc;
}

template <size_t size1,size_t size2,size_t size3>
unsigned tests::checkLogicalOp (const Num<size1>& a, int b, const Num<size2>& res1, const Num<size3>& res2, const char *op)
{
  // Num op int  
  unsigned rc = (res1 != res2);
  if (rc) {
    cout << "Error (2) occurred in expression: " << a << op << b << endl;
    cout << "         res = " << res1 << endl;
    cout <<"expected res = " << res2 << endl;
  }
  return rc;
}  

template <size_t size1,size_t size2>
unsigned tests::checkLogicals ()
{       
  unsigned rc = 0;
  assert (size2 >= size1);
  for (int i = 0; i < maxIter; i++) {  
    Num<size1> a =genRandom<size1>();
    Num<size2> b =genRandom<size2>();
    Num<size1> b0 (0);
    Num<size1> b1 (0);
    b1 . set ();
    Num<size2> c0 (0);
    Num<size2> c1 (0);
    c1 . set ();
    Num<size1> tmpa (a);
    Num<size2> tmpb (b);
    Num<size2> tmpc0(c0);
    Num<size2> tmpc1(c1);     

    // check & and &= using (x & zero), (x & ones), (zero & x), and (ones & x) with
    // different sizes of x, zero, and ones:
    //   & operands have same size
    rc |= checkLogicalOp (a, b0, (a & b0), 0, "&");
    a &= b0;    
    rc |= checkLogicalOp (tmpa, b0, a, 0, "&=");
    a = tmpa;
    rc |= checkLogicalOp (a, b1, (a & b1), a, "&");
    a &= b1;
    rc |= checkLogicalOp (tmpa, b1, a, tmpa, "&=");
    //   smaller & larger
    rc |= checkLogicalOp (a, c0, (a & c0), 0, "&");
    a &= c0;
    rc |= checkLogicalOp (tmpa, c0, a, 0, "&=");
    a = tmpa;
    rc |= checkLogicalOp (a, c1, (a & c1), a, "&");
    a &= c1;
    rc |= checkLogicalOp (tmpa, c1, a, tmpa, "&=");
    a = tmpa;
    //   larger & smaller
    rc |= checkLogicalOp (c0, a, (c0 & a), 0, "&");
    c0 &= a;
    rc |= checkLogicalOp (tmpc0, a, c0, 0, "&=");
    c0 = tmpc0;
    rc |= checkLogicalOp (c1, a, (c1 & a), a, "&");
    c1 &= a;
    rc |= checkLogicalOp (tmpc1, a, c1, a, "&=");
    c1 = tmpc1;
    //   & with integer
    // fix me: turn back on when sign extension is implemented 
    //   b &= ((unsigned)-1);
    //   rc |= checkLogicalOp (tmpb, -1, b, tmpb , "&=");
    //   rc |= checkLogicalOp (b, 0, b & 0, 0, "&");
    //   b &= 0;
    //   rc |= checkLogicalOp (tmpb, 0, b, 0, "&=");
    //   b = tmpb;
    //   rc |= checkLogicalOp (b, -1, b & ((unsigned)-1), b , "&");
    
    b = tmpb;
        
    // check | and |= using (x | ones) and (ones | x) withc
    // different sizes of x and ones:
    //   | operands have same size
    rc |= checkLogicalOp (a, b1, (a | b1), b1, "|");
    a |= b1;
    rc |= checkLogicalOp (tmpa, b1, a, b1, "|=");
    a = tmpa;
    //   smaller | larger
    rc |= checkLogicalOp (a, c1, (a | c1), c1, "|");
    a |= c1;
    rc |= checkLogicalOp (tmpa, c1, a, b1, "|=");
    a = tmpa;
    //   larger | smaller
    rc |= checkLogicalOp (c1, a,(c1 | a), c1, "|");
    c1 |= a;
    rc |= checkLogicalOp (tmpc1, a, c1, tmpc1, "|=");
    c1 = tmpc1;
    //   | with integer
    //   & with integer
    // fix me: turn back on when sign extension is implemented 
    //    Num<size2> tmp1 = b;
    //    tmp1  (size2 - 32, size2 - 1, (unsigned)-1);
    //    rc |= checkLogicalOp (b, -1, b | ((unsigned)-1), tmp1, "|");
    //    b |= ((unsigned)-1);
    //    rc |= checkLogicalOp (tmpb, -1, b, tmp1, "|=");
   
    b = tmpb;
        
    // check ^ and ^= using (x ^ x), (x ^ zero), (x ^ ones), (zero ^ x), and (ones ^ x) with
    // different sizes of x, zero, and ones:
    //   ^ operands have same size
    rc |= checkLogicalOp (a, a, (a ^ a), 0, "^");
    a ^= a;
    rc |= checkLogicalOp (tmpa, tmpa, a, 0, "^=");
    a = tmpa;
    rc |= checkLogicalOp (a, b0, (a ^ b0), a, "^");
    a ^= b0;
    rc |= checkLogicalOp (tmpa, b0, a, tmpa, "^=");
    a = tmpa;
    rc |= checkLogicalOp (a, b1, (a ^ b1), ~a, "^");
    a ^= b1;
    rc |= checkLogicalOp (tmpa, b1, a, ~tmpa, "^=");
    a = tmpa;
    //   smaller ^ larger
    rc |= checkLogicalOp (a, c0,( a ^ c0), a, "^");
    a ^= c0;
    rc |= checkLogicalOp (tmpa, c0, a, tmpa, "^=");
    a = tmpa;
    Num<size2> aa (a);
    rc |= checkLogicalOp (a, c1,( a ^ c1), ~aa, "^");
    a ^= c1;
    rc |= checkLogicalOp (tmpa, c1, a, ~tmpa, "^=");
    a = tmpa;
    //   larger ^ smaller
    rc |= checkLogicalOp (c0, a, (c0 ^ a), a, "^");
    c0 ^= a;
    rc |= checkLogicalOp (tmpc0, a, c0, a, "^=");
    c0 = tmpc0;
    Num<size2> tmp2 = a;
    // set the ~a into the lower field of tmp2
    tmp2 = ~tmp2;
    rc |= checkLogicalOp (c1, a, (c1 ^ a), tmp2, "^");
    c1 ^= a;
    rc |= checkLogicalOp (tmpc1, a, c1, tmp2, "^=");  
    c1 = tmpc1;
        
    //   ^ with integer
    //   & with integer
    // fix me: turn back on when sign extension is implemented 
    //   Num<size2> tmp3 = b;
    //   // set all but lowest word to ones
    //   tmp3  (size2 - 32, size2 - 1,(unsigned) -1);
    //   unsigned num3 = ~ (b.uint32());
    //   rc |= checkLogicalOp (b, num3, b ^ num3, tmp3, "^");
    //   b ^= num3;
    //   rc |= checkLogicalOp (tmpb, num3, b, tmp3, "^=");
    //   b = tmpb;
    //   rc |= checkLogicalOp (b, 0, b ^ 0, b, "^");
    //   b ^= 0;
    //   rc |= checkLogicalOp (tmpb, 0, b, tmpb, "^=");
    
    b = tmpb;
  }        
  return rc;
}


//====================================

void usage (const char *pgm)
{
  cout << "Usage:  "<<pgm<<" [-seed n] [-n] [-dcpath <path to dc] [-dc <dc program>]\n";
  exit (1);
}
int _argc;
const char **_argv;
int _cur;

const char *curArg()
{
  return _argv[_cur];
}

const char *nextArg()
{
  ++_cur;
  if (_cur >= _argc) {
    throw runtime_error(string("Error:  Expected an argument for option '")+_argv[_cur-1]+"'.");
  }
  return _argv[_cur];
}

int pMain(int, char const**)
{ return 0; }



void test ()
{

  Num<64> db = 0x12345678deadbeefULL;

  ostringstream ss2;
  ss2.setf(std::ios_base::hex);
  db . printToOS(ss2);

  const int PHex = (ihex | iprefix);

  cout << "db.str() = "<<db.str(PHex)<<endl;
  
}

int main (int argc, const char **argv)
{   
  cout << "NumberTest" << endl;
  // The perl test driver will take this file and insert
  // all the templatized calls for the sizes we want to test
  // PERL:1,32,64,128,10,31,33,100
  // P: 1,64  // comment out t.checkConcatenation() if you scale down here

  test();

  unsigned rc = 0;

  string path = "/usr/bin";
  string prog = "dc";
  string pgm;
   
  // process command line args
  AnyOption options(argc,argv);
  options.addUsage(":  [options] <source>");
  options.setFlag("help","h","Display help");
  options.setOption("seed","seed to initialize random number generator.");
  options.setOption("n","maximum number of iterations for each test.");
  options.setOption("dc","path to digital calculator.");
  if (!options.processCommandLine()) {
    return 1;
  }
  if (options.getFlag("h")) {
    options.printUsage();
    return 0;
  }

  
  unsigned seed = atoi( options.getOption("seed").c_str());
  if (seed == 0)
    seed = time(NULL);
  
  maxIter = atoi(options.getOption("n").c_str()); ;
  if (maxIter == 0)
    maxIter = 100;
  
  
  /*
    string opt = options.getOption("dcpath");
    if (!opt.empty())
    path = opt;
        
    opt = options.getOption("dc");
    if (!opt.empty())
    pgm = opt; 
    else */
  
  pgm = path + "/" + prog;
  
  

  Calculator calc(pgm.c_str());
  tests t(seed);
  cout << " seed:  "<<seed<<endl;

  // construct/resize/set/operator=
  cout<<"Starting constructors..."<<endl;
  rc |= t.checkConstructors ();

  // check byte-swapping.  This is just a single test b/c I wasn't sure of a good
  // way to check this in an automatic way.
  cout<<"Starting byte swaps..."<<endl;
  rc |= t.checkByteSwaps ();

  // check word-swapping.
  cout<<"Starting word swaps..."<<endl;
  rc |= t.checkWordSwaps ();
  
  // check population count
  cout<<"Starting pop counts..."<<endl;
  rc |= t.checkPopCounts ();

  // check count-leading-zeros
  cout<<"Starting count-leading-zeros..."<<endl;
  rc |= t.checkCountLeadingZeros ();

  // concatenation
  cout<<"Starting concatenation..."<<endl;
  rc |= t.checkConcatenation ();
                                                                                                                                      
  // add
  cout<<"Starting adds..."<<endl;
  rc |= t.checkOperator ( "+", &calc);
  rc |= t.checkMutator ( "+=", &calc);
                                                                                                                                     
  // subtract
  cout<<"Starting subtracts..."<<endl;
  rc |= t.checkOperator ( "-", &calc);
  rc |= t.checkMutator ( "-=", &calc);
                                                                                                                                      
  // multiply
  cout<<"Starting multiplies..."<<endl;
  rc |= t.checkOperator ( "*", &calc);
  rc |= t.checkMutator ( "*=", &calc);
                                                                                                                                      
  // divide
  cout<<"Starting divides..."<<endl;
  rc |= t.checkOperator ( "/", &calc);
  rc |= t.checkMutator ( "/=", &calc);
         
  if(!SIGNED) { 
    // signed multiply & divide
    cout<<"Starting signed multiplies..."<<endl;
    rc |= t.checkOperator ("*",&calc,true);
    rc |= t.checkMutator ( "*=", &calc,true);

    cout<<"Starting signed divides..."<<endl;
    rc |= t.checkOperator ("/",&calc,true);
    rc |= t.checkMutator ( "/=", &calc,true);

  }
  // modulus"<<endl;
  cout<<"Starting mods..."<<endl;
  rc |= t.checkOperator ( "%", &calc);
  rc |= t.checkMutator ( "%=", &calc);
                                                                                                                                      
                                                                                                                                      
  cout<<"Starting <..." << endl;
  rc |= t.checkComparator ( "<", &calc, SIGNED);
                                                                                                                                      
                                                                                                                                      
  cout<<"Starting <=..." << endl;
  rc |= t.checkComparator ( "<=", &calc, SIGNED);

  cout<<"Starting >..."  << endl;
  rc |= t.checkComparator ( ">", &calc, SIGNED);
                                                                                                                                      
                                                                                                                                      
  cout<<"Starting >=..." << endl;
  rc |= t.checkComparator ( ">=", &calc, SIGNED);
                                                                                                                                      
                                                                                                                                      
  // ==
  cout<<"Starting ==..."<<endl;
  rc |= t.checkComparator ( "==", &calc, SIGNED);
                                                                                                                                      
                                                                                                                                      
  // !=
  cout<<"Starting !=..."<<endl;
  rc |= t.checkComparator ( "!=", &calc, SIGNED);
                                                                                                                                     
#if !SIGNED
  // signedGT
  cout<<"Starting signedGT..."<<endl;
  rc |=  t.checkSignedComparator ( "GT", &calc);

  // signedGE
  cout<<"Starting signedGE..."<<endl;
  rc |=  t.checkSignedComparator ( "GE", &calc);

  // signedLT
  cout<<"Starting signedLT..."<<endl;
  rc |=  t.checkSignedComparator ( "LT", &calc);

  // signedLE
  cout<<"Starting signedLE..."<<endl;
  rc |=  t.checkSignedComparator ("LE", &calc);

#endif                                                                                                                                     

  // get bit
  // set bit
  cout<<"Starting bit accessors..."<<endl;
  rc |= t.checkBitAccessors ();


  // get field
  // set field
  cout<<"Starting field accessors..."<<endl;
  rc |= t.checkFieldAccessors ();

  // sign extend
  cout<<"Starting sign extensions..."<<endl;
  rc |= t.checkSignExtends ();
                                                                                                                                      
  // invert
  // negate
  // not
  cout<<"Starting inversions..."<<endl;
  rc |= t.checkInversions ();
                                                                                                                                      
                                                                                                                                      
  // left shift
  // right shift
  cout<<"Starting shifts..."<<endl;
  rc |= t.checkShifts ();

  // setAll
  cout<<"Starting setAlls..."<<endl;
  rc |= t.checkSetAlls ();
                                                                                                                                      
                                                                                                                                      
  // clearAll
  cout<<"Starting clearAlls..."<<endl;
  rc |= t.checkClearAlls ();
                                                                                                                                      
                                                                                                                                      
  // getInt
  cout<<"Starting getInts..."<<endl;
  rc |= t.checkGetInts ();
                                                                                                                                      
  // and
  // or
  // xor
  cout<<"Starting logicals..."<<endl;
  rc |= t.checkLogicals ();

  // miscellaneous
  cout<<"Starting misc..."<<endl;
  rc |= t.checkMisc (); 

/////////////////////////////////////////////////////////////////////////////////////////////////

  if (rc) {
    cout << "Errors were found.  Seed used was " << dec << seed << endl;
  } else {
    cout << "All tests passed.  Seed used was " << dec << seed << endl;
  }
  
  return rc;
}




Calculator::Calculator (const char *pgm)
{
  _pgm = pgm;

  if (pipe (_fd1) < 0 || pipe (_fd2) < 0) {
    cout << "Error creating pipe." << endl;
    exit (1);
  }
  
  pid_t pid;
  if ((pid = fork ()) < 0) {
    cout << "Fork error." << endl;
    exit (1);
  }
  else if (pid > 0) {    // parent
    close (_fd1[0]);
    close (_fd2[1]);
  }
  else {                 // child
    close (_fd1[1]);
    close (_fd2[0]);
    if (_fd1[0] != 0)
      dup2 (_fd1[0], 0);
    if (_fd2[1] != 2)
      dup2 (_fd2[1], 1);
    if (execl (pgm, _pgm, NULL) < 0) {
      cout << "Exec error." << endl;
      exit (1);
    }
  }

  init ();
}

Calculator::~Calculator ()
{
  terminate ();
}

static void negative (char *str,size_t size)
{
  if (size > 1) {
    //  prepend the _ (dc uses _ as negative)
    string s ("_"); 
    s += str;
    strcpy (str,s.c_str());;
  }
}

template <size_t size1>
static void getNumStr(char *str,Num<size1> x,bool ext)
{
  const int PHex = (ihex | iupper);

  if (ext && x.get(msb(size1))) {
    x.negate();
    strcpy (str, x . str (PHex) . c_str());
    negative(str,size1);
  } else {
    strcpy (str, x . str (PHex) . c_str());
  }

}
#if SIGNED
template <size_t size1>
static void getNumStr(char *str,UNum<size1> x,bool ext)
{
  const int PHex = (ihex | iupper);

  if (ext && x.get(msb(size1))) {
    x.negate();
    strcpy (str, x . str (PHex) . c_str());
    negative(str,size1);
  } else {
    strcpy (str, x . str (PHex) . c_str());
  }

}
#endif
// Verify arithmetic using the external calculator.  This is for Num tests.
// If ext is true, we allow for resizing.
template <size_t size1, size_t size2, size_t size3>
unsigned Calculator::checkArith (Num<size1> a, Num<size2> b,
                                 const Num<size3>& c, const char *op, bool ext)
{
  char astr[256];
  char bstr[256];

  assert (a . size () <= 1024 && b . size () <= 1024);

  // We have to remove the 0x prefix b/c dc does not understand that syntax.
  // We also remove the sign bit and add the negative sign for dc (this only
  // applies to signed multiply where we only want to multiply the matissas).
  getNumStr(astr,a,ext);
  getNumStr(bstr,b,ext);

  return arithCalc(astr,a.size(),bstr,b.size(),c,op,false);
}
#if SIGNED
template <size_t size1, size_t size2, size_t size3>
unsigned Calculator::checkArith (Num<size1> a, UNum<size2> b,
                                 const UNum<size3>& c, const char *op, bool ext)
{
  char astr[256];
  char bstr[256];

  assert (a . size () <= 1024 && b . size () <= 1024);

  // We have to remove the 0x prefix b/c dc does not understand that syntax.
  // We also remove the sign bit and add the negative sign for dc (this only
  // applies to signed multiply where we only want to multiply the matissas).
  getNumStr(astr,a,ext);
  getNumStr(bstr,b,ext);

  return arithCalc(astr,a.size(),bstr,b.size(),(Num<size3>)c,op,false);
}

template <size_t size1, size_t size2, size_t size3>
unsigned Calculator::checkArith (UNum<size1> a, Num<size2> b,
                                 const UNum<size3>& c, const char *op, bool ext)
{
  char astr[256];
  char bstr[256];

  assert (a . size () <= 1024 && b . size () <= 1024);

  // We have to remove the 0x prefix b/c dc does not understand that syntax.
  // We also remove the sign bit and add the negative sign for dc (this only
  // applies to signed multiply where we only want to multiply the matissas).
  getNumStr(astr,a,ext);
  getNumStr(bstr,b,ext);

  return arithCalc(astr,a.size(),bstr,b.size(),(Num<size3>)c,op,false);
}
#endif
/*
template <size_t size1,size_t size2>
unsigned Calculator::checkArith (uint32_t a, Num<size1> b, const Num<size2>& c,
                                 char *op, bool ext)
{
  char astr[256];
  char bstr[256];
  getNumStr(bstr,b,ext);
  
  if (ext && (int32_t)(a) < 0) {
    sprintf (astr, "_%X", -((int32_t)a));
  } else {
    sprintf (astr, "%X", a);
  }
  unsigned exp_size = max(b.size(), (size_t)32);
  
  if ( !ext && (op[0] != '%' && c.size() != exp_size )) {
    cout << "Result size error (2) occurred in expression:  " << astr << "(" << b.size()<<") "
         << bstr << "(32) (" <<c.size() << ") " << op << endl;
    return 1;
  }
  return arithCalc(astr,sizeof(unsigned)*8,bstr,b.size(),c,op,false);
}

template <size_t size1,size_t size2>
unsigned Calculator::checkArith (Num<size1> a, uint32_t b, const Num<size2>& c,
                                 char *op, bool ext)
{
  char astr[256];
  char bstr[256];
  
  getNumStr(astr,a,ext);
  
  if (ext&& (int32_t)b < 0) {
    sprintf (bstr, "_%X", -b);
  } else {
    sprintf (bstr, "%X", b);
  }
  
  unsigned exp_size = max(a.size(), (size_t)32);

  if ( !ext && (op[0] != '%' && c.size() != exp_size )) 
    {
      cout << "Result size error (2) occurred in expression:  "<<astr<<"("<<a.size()<<") "<<bstr<<"(32) ("<<c.size()<<") "<<op<<endl;
      return 1;
    }

  return arithCalc(astr,a.size(),bstr,sizeof(unsigned)*8,c,op,false);
}
*/
template <size_t size1,size_t size2>
unsigned Calculator::checkArith (int32_t a, Num<size1> b, const Num<size2>& c,
                                 const char *op, bool ext)
{
  char astr[256];
  char bstr[256];
  getNumStr(bstr,b,ext);
  
  if ( a < 0) {
    sprintf (astr, "_%X", -a);
  } else {
    sprintf (astr, "%X", a);
  }
  unsigned exp_size = max(b.size(), (size_t)32);
  
  if ( !ext && (op[0] != '%' && c.size() != exp_size )) {
    cout << "Result size error (2) occurred in expression:  " << astr << "(" << b.size()<<") "
         << bstr << "(32builtin) (" <<c.size() << ") " << op << endl;
    return 1;
  }
  return arithCalc(astr,sizeof(unsigned)*8,bstr,b.size(),c,op,false);
}

template <size_t size1,size_t size2>
unsigned Calculator::checkArith (Num<size1> a, int32_t b, const Num<size2>& c,
                                 const char *op, bool ext)
{
  char astr[256];
  char bstr[256];

  getNumStr(astr,a,ext);

  if ( b < 0) {
    sprintf (bstr, "_%X", -b);
  } else {
    sprintf (bstr, "%X", b);
  }  

  unsigned exp_size = max(a.size(), (size_t)32);

  if ( !ext && (op[0] != '%' && c.size() != exp_size )) 
    {
      cout << "Result size error (2) occurred in expression:  "<<astr<<"("<<a.size()<<") "<<bstr<<"(32builtin) ("<<c.size()<<") "<<op<<endl;
      return 1;
    }

  return arithCalc(astr,a.size(),bstr,sizeof(unsigned)*8,c,op,false);
}

template <size_t size1,size_t size2>
unsigned Calculator::checkArith (uint64_t a, Num<size1> b, const Num<size2>& c,
                                 const char *op, bool ext)
{
  char astr[256];
  char bstr[256];
  getNumStr(bstr,b,ext);
  
  if (ext && (int64_t)(a) < 0) {
    sprintf (astr, "_%" PRIX64, -((int64_t)a));
  } else {
    sprintf (astr, "%" PRIX64, a);
  }
  unsigned exp_size = max(b.size(), (size_t)64);
  
  if ( !ext && (op[0] != '%' && c.size() != exp_size )) {
    cout << "Result size error (2) occurred in expression:  " << astr << "(" << b.size()<<") "
         << bstr << "(64builtin) (" <<c.size() << ") " << op << endl;
    return 1;
  }
  return arithCalc(astr,sizeof(uint64_t)*8,bstr,b.size(),c,op,false);
}

template <size_t size1,size_t size2>
unsigned Calculator::checkArith (Num<size1> a, uint64_t b, const Num<size2>& c,
                                 const char *op, bool ext)
{
  char astr[256];
  char bstr[256];

  getNumStr(astr,a,ext);

  if (ext && (int64_t)(b) < 0) {
    sprintf (bstr, "_%" PRIX64, -((int64_t)b));
  } else {
    sprintf (bstr, "%" PRIX64, b);
  }  

  unsigned exp_size = max(a.size(), (size_t)64);

  if ( !ext && (op[0] != '%' && c.size() != exp_size )) 
    {
      cout << "Result size error (2) occurred in expression:  "<<astr<<"("<<a.size()<<") "<<bstr<<"(64builtin) ("<<c.size()<<") "<<op<<endl;
      return 1;
    }

  return arithCalc(astr,a.size(),bstr,sizeof(uint64_t)*8,c,op,false);
}
// Performs the specified calculation and compares the result
// to c.
// astr:  Printed number ready to hand to calculator.
// asize: a's size in bits.
// bstr:  Printed number ready to hand to calculator.
// bsize: b's size in bits.
// c:     Expected result.
// op:    Operator to use in calculation.
template <size_t size>
unsigned Calculator::arithCalc (const char *astr,unsigned asize,
                                const char *bstr,unsigned bsize,
                                const Num<size> &res,const char *op,
                                bool extend)
{
  unsigned rc = 0;
  //const int PHex = (ihex | iprefix);                                                                                                                                                                              
  char cmd[1024];
  char buf[1024];
  sprintf (cmd, "%s %s %c p c\n", astr, bstr, op[0]);
  
  //cout << cmd;
  //cout << hex << res << endl << endl;
  
  int n = strlen (cmd);
  if (write (_fd1[1], cmd, strlen (cmd)) != n) {
    cout << "Write error." << endl;
    exit (1);
  }
  n = 0;
  buf[0] = '\0';
  do {
    int len = read (_fd2[0], buf + n, 1024);
    if (len < 0) {
      cout << "Read error." << endl;
      exit (1);
    }
    n += len; 
  } while (n == 0 || buf[n-1] != '\n');
  buf[n] = '\0';
    
  Num<size> dc_res(0);
    
  if (!extend) {
    if (buf[0] == '-') {
      dc_res = Num<size>( buf + 1, ihex );
      // take the complement
      dc_res.negate();
    }
    else {   
      Num<size> tmp ( buf, ihex );
      dc_res = tmp;
    }
  } 
    
  if (res != dc_res) {
    cout << "Error (3) occurred in expression:  "<<astr<<"("<<asize<<") "<<bstr<<"("<<bsize<<") "<<op<<"\n"
         << "  Num<" << size << "> res = "<< hex << endl 
	 << res << ", dc res = " << endl << dc_res << dec << endl;
    rc = 1;
  }    
    
  return rc;
}

template <size_t size1,size_t size2>
unsigned Calculator::checkComparator (const Num<size1>& a, const Num<size2>& b, int res, const char *op,bool ext)
{
  char astr[256];
  char bstr[256];
  unsigned rc = 0;

  getNumStr(astr,a,ext);
  getNumStr(bstr,b,ext);
    
  char cmd[1024];
  char buf[1024];
  sprintf (cmd, "%s %s - p c\n", astr, bstr);
  int n = strlen (cmd);
  if (write (_fd1[1], cmd, strlen (cmd)) != n) {
    cout << "Write error." << endl;
    exit (1);
  }
  n = 0;
  buf[0] = '\0';
  do {
    int len = read (_fd2[0], buf + n, 1024);
    if (len < 0) {
      cout << "Read error." << endl;
      exit (1);
    }
    n += len;
  } while (n == 0 || buf[n-1] != '\n');
  buf[n] = '\0';
  
  if (strcmp (op, "<") == 0 ) {
    if (res)
      rc = (buf[0] == '-');
    else
      rc = (buf[0] != '-' || strcmp (buf, "0\n") == 0);
  }
  else if (strcmp (op, "<=") == 0) {
    if (res)
      rc = (buf[0] == '-' || strcmp (buf, "0\n") == 0);
    else
      rc = (buf[0] != '-' && strcmp (buf, "0\n") != 0);
  }
  else if (strcmp (op, ">") == 0) {
    if (res)
      rc = (buf[0] != '-');
    else
      rc = (buf[0] == '-' || strcmp (buf, "0\n") == 0);
  }
  else if (strcmp (op, ">=") == 0) {
    if (res)
      rc = (buf[0] != '-');
    else
      rc = (buf[0] == '-' || strcmp (buf, "0\n") == 0);
  }
  else if (strcmp (op, "==") == 0) {
    if (res)
      rc = (strcmp (buf, "0\n") == 0);
    else
      rc = (strcmp (buf, "0\n") != 0);
  }
  else if (strcmp (op, "!=") == 0) {
    if (res)
      rc = (strcmp (buf, "0\n") != 0);
    else
      rc = (strcmp (buf, "0\n") == 0);
  }
  
  else
    assert (0);
  
  if (! rc) {
    cout << "Error (4) occurred in expression:  "<<astr<<"("<<a.size()<<") "<<bstr<<"("<<b.size()<<") "<<op<<"\n"
         << "  Num<size> res = "<<res<<", subtract output = "<<buf<<endl;
    cout << hex<<"a="<<a<<", b="<<b<<endl;
    rc = 1;
  }
  else
    rc = 0;
  
  return rc;
}

template <size_t size1>
unsigned Calculator::checkComparator (const Num<size1>& a, unsigned b, int res, const char *op,bool ext)
{
  char astr[256];
  char bstr[256];
  unsigned rc = 0;

  getNumStr(astr,a,ext);
  sprintf (bstr, "%X", b);

  char cmd[1024];
  char buf[1024];
  sprintf (cmd, "%s %s - p c\n", astr, bstr);
  int n = strlen (cmd);
  if (write (_fd1[1], cmd, strlen (cmd)) != n) {
    cout << "Write error." << endl;
    exit (1);
  }

  buf[0] = '\0';
  n = 0;
  do {
    int len = read (_fd2[0], buf + n, 1024);
    if (len < 0) {
      cout << "Read error." << endl;
      exit (1);
    }
    n += len;
  } while (n == 0 || buf[n-1] != '\n');
  buf[n] = '\0';

  if (strcmp (op, "<") == 0 ) {
    if (res)
      rc = (buf[0] == '-');
    else
      rc = (buf[0] != '-' || strcmp (buf, "0\n") == 0);
  }
  else if (strcmp (op, "<=") == 0) {
    if (res)
      rc = (buf[0] == '-' || strcmp (buf, "0\n") == 0);
    else
      rc = (buf[0] != '-' && strcmp (buf, "0\n") != 0);
  }
  else if (strcmp (op, ">") == 0) {
    if (res)
      rc = (buf[0] != '-');
    else
      rc = (buf[0] == '-' || strcmp (buf, "0\n") == 0);
  }
  else if (strcmp (op, ">=") == 0) {
    if (res)
      rc = (buf[0] != '-');
    else
      rc = (buf[0] == '-' || strcmp (buf, "0\n") == 0);
  }
  else if (strcmp (op, "==") == 0) {
    if (res)
      rc = (strcmp (buf, "0\n") == 0);
    else
      rc = (strcmp (buf, "0\n") != 0);
  }
  else if (strcmp (op, "!=") == 0) {
    if (res)
      rc = (strcmp (buf, "0\n") != 0);
    else
      rc = (strcmp (buf, "0\n") == 0);
  }
  else
    assert (0);

  if (! rc) {
    cout << "Error (5) occurred in expression:  "<<astr<<"("<<a.size()<<") "<<bstr<<" "<<op<<"\n"
         << "  Num<size> res = "<<res<<", subtract output = "<<buf<<endl;
    rc = 1;
  }
  else
    rc = 0;

  return rc;
}

void Calculator::init ()
{
  const char *str = "16 o 16 i\n";
  int n = strlen (str);
  if (write (_fd1[1], str, strlen (str)) != n) {
    cout << "Write error in init." << endl;
    exit (1);
  }
}

void Calculator::terminate ()
{
  const char *str = "q\n";
  int n = strlen (str);
  if (write (_fd1[1], str, strlen (str)) != n) {
    cout << "Write error in init." << endl;
    exit (1);
  }
}
